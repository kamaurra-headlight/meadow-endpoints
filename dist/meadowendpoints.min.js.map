{"version":3,"sources":["node_modules/browser-pack/_prelude.js","meadowendpoints.min.js","node_modules/JSONStream/index.js","node_modules/async/asyncify.js","node_modules/async/eachLimit.js","node_modules/async/eachSeries.js","node_modules/async/internal/breakLoop.js","node_modules/async/internal/doLimit.js","node_modules/async/internal/eachOfLimit.js","node_modules/async/internal/getIterator.js","node_modules/async/internal/initialParams.js","node_modules/async/internal/iterator.js","node_modules/async/internal/once.js","node_modules/async/internal/onlyOnce.js","node_modules/async/internal/setImmediate.js","node_modules/async/internal/slice.js","node_modules/async/internal/withoutIndex.js","node_modules/async/internal/wrapAsync.js","node_modules/async/waterfall.js","node_modules/available-typed-arrays/index.js","node_modules/base64-js/index.js","node_modules/buffer/index.js","node_modules/builtin-status-codes/browser.js","node_modules/call-bind/callBound.js","node_modules/call-bind/index.js","node_modules/events/events.js","node_modules/for-each/index.js","node_modules/foxhound/source/FoxHound.js","node_modules/foxhound/source/Foxhound-Dialects.js","node_modules/foxhound/source/Parameters.js","node_modules/foxhound/source/dialects/ALASQL/FoxHound-Dialect-ALASQL.js","node_modules/foxhound/source/dialects/English/FoxHound-Dialect-English.js","node_modules/foxhound/source/dialects/MeadowEndpoints/FoxHound-Dialect-MeadowEndpoints.js","node_modules/foxhound/source/dialects/MySQL/FoxHound-Dialect-MySQL.js","node_modules/function-bind/implementation.js","node_modules/function-bind/index.js","node_modules/generate-function/index.js","node_modules/generate-object-property/index.js","node_modules/get-intrinsic/index.js","node_modules/gopd/index.js","node_modules/has-symbols/index.js","node_modules/has-symbols/shams.js","node_modules/has-tostringtag/shams.js","node_modules/has/src/index.js","node_modules/https-browserify/index.js","node_modules/ieee754/index.js","node_modules/inherits/inherits_browser.js","node_modules/is-arguments/index.js","node_modules/is-callable/index.js","node_modules/is-generator-function/index.js","node_modules/is-my-ip-valid/index.js","node_modules/is-my-json-valid/formats.js","node_modules/is-my-json-valid/index.js","node_modules/is-property/is-property.js","node_modules/is-typed-array/index.js","node_modules/jsonparse/jsonparse.js","node_modules/jsonpointer/jsonpointer.js","node_modules/lodash/_Symbol.js","node_modules/lodash/_arrayLikeKeys.js","node_modules/lodash/_baseGetTag.js","node_modules/lodash/_baseIsArguments.js","node_modules/lodash/_baseIsTypedArray.js","node_modules/lodash/_baseKeys.js","node_modules/lodash/_baseTimes.js","node_modules/lodash/_baseUnary.js","node_modules/lodash/_freeGlobal.js","node_modules/lodash/_getRawTag.js","node_modules/lodash/_isIndex.js","node_modules/lodash/_isPrototype.js","node_modules/lodash/_nativeKeys.js","node_modules/lodash/_nodeUtil.js","node_modules/lodash/_objectToString.js","node_modules/lodash/_overArg.js","node_modules/lodash/_root.js","node_modules/lodash/isArguments.js","node_modules/lodash/isArray.js","node_modules/lodash/isArrayLike.js","node_modules/lodash/isBuffer.js","node_modules/lodash/isFunction.js","node_modules/lodash/isLength.js","node_modules/lodash/isObject.js","node_modules/lodash/isObjectLike.js","node_modules/lodash/isTypedArray.js","node_modules/lodash/keys.js","node_modules/lodash/noop.js","node_modules/lodash/stubFalse.js","node_modules/meadow/node_modules/async/asyncify.js","node_modules/meadow/node_modules/async/eachLimit.js","node_modules/meadow/node_modules/async/eachSeries.js","node_modules/meadow/node_modules/async/internal/asyncEachOfLimit.js","node_modules/meadow/node_modules/async/internal/awaitify.js","node_modules/meadow/node_modules/async/internal/breakLoop.js","node_modules/meadow/node_modules/async/internal/eachOfLimit.js","node_modules/meadow/node_modules/async/internal/getIterator.js","node_modules/meadow/node_modules/async/internal/initialParams.js","node_modules/meadow/node_modules/async/internal/isArrayLike.js","node_modules/meadow/node_modules/async/internal/iterator.js","node_modules/meadow/node_modules/async/internal/once.js","node_modules/meadow/node_modules/async/internal/onlyOnce.js","node_modules/meadow/node_modules/async/internal/setImmediate.js","node_modules/meadow/node_modules/async/internal/withoutIndex.js","node_modules/meadow/node_modules/async/internal/wrapAsync.js","node_modules/meadow/node_modules/async/waterfall.js","node_modules/meadow/source/Meadow-PackageFileLoader.js","node_modules/meadow/source/Meadow-PackageObjectLoader.js","node_modules/meadow/source/Meadow-RawQuery.js","node_modules/meadow/source/Meadow-Schema.js","node_modules/meadow/source/Meadow.js","node_modules/meadow/source/behaviors/Meadow-Count.js","node_modules/meadow/source/behaviors/Meadow-Create.js","node_modules/meadow/source/behaviors/Meadow-Delete.js","node_modules/meadow/source/behaviors/Meadow-Read.js","node_modules/meadow/source/behaviors/Meadow-Reads.js","node_modules/meadow/source/behaviors/Meadow-Undelete.js","node_modules/meadow/source/behaviors/Meadow-Update.js","node_modules/meadow/source/providers/Meadow-Provider-ALASQL.js","node_modules/meadow/source/providers/Meadow-Provider-MeadowEndpoints.js","node_modules/meadow/source/providers/Meadow-Provider-MySQL.js","node_modules/meadow/source/providers/Meadow-Provider-None.js","node_modules/once/once.js","node_modules/process/browser.js","node_modules/punycode/punycode.js","node_modules/querystring-es3/decode.js","node_modules/querystring-es3/encode.js","node_modules/querystring-es3/index.js","node_modules/safe-buffer/index.js","node_modules/simple-concat/index.js","node_modules/simple-get/index.js","node_modules/stream-browserify/index.js","node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js","node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js","node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js","node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js","node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/stream-http/index.js","node_modules/stream-http/lib/capability.js","node_modules/stream-http/lib/request.js","node_modules/stream-http/lib/response.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_readable.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_writable.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/stream-http/node_modules/readable-stream/readable-browser.js","node_modules/string_decoder/lib/string_decoder.js","node_modules/through/index.js","node_modules/timers-browserify/main.js","node_modules/url/url.js","node_modules/url/util.js","node_modules/util-deprecate/browser.js","node_modules/util/support/isBufferBrowser.js","node_modules/util/support/types.js","node_modules/util/util.js","node_modules/which-typed-array/index.js","node_modules/wrappy/wrappy.js","node_modules/xtend/immutable.js","source/Meadow-Endpoints-Browser-Shim.js","source/Meadow-Endpoints.js","source/controller/Meadow-Endpoints-Controller-Base.js","source/controller/components/Meadow-Endpoints-Controller-BehaviorInjection.js","source/controller/components/Meadow-Endpoints-Controller-Error.js","source/controller/components/Meadow-Endpoints-Controller-Log.js","source/controller/utility/Meadow-Endpoints-Filter-Parser.js","source/controller/utility/Meadow-Endpoints-Session-Marshaler.js","source/controller/utility/Meadow-Endpoints-Stream-RecordArray.js","source/endpoints/count/Meadow-Endpoint-Count.js","source/endpoints/count/Meadow-Endpoint-CountBy.js","source/endpoints/create/Meadow-Endpoint-BulkCreate.js","source/endpoints/create/Meadow-Endpoint-Create.js","source/endpoints/create/Meadow-Operation-Create.js","source/endpoints/delete/Meadow-Endpoint-Delete.js","source/endpoints/delete/Meadow-Endpoint-Undelete.js","source/endpoints/read/Meadow-Endpoint-Read.js","source/endpoints/read/Meadow-Endpoint-ReadDistinctList.js","source/endpoints/read/Meadow-Endpoint-ReadLiteList.js","source/endpoints/read/Meadow-Endpoint-ReadMax.js","source/endpoints/read/Meadow-Endpoint-ReadSelectList.js","source/endpoints/read/Meadow-Endpoint-Reads.js","source/endpoints/read/Meadow-Endpoint-ReadsBy.js","source/endpoints/read/Meadow-Marshal-DistinctList.js","source/endpoints/read/Meadow-Marshal-LiteList.js","source/endpoints/schema/Meadow-Endpoint-New.js","source/endpoints/schema/Meadow-Endpoint-Schema.js","source/endpoints/schema/Meadow-Endpoint-Validate.js","source/endpoints/update/Meadow-Endpoint-BulkUpdate.js","source/endpoints/update/Meadow-Endpoint-Update.js","source/endpoints/update/Meadow-Operation-Update.js","source/endpoints/upsert/Meadow-Endpoint-BulkUpsert.js","source/endpoints/upsert/Meadow-Endpoint-Upsert.js","source/endpoints/upsert/Meadow-Operation-Upsert.js"],"names":["f","exports","module","define","amd","window","global","self","this","MeadowEndpoints","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","Buffer","Parser","through","bufferFrom","from","Uint8Array","check","x","y","exec","parse","path","map","header","footer","parser","stream","chunk","write","data","emit","queue","split","emitKey","recurse","onValue","value","root","j","emitPath","key","stack","setHeaderFooter","nextKey","Object","isFrozen","count","actualPath","slice","element","concat","k","_onToken","onToken","token","onError","err","message","indexOf","stringify","op","sep","cl","indent","first","anyData","json","JSON","stringifyObject","buffer","jsonparse","defineProperty","default","func","_initialParams2","args","callback","result","apply","_isObject2","then","invokeCallback","_interopRequireDefault","_setImmediate2","obj","__esModule","error","rethrow","coll","limit","iteratee","_eachOfLimit2","_withoutIndex2","_wrapAsync2","_eachLimit2","_doLimit2","fn","iterable","_once2","_noop2","nextElem","_iterator2","done","running","looping","iterateeCallback","_breakLoop2","replenish","elem","_onlyOnce2","iteratorSymbol","Symbol","iterator","_slice2","arguments","pop","_slice","_isArrayLike2","len","createArrayIterator","_getIterator2","item","next","createES2015Iterator","okeys","_keys2","callFn","process","setImmediate","hasNextTick","hasSetImmediate","undefined","fallback","wrap","_defer","nextTick","setTimeout","defer","_process","timers","arrayLike","start","newLen","Math","max","newArr","Array","idx","index","isAsync","_asyncify","_asyncify2","supportsSymbol","toStringTag","asyncFn","tasks","_isArray2","taskIndex","nextTask","task","push","possibleNames","g","globalThis","out","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","arr","Arr","_byteLength","curByte","revLookup","charCodeAt","fromByteArray","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","join","end","num","output","dup","base64","ieee754","SlowBuffer","alloc","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","__proto__","prototype","arg","encodingOrOffset","TypeError","allocUnsafe","string","encoding","isEncoding","actual","fromString","ArrayBuffer","isView","fromArrayLike","isInstance","array","byteOffset","fromArrayBuffer","valueOf","b","isBuffer","checked","copy","numberIsNaN","type","isArray","fromObject","toPrimitive","assertSize","size","toString","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","String","read","readUInt16BE","foundIndex","found","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","foo","typedArraySupport","console","enumerable","get","species","configurable","writable","poolSize","fill","allocUnsafeSlow","_isBuffer","compare","list","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","toHex","bytes","checkOffset","ext","checkInt","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","set","INVALID_BASE64_RE","Infinity","leadSurrogate","base64clean","src","dst","constructor","name","GetIntrinsic","callBind","$indexOf","allowMissing","intrinsic","bind","$apply","$call","$reflectApply","$gOPD","$defineProperty","$max","originalFunction","applyBind","ReflectOwnKeys","R","Reflect","ReflectApply","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","isNaN","EventEmitter","init","once","emitter","Promise","resolve","reject","errorListener","removeListener","resolver","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","prepend","events","existing","warning","create","newListener","unshift","warned","w","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","unwrapListeners","arrayClone","listenerCount","addEventListener","wrapListener","removeEventListener","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","listeners","addListener","prependListener","prependOnceListener","position","originalListener","shift","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","isCallable","toStr","hasOwnProperty","forEachArray","forEachString","charAt","forEachObject","object","thisArg","baseParameters","createNew","pFable","pFromParameters","new","_Fable","_DefaultParameters","_Parameters","_Dialects","_UUID","getUUID","_LogLevel","_Dialect","resetParameters","Utility","extend","query","disableAutoIdentity","disableAutoDateStamp","disableAutoUserStamp","disableDeleteTracking","body","schema","IDUser","UUID","records","parameters","executed","addJoin","pTable","pFrom","pTo","pType","log","queryUUID","invalidField","tmpJoin","Type","Table","From","To","info","setDialect","pDialectName","invalidDialect","checkDialect","tmpNewFoxHoundObject","mergeParameters","setLogLevel","pLogLevel","tmpLogLevel","setScope","pScope","tmpScope","invalidScope","scope","setDistinct","pDistinct","distinct","setIDUser","pIDUser","tmpUserID","invalidIDUser","userID","setDataElements","pDataElements","tmpDataElements","dataElements","setBegin","pBeginAmount","tmpBegin","invalidBeginAmount","begin","setCap","pCapAmount","tmpCapAmount","invalidCapAmount","cap","setFilter","pFilter","tmpFilter","filter","addFilter","pColumn","pValue","pOperator","pConnector","pParameter","invalidColumn","tmpParameter","Column","Operator","Value","Connector","Parameter","newFilter","setSort","pSort","tmpSort","Direction","sort","addSort","setJoin","pJoin","forEach","addRecord","pRecord","newRecord","setDisableAutoIdentity","pFlag","setDisableAutoDateStamp","setDisableAutoUserStamp","setDisableDeleteTracking","buildCreateQuery","Create","buildReadQuery","Read","buildUpdateQuery","Update","buildDeleteQuery","Delete","buildUndeleteQuery","Undelete","buildCountQuery","Count","clone","tmpFoxHound","pQuery","pResult","pParameters","getDialects","tmpDialects","ALASQL","English","MySQL","queryOverride","generateTableName","escapeColumn","tmpTableName","generateFieldList","pIsForCountClause","tmpSchema","idColumn","find","entry","tmpFieldList","generateWhere","tmpSchemaEntry","tmpHasDeletedParameter","tmpWhere","tmpLastOperatorNoConnector","tmpColumnParameter","tmpDialect","tmpCreateSetList","tmpRecords","tmpCreateSet","tmpColumn","generateCreateSetList","tmpCreateSetValues","tmpCurrentColumn","buildDefaultDefinition","generateCreateSetValues","tmpOrderBy","tmpOrderClause","generateOrderBy","tmpLimit","generateLimit","tmpOptDistinct","template","tmpQueryTemplate","FieldList","TableName","Where","OrderBy","Limit","Distinct","_Params","pError","tmpUpdateSetters","tmpUpdate","tmpColumnDefaultParameter","generateUpdateSetters","tmpUpdateDeleteSetters","tmpHasDeletedField","tmpUpdateSql","generateUpdateDeleteSetters","tmpDeleteTrackingState","tmpUpdateUndeleteSetters","generateUpdateUndeleteSetters","tmpURL","tmpfAddFilter","pFilterCommand","pFilterParameters","tmpfTranslateOperator","tmpNewOperator","toUpperCase","tmpFilterCommand","encodeURIComponent","generateFlags","tmpDisableAutoDateStamp","tmpDisableDeleteTracking","tmpDisableAutoIdentity","tmpDisableAutoUserStamp","tmpFlags","fAddFlag","pFlagSet","generateIdentityColumnName","tmpIDRecord","getIDRecord","SQL_NOW","qualifiedIDColumn","generateSafeFieldName","SURROUNDING_QUOTES_AND_WHITESPACE_REGEX","cleanseQuoting","pFieldName","pFieldNames","cleansedFieldName","generateJoins","tmpJoins","tmpJoinClause","Join","ERROR_MESSAGE","funcType","bound","boundLength","boundArgs","Empty","implementation","util","isProperty","INDENT_START","INDENT_END","RESERVED","RESERVED_MAP","isVariable","formats","s","d","genfun","lines","vars","spaces","pushLine","line","test","fmt","format","sym","property","toFunction","vals","gen","prop","valid","$SyntaxError","SyntaxError","$Function","$TypeError","getEvalledConstructor","expressionSyntax","getOwnPropertyDescriptor","throwTypeError","ThrowTypeError","calleeThrows","gOPDthrows","hasSymbols","getProto","needsEval","TypedArray","INTRINSICS","AggregateError","Atomics","BigInt","BigInt64Array","BigUint64Array","Boolean","DataView","Date","decodeURI","decodeURIComponent","encodeURI","eval","EvalError","Float32Array","Float64Array","FinalizationRegistry","Int8Array","Int16Array","Int32Array","Map","parseFloat","Proxy","ReferenceError","RegExp","Set","SharedArrayBuffer","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakRef","WeakSet","errorProto","doEval","LEGACY_ALIASES","hasOwn","$concat","$spliceApply","splice","$replace","$strSlice","$exec","rePropName","reEscapeChar","stringToPath","last","match","number","quote","subString","getBaseIntrinsic","alias","intrinsicName","intrinsicBaseName","intrinsicRealName","skipFurtherCaching","isOwn","part","desc","has","origSymbol","hasSymbolSham","symObj","syms","propertyIsEnumerable","descriptor","http","url","https","validateParams","params","protocol","request","cb","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","floor","LN2","ctor","superCtor","super_","TempCtor","hasToStringTag","$toString","callBound","isStandardArguments","isLegacyArguments","callee","supportsStandardArguments","badArrayLike","isCallableMarker","fnToStr","reflectApply","_","constructorRegex","isES6ClassFn","fnStr","tryFunctionObject","isIE68","isDDA","document","all","strClass","GeneratorFunction","isFnRegex","generatorFunc","getGeneratorFunc","reIpv4FirstPass","reSubnetString","reForwardSlash","reZone","reBadCharacters","reBadAddress","validate4","input","n0","n1","n2","n3","validate6","withoutSubnet","hasSubnet","withoutZone","lastPartSeparator","address","substring","halves","validate","options","version","createIpValidator","reEmailWhitespace","reHostnameFirstPass","reHostnamePart","rePhoneFirstPass","rePhoneDoubleSpace","rePhoneGlobalSpace","digits","genobj","jsonpointer","xtend","types","unique","isMultipleOf","multipleOf","factor","round","testLimitedRegex","maxLength","compile","cache","reporter","opts","fmts","verbose","greedy","allocated","gensym","formatName","field","pattern","replacer","v","reversePatterns","patterns","genloop","visit","node","schemaPath","properties","tuple","items","msg","required","additionalItems","req","uniqueItems","maxItems","enum","some","dependencies","deps","additionalProperties","additionalProp","patternProperties","$ref","additionalSchemas","ptr","id","reduce","other","fragment","schemas","not","prev","allOf","sch","anyOf","oneOf","passes","maxProperties","minProperties","minItems","minLength","minimum","exclusiveMinimum","maximum","exclusiveMaximum","errors","availableTypedArrays","gOPD","typedArrays","$slice","toStrTags","typedArray","proto","superProto","tag","anyTrue","getter","tryTypedArrays","gopd","C","LEFT_BRACE","RIGHT_BRACE","LEFT_BRACKET","RIGHT_BRACKET","COLON","COMMA","TRUE","FALSE","NULL","STRING","NUMBER","START","STOP","TRUE1","TRUE2","TRUE3","FALSE1","FALSE2","FALSE3","FALSE4","NULL1","NULL2","NULL3","NUMBER1","NUMBER3","STRING1","STRING2","STRING3","STRING4","STRING5","STRING6","VALUE","KEY","OBJECT","ARRAY","BACK_SLASH","FORWARD_SLASH","BACKSPACE","FORM_FEED","NEWLINE","CARRIAGE_RETURN","TAB","STRING_BUFFER_SIZE","tState","stringBuffer","stringBufferOffset","unicode","highSurrogate","mode","bytes_remaining","bytes_in_sequence","temp_buffs","toknam","l","charError","appendStringChar","char","appendStringBuf","intVal","parseError","parent","hasExcape","escapeMatcher","escapeReplacer","untilde","compilePointer","pointer","hasNextPart","oldValue","setter","compiled","baseTimes","isArguments","isIndex","isTypedArray","inherited","isArr","isArg","isBuff","isType","skipIndexes","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","baseGetTag","isObjectLike","argsTag","isLength","typedArrayTags","isPrototype","nativeKeys","freeGlobal","objectProto","nativeObjectToString","unmasked","MAX_SAFE_INTEGER","reIsUint","Ctor","overArg","freeExports","nodeType","freeModule","freeProcess","nodeUtil","binding","transform","freeSelf","baseIsArguments","isFunction","stubFalse","isObject","asyncTag","funcTag","genTag","proxyTag","baseIsTypedArray","baseUnary","nodeIsTypedArray","arrayLikeKeys","baseKeys","isArrayLike","_wrapAsync","handlePromise","promise","_awaitify2","generator","canceled","awaiting","iterDone","catch","handleError","_breakLoop","arity","cbArgs","_asyncEachOfLimit2","isAsyncGenerator","isAsyncIterable","asyncIterator","wrapper","assign","hasQueueMicrotask","queueMicrotask","pMeadow","pPackage","tmpPackage","fable","Package","tmpNewMeadow","Scope","Domain","setDomain","DefaultIdentifier","setDefaultIdentifier","Schema","setSchema","JsonSchema","setJsonSchema","DefaultObject","setDefault","Authorization","setAuthorizer","libFS","_Meadow","_Queries","doSetQuery","pQueryTag","pQueryString","loadQuery","pFileName","fCallBack","tmpCallBack","readFile","pData","QueryTag","FileName","trace","setQuery","checkQuery","getQuery","fs","libValidator","pOriginalJsonSchema","pOriginalSchema","_Schema","_JsonSchema","_Default","_Validate","_Authorizers","pSchema","title","pJsonSchema","pDefault","tmpNewMeadowSchemaObject","pAuthorizer","validateObject","pObject","tmpValidation","Valid","Errors","libFoxHound","settingsManager","MeadowProvider","_IDUser","_Scope","_Query","_RawQueries","_CreateBehavior","_ReadBehavior","_ReadsBehavior","_UpdateBehavior","_DeleteBehavior","_UndeleteBehavior","_CountBehavior","_Provider","_ProviderName","_DefaultIdentifier","_DefaultGUIdentifier","_MeadowPackageLoader","_MeadowPackageObjectLoader","updateProviderState","_PROVIDERS","None","setProvider","pProviderName","InvalidProvider","_RoleNames","settings","MeadowRoleNames","tmpNewMeadowObject","doCreate","doRead","doReads","doUpdate","doDelete","doUndelete","doCount","marshalRecordFromSourceToObject","tmpNewObject","defaultObject","loadFromPackage","loadFromPackageObject","pDomain","pDefaultIdentifier","getRoleName","pRoleIndex","logSlowQuery","pProfileTime","tmpQuery","tmpFullQuery","tmpKey","Provider","Query","Body","Parameters","FullQuery","jsonSchema","addServices","foxhound","libAsyncWaterfall","tmpProfileStart","fStageComplete","rawQueries","provider","tmpProfileTime","getTime","pCount","Message","defaultGUIdentifier","tmpGUIDRecord","tmpQueryRead","tmpError","userIdentifier","schemaFull","pIDRecord","defaultIdentifier","pQueryRead","tmpRecord","Stack","libAsyncEach","pRow","pQueueCallback","pRecords","_GlobalLogLevel","ArrayStorage","GlobalLogLevel","fatal","libALASQL","createTableDynamically","tmpCreateStatement","tmpTable","Size","CreateStatement","checkDataExists","tables","pDefaultGUIdentifier","constructFromObject","Meadow","ObjectPrototype","AuditData","Import","Data","tmpDefaultIdentifier","tmpMeadow","tmpProperty","bindObject","fCallback","tmpResult","fQuery","logLevel","identities","autoval","affectedRows","RowCount","libSimpleGet","_Headers","_Cookies","_EndpointSettings","MedaowEndpoints","ServerProtocol","ServerAddress","ServerPort","ServerEndpointPrefix","buildRequestOptions","pAddress","tmpRequestOptions","headers","cookie","debug","post","pResponse","tmpData","pChunk","tmpIdentityColumn","startsWith","put","delete","pErrorGettingRowcount","getSQLPool","MeadowMySQLConnectionPool","getConnection","pDBConnection","pRows","release","insertId","wrappy","called","onceStrict","onceError","strict","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","clearTimeout","currentQueue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","browser","env","argv","versions","cwd","chdir","umask","punycode","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","overflow","baseMinusTMin","stringFromCharCode","mapDomain","ucs2decode","extra","counter","ucs2encode","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","decode","basic","oldi","baseMinusT","inputLength","bias","encode","handledCPCount","basicLength","q","currentValue","handledCPCountPlusOne","qMinusT","ucs2","toASCII","toUnicode","qs","eq","regexp","maxKeys","kstr","vstr","xs","stringifyPrimitive","objectKeys","ks","copyProps","SafeBuffer","chunks","simpleGet","decompressResponse","querystring","isStream","pipe","maxRedirects","hostname","port","auth","form","method","accept","originalHost","followRedirects","statusCode","location","host","resume","redirectHost","authorization","tryUnzip","abort","Stream","EE","inherits","Readable","Writable","Duplex","Transform","PassThrough","finished","pipeline","dest","source","ondata","pause","ondrain","readable","_isStdio","onend","onclose","didOnEnd","destroy","onerror","cleanup","codes","createErrorType","Base","NodeError","_Base","subClass","superClass","arg1","arg2","arg3","getMessage","expected","thing","determiner","search","this_len","endsWith","allowHalfOpen","_writableState","ended","onEndNT","highWaterMark","getBuffer","_readableState","destroyed","_transform","ReadableState","EElistenerCount","OurUint8Array","debugUtil","debuglog","BufferList","destroyImpl","getHighWaterMark","_require$codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","StringDecoder","createReadableStreamAsyncIterator","errorOrDestroy","kProxyEvents","isDuplex","objectMode","readableObjectMode","pipes","pipesCount","flowing","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","paused","emitClose","autoDestroy","defaultEncoding","awaitDrain","readingMore","decoder","_read","_destroy","readableAddChunk","addToFront","skipChunkCheck","emitReadable","emitReadable_","onEofChunk","chunkInvalid","_uint8ArrayToBuffer","addChunk","maybeReadMore","_undestroy","undestroy","isPaused","setEncoding","enc","head","content","clear","MAX_HWM","howMuchToRead","computeNewHighWaterMark","flow","maybeReadMore_","updateReadableListening","nReadingNextTick","resume_","fromList","consume","endReadable","endReadableNT","wState","nOrig","pipeOpts","endFn","stdout","stderr","unpipe","onunpipe","unpipeInfo","hasUnpiped","onfinish","cleanedUp","needDrain","pipeOnDrain","event","dests","ev","_fromList","ERR_MULTIPLE_CALLBACK","ERR_TRANSFORM_ALREADY_TRANSFORMING","ERR_TRANSFORM_WITH_LENGTH_0","afterTransform","ts","_transformState","transforming","writecb","writechunk","rs","needTransform","writeencoding","flush","_flush","prefinish","_write","err2","CorkedRequest","finish","corkReq","pendingcb","corkedRequestsFree","onCorkedFinish","WritableState","internalUtil","deprecate","ERR_STREAM_CANNOT_PIPE","ERR_STREAM_DESTROYED","ERR_STREAM_NULL_VALUES","ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","nop","writableObjectMode","finalCalled","ending","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writelen","onwriteStateUpdate","finishMaybe","errorEmitted","onwriteError","needFinish","bufferedRequest","clearBuffer","afterWrite","lastBufferedRequest","prefinished","bufferedRequestCount","realHasInstance","writev","_writev","final","_final","doWrite","onwriteDrain","holder","allBuffers","isBuf","callFinal","need","rState","current","hasInstance","writeAfterEnd","validChunk","newChunk","decodeChunk","writeOrBuffer","cork","uncork","setDefaultEncoding","endWritable","kLastResolve","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","readAndResolve","iter","onReadable","AsyncIteratorPrototype","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","lastPromise","wrapForNext","return","enumerableOnly","symbols","_objectSpread","_defineProperty","getOwnPropertyDescriptors","defineProperties","hint","prim","_toPrimitive","_toPropertyKey","custom","tail","hasStrings","_getString","_getBuffer","nb","depth","customInspect","emitErrorAndCloseNT","emitErrorNT","emitCloseNT","readableDestroyed","writableDestroyed","ERR_STREAM_PREMATURE_CLOSE","eos","_len","_key","onlegacyfinish","writableEnded","readableEnded","onrequest","setHeader","isRequest","ERR_MISSING_ARGS","to","streams","popCallback","destroys","closed","destroyer","ERR_INVALID_OPT_VALUE","duplexKey","hwm","highWaterMarkFrom","ClientRequest","response","statusCodes","defaultProtocol","IncomingMessage","Agent","defaultMaxSockets","globalAgent","STATUS_CODES","METHODS","xhr","getXHR","XMLHttpRequest","open","XDomainRequest","checkTypeSupport","responseType","fetch","ReadableStream","writableStream","WritableStream","abortController","AbortController","arraybuffer","msstream","mozchunkedarraybuffer","overrideMimeType","capability","rStates","readyStates","preferBinary","_opts","_body","_headers","useFetch","_mode","decideMode","_fetchTimer","_socketTimeout","_socketTimer","_onFinish","lowerName","unsafeHeaders","getHeader","removeHeader","_destroyed","headersObj","Blob","headersList","keyName","signal","controller","_fetchAbortController","requestTimeout","credentials","withCredentials","_fetchResponse","_resetTimers","_connect","reason","_xhr","ontimeout","setRequestHeader","_response","onreadystatechange","readyState","LOADING","DONE","_onXHRProgress","onprogress","send","status","statusValid","flushHeaders","setNoDelay","setSocketKeepAlive","UNSENT","OPENED","HEADERS_RECEIVED","resetTimers","rawHeaders","trailers","rawTrailers","statusMessage","statusText","_resumeFetch","close","pipeTo","reader","getReader","_pos","responseURL","getAllResponseHeaders","matches","_charset","mimeType","charsetMatch","responseText","newData","MSStreamReader","onload","readAsArrayBuffer","nenc","retried","_normalizeEncoding","normalizeEncoding","text","utf16Text","utf16End","fillLast","utf8FillLast","base64Text","base64End","simpleWrite","simpleEnd","lastNeed","lastTotal","lastChar","utf8CheckByte","byte","utf8CheckExtraBytes","total","utf8CheckIncomplete","_ended","drain","clearImmediate","immediateIds","nextImmediateId","Timeout","clearFn","_id","_clearFn","setInterval","clearInterval","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","Url","slashes","hash","pathname","href","urlParse","relative","resolveObject","isString","protocolPattern","portPattern","simplePathPattern","unwise","autoEscape","nonHostChars","hostEndingChars","hostnamePartPattern","hostnamePartStart","unsafeProtocol","javascript","hostlessProtocol","slashedProtocol","ftp","gopher","file","parseQueryString","slashesDenoteHost","queryIndex","splitter","uSplit","rest","simplePath","lowerProto","atSign","hostEnd","hec","parseHost","ipv6Hostname","hostparts","newpart","validParts","notHost","bit","h","ae","esc","escape","qm","rel","tkeys","tk","tkey","rkeys","rk","rkey","relPath","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","isNullOrUndefined","authInHost","isNull","hasTrailingSlash","up","isAbsolute","config","localStorage","isArgumentsObject","isGeneratorFunction","whichTypedArray","uncurryThis","BigIntSupported","SymbolSupported","ObjectToString","numberValue","stringValue","booleanValue","bigIntValue","symbolValue","checkBoxedPrimitive","prototypeValueOf","isMapToString","isSetToString","isWeakMapToString","isWeakSetToString","isArrayBufferToString","isArrayBuffer","working","isDataViewToString","isDataView","isPromise","isArrayBufferView","isUint8Array","isUint8ClampedArray","isUint16Array","isUint32Array","isInt8Array","isInt16Array","isInt32Array","isFloat32Array","isFloat64Array","isBigInt64Array","isBigUint64Array","isMap","isSet","isWeakMap","isWeakSet","SharedArrayBufferCopy","isSharedArrayBufferToString","isSharedArrayBuffer","isNumberObject","isStringObject","isBooleanObject","isBigIntObject","isSymbolObject","isAsyncFunction","isMapIterator","isSetIterator","isGeneratorObject","isWebAssemblyCompiledModule","isBoxedPrimitive","isAnyArrayBuffer","descriptors","formatRegExp","objects","noDeprecation","throwDeprecation","traceDeprecation","debugs","debugEnvRegex","NODE_DEBUG","debugEnv","ctx","seen","stylize","stylizeNoColor","colors","isBoolean","showHidden","_extend","isUndefined","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","primitive","simple","isNumber","formatPrimitive","visibleKeys","arrayToHash","isError","formatError","isRegExp","isDate","braces","toUTCString","formatProperty","formatArray","cur","numLinesEst","reduceToSingleString","ar","re","pad","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","boolean","null","date","isSymbol","isNativeError","isPrimitive","months","time","getHours","getMinutes","getSeconds","getDate","getMonth","origin","add","kCustomPromisifiedSymbol","callbackifyOnRejected","newReason","promisify","original","promiseResolve","promiseReject","callbackify","callbackified","maybeCb","rej","foundName","libNPMModuleWrapper","libMeadowEndpointsControllerBase","libMeadow","pControllerOptions","DAL","_Controller","_ControllerOptions","ControllerInstance","ControllerClass","EndpointVersion","MeadowEndpointVersion","EndpointName","EndpointPrefix","_EnabledBehaviorSets","Reads","Validate","New","_Endpoints","Creates","ReadMax","ReadsBy","ReadSelectList","ReadLiteList","ReadDistinctList","Updates","Upsert","Upserts","CountBy","pController","setBehaviorEndpoint","pEndpointHash","fEndpoint","connectRoute","pServiceServer","pRequestMethod","pRoutePartial","pEndpointProcessingFunction","pBehaviorName","tmpRoute","tmpBehaviorName","pServiceServerRouteConnectError","connectRoutes","BaseController","meadow","libBaseLogController","libBaseErrorController","libBaseBehaviorInjectionController","libMeadowEndpointsFilterParser","libMeadowEndpointsSessionMarshaler","libMeadowEndpointsStreamRecordArray","pMeadowEndpoints","ControllerOptions","_Settings","_LogController","_BehaviorInjectionController","_ErrorController","waterfall","eachLimit","initializeDefaultUnsetControllers","_FilterParser","_SessionMarshaler","_StreamRecordArray","MeadowEndpointsDefaultSessionObject","CustomerID","SessionID","DeviceID","UserID","UserRole","UserRoleIndex","LoggedIn","initializeRequestState","pRequest","pVerb","tmpRequestState","Verb","SessionData","getSessionData","cloneAsyncSafeRequestState","pRequestState","pNewVerb","tmpSafeRequestState","ParentRequestState","_BeginDataRequestFunction","fNext","beginMeadowRequest","_EndDataRequestFunction","endMeadowRequest","pSettings","pLogController","BehaviorInjection","pBehaviorInjectionController","ErrorHandler","pErrorController","parseFilter","pFilterString","doStreamRecordArray","streamRecordArray","BaseErrorController","BaseBehaviorInjectionController","BaseFilterParser","BaseSessionMarshaler","BaseStreamRecordArray","_BehaviorFunctions","_Templates","_TemplateFunctions","setBehavior","pBehaviorHash","fBehavior","runBehavior","pInjectedBehaviorError","getTemplate","pTemplateHash","setTemplate","pTemplate","getTemplateFunction","processTemplate","pTemplateData","pDefaultTemplate","tmpTemplateFunction","tmpTemplateData","getError","pMessage","pStatusCode","pSuppressSoftwareTrace","StatusCode","SuppressSoftwareTrace","handleErrorIfSet","sendError","logRequestError","SendErrorStatusCodes","tmpStatusCode","tmpResponseObject","prepareRequestContextOutputObject","pObjectToPopulate","Code","Record","QueryParameters","RebuiltQueryString","tmpQueryParameterSet","requestCompletedSuccessfully","pActionSummary","RequestID","RequestUUID","RequestURL","Action","tmpErrorLogData","pLogText","pLogObject","getFilterComparisonOperator","pFilterOperator","tmpOperator","addFilterStanzaToQuery","pFilterStanza","Instruction","Field","tmpSortDirection","tmpFilterTerms","tmpFilterStanza","tmpSession","MeadowEndpointsSessionDataSource","_SessionDataSource","UserSession","tmpHeaderSessionString","tmpHeaderSession","libAsyncEachSeries","JSONStream","pInput","pChunkSize","pChunkCache","tmpInputArray","tmpChunkSize","tmpChunkCache","writeHead","recordJsonMarshaller","pRecordChunk","Filter","fBehaviorInjector","Result","ByField","ByValue","CreatedRecords","RecordsToBulkCreate","libAsync","eachSeries","pNewRecord","RecordCreateError","RecordCreateErrorObject","IDRecord","RecordToCreate","IDCustomer","pReadQuery","RecordCount","tmpHasDeletedBit","GUIDRecord","RecordSearchCriteria","pQueryError","marshalDistinctList","DistinctColumns","tmpCap","Begin","Cap","Columns","Records","ResultRecords","marshalLiteList","RawRecords","ExtraColumns","pResultRecords","ColumnName","SelectList","Hash","addField","pByField","pByValue","tmpFilters","Filters","pFieldList","tmpDistinctList","tmpDistinctRecord","pField","tmpLiteList","tmpGUID","tmpHasUpdateDate","tmpLiteRecord","UpdateDate","EmptyEntityRecord","JSONSchema","RecordValidation","UpdatedRecords","BulkRecords","RecordUpdateError","RecordUpdateErrorObject","pRecordToModify","pOptionalCachedUpdatingRecord","RecordToModify","OriginalRecord","UpdatingRecord","doUpsert","UpsertedRecords","RecordToUpsert","RecordUpsertError","RecordUpsertErrorMessage","pRecordToUpsert","UpsertCreateOnly","CommonServices","MeadowOperation"],"mappings":"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","file":"meadowendpoints.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.MeadowEndpoints = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n(function (Buffer){(function (){\n'use strict'\n\nvar Parser = require('jsonparse')\n  , through = require('through')\n\nvar bufferFrom = Buffer.from && Buffer.from !== Uint8Array.from\n\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n\n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\nexports.parse = function (path, map) {\n  var header, footer\n  var parser = new Parser()\n  var stream = through(function (chunk) {\n    if('string' === typeof chunk)\n      chunk = bufferFrom ? Buffer.from(chunk) : new Buffer(chunk)\n    parser.write(chunk)\n  },\n  function (data) {\n    if(data)\n      stream.write(data)\n    if (header)\n        stream.emit('header', header)\n    if (footer)\n      stream.emit('footer', footer)\n    stream.queue(null)\n  })\n\n  if('string' === typeof path)\n    path = path.split('.').map(function (e) {\n      if (e === '$*')\n        return {emitKey: true}\n      else if (e === '*')\n        return true\n      else if (e === '') // '..'.split('.') returns an empty string\n        return {recurse: true}\n      else\n        return e\n    })\n\n\n  var count = 0, _key\n  if(!path || !path.length)\n    path = null\n\n  parser.onValue = function (value) {\n    if (!this.root)\n      stream.root = value\n\n    if(! path) return\n\n    var i = 0 // iterates on path\n    var j  = 0 // iterates on stack\n    var emitKey = false;\n    var emitPath = false;\n    while (i < path.length) {\n      var key = path[i]\n      var c\n      j++\n\n      if (key && !key.recurse) {\n        c = (j === this.stack.length) ? this : this.stack[j]\n        if (!c) return\n        if (! check(key, c.key)) {\n          setHeaderFooter(c.key, value)\n          return\n        }\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++\n      } else {\n        i++\n        var nextKey = path[i]\n        if (! nextKey) return\n        while (true) {\n          c = (j === this.stack.length) ? this : this.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(this.stack[j]))\n              this.stack[j].value = null\n            break\n          } else {\n            setHeaderFooter(c.key, value)\n          }\n          j++\n        }\n      }\n\n    }\n\n    // emit header\n    if (header) {\n      stream.emit('header', header);\n      header = false;\n    }\n    if (j !== this.stack.length) return\n\n    count ++\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])\n    var data = value\n    if(null != data)\n      if(null != (data = map ? map(data, actualPath) : data)) {\n        if (emitKey || emitPath) {\n          data = { value: data };\n          if (emitKey)\n            data[\"key\"] = this.key;\n          if (emitPath)\n            data[\"path\"] = actualPath;\n        }\n\n        stream.queue(data)\n      }\n    if (this.value) delete this.value[this.key]\n    for(var k in this.stack)\n      if (!Object.isFrozen(this.stack[k]))\n        this.stack[k].value = null\n  }\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if(!path)\n          stream.queue(stream.root)\n        count = 0;\n        stream.root = null;\n      }\n    }\n  }\n\n  parser.onError = function (err) {\n    if(err.message.indexOf(\"at position\") > -1)\n      err.message = \"Invalid JSON (\" + err.message + \")\";\n    stream.emit('error', err)\n  }\n\n  return stream\n\n  function setHeaderFooter(key, value) {\n    // header has not been emitted yet\n    if (header !== false) {\n      header = header || {}\n      header[key] = value\n    }\n\n    // footer has not been emitted yet but header has\n    if (footer !== false && header === false) {\n      footer = footer || {}\n      footer[key] = value\n    }\n  }\n}\n\nfunction check (x, y) {\n  if ('string' === typeof x)\n    return y == x\n  else if (x && 'function' === typeof x.exec)\n    return x.exec(y)\n  else if ('boolean' === typeof x || 'object' === typeof x)\n    return x\n  else if ('function' === typeof x)\n    return x(y)\n  return false\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '[\\n'\n    sep = '\\n,\\n'\n    cl = '\\n]\\n'\n\n  }\n\n  //else, what ever you like\n\n  var stream\n    , first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    try {\n      var json = JSON.stringify(data, null, indent)\n    } catch (err) {\n      return stream.emit('error', err)\n    }\n    if(first) { first = false ; stream.queue(op + json)}\n    else stream.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData)\n      stream.queue(op)\n    stream.queue(cl)\n    stream.queue(null)\n  })\n\n  return stream\n}\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '{\\n'\n    sep = '\\n,\\n'\n    cl = '\\n}\\n'\n\n  }\n\n  //else, what ever you like\n\n  var first = true\n  var anyData = false\n  var stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)\n    if(first) { first = false ; this.queue(op + json)}\n    else this.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData) this.queue(op)\n    this.queue(cl)\n\n    this.queue(null)\n  })\n\n  return stream\n}\n\n\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":22,\"jsonparse\":56,\"through\":164}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _isObject = require('lodash/isObject');\n\nvar _isObject2 = _interopRequireDefault(_isObject);\n\nvar _initialParams = require('./internal/initialParams');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if ((0, _isObject2.default)(result) && typeof result.then === 'function') {\n            result.then(function (value) {\n                invokeCallback(callback, null, value);\n            }, function (err) {\n                invokeCallback(callback, err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (e) {\n        (0, _setImmediate2.default)(rethrow, e);\n    }\n}\n\nfunction rethrow(error) {\n    throw error;\n}\nmodule.exports = exports['default'];\n},{\"./internal/initialParams\":9,\"./internal/setImmediate\":13,\"lodash/isObject\":81}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = eachLimit;\n\nvar _eachOfLimit = require('./internal/eachOfLimit');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _withoutIndex = require('./internal/withoutIndex');\n\nvar _withoutIndex2 = _interopRequireDefault(_withoutIndex);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit(coll, limit, iteratee, callback) {\n  (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);\n}\nmodule.exports = exports['default'];\n},{\"./internal/eachOfLimit\":7,\"./internal/withoutIndex\":15,\"./internal/wrapAsync\":16}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachLimit = require('./eachLimit');\n\nvar _eachLimit2 = _interopRequireDefault(_eachLimit);\n\nvar _doLimit = require('./internal/doLimit');\n\nvar _doLimit2 = _interopRequireDefault(_doLimit);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nexports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);\nmodule.exports = exports['default'];\n},{\"./eachLimit\":3,\"./internal/doLimit\":6}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nexports.default = {};\nmodule.exports = exports[\"default\"];\n},{}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = doLimit;\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\nmodule.exports = exports[\"default\"];\n},{}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _eachOfLimit;\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _once = require('./once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _breakLoop = require('./breakLoop');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = (0, _once2.default)(callback || _noop2.default);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n}\nmodule.exports = exports['default'];\n},{\"./breakLoop\":5,\"./iterator\":10,\"./once\":11,\"./onlyOnce\":12,\"lodash/noop\":85}],8:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nmodule.exports = exports['default'];\n},{}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function () /*...args, callback*/{\n        var args = (0, _slice2.default)(arguments);\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    };\n};\n\nvar _slice = require('./slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n},{\"./slice\":14}],10:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = iterator;\n\nvar _isArrayLike = require('lodash/isArrayLike');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nvar _keys = require('lodash/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = (0, _keys2.default)(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? { value: obj[key], key: key } : null;\n    };\n}\n\nfunction iterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];\n},{\"./getIterator\":8,\"lodash/isArrayLike\":77,\"lodash/keys\":84}],11:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\nmodule.exports = exports[\"default\"];\n},{}],12:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function () {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\nmodule.exports = exports[\"default\"];\n},{}],13:[function(require,module,exports){\n(function (process,setImmediate){(function (){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.hasNextTick = exports.hasSetImmediate = undefined;\nexports.fallback = fallback;\nexports.wrap = wrap;\n\nvar _slice = require('./slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return function (fn /*, ...args*/) {\n        var args = (0, _slice2.default)(arguments, 1);\n        defer(function () {\n            fn.apply(null, args);\n        });\n    };\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);\n}).call(this)}).call(this,require('_process'),require(\"timers\").setImmediate)\n\n},{\"./slice\":14,\"_process\":121,\"timers\":165}],14:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = slice;\nfunction slice(arrayLike, start) {\n    start = start | 0;\n    var newLen = Math.max(arrayLike.length - start, 0);\n    var newArr = Array(newLen);\n    for (var idx = 0; idx < newLen; idx++) {\n        newArr[idx] = arrayLike[start + idx];\n    }\n    return newArr;\n}\nmodule.exports = exports[\"default\"];\n},{}],15:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _withoutIndex;\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\nmodule.exports = exports[\"default\"];\n},{}],16:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;\n},{\"../asyncify\":2}],17:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (tasks, callback) {\n    callback = (0, _once2.default)(callback || _noop2.default);\n    if (!(0, _isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        args.push((0, _onlyOnce2.default)(next));\n        task.apply(null, args);\n    }\n\n    function next(err /*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask((0, _slice2.default)(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _once = require('./internal/once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _slice = require('./internal/slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nvar _onlyOnce = require('./internal/onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\n},{\"./internal/once\":11,\"./internal/onlyOnce\":12,\"./internal/slice\":14,\"./internal/wrapAsync\":16,\"lodash/isArray\":76,\"lodash/noop\":85}],18:[function(require,module,exports){\n(function (global){(function (){\n'use strict';\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],19:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n},{}],20:[function(require,module,exports){\n\n},{}],21:[function(require,module,exports){\narguments[4][20][0].apply(exports,arguments)\n},{\"dup\":20}],22:[function(require,module,exports){\n(function (Buffer){(function (){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"base64-js\":19,\"buffer\":22,\"ieee754\":46}],23:[function(require,module,exports){\nmodule.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n\n},{}],24:[function(require,module,exports){\n'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\n},{\"./\":25,\"get-intrinsic\":39}],25:[function(require,module,exports){\n'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n\n},{\"function-bind\":36,\"get-intrinsic\":39}],26:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n},{}],27:[function(require,module,exports){\n'use strict';\n\nvar isCallable = require('is-callable');\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n\n},{\"is-callable\":49}],28:[function(require,module,exports){\n/**\n* FoxHound Query Generation Library\n* @license MIT\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Load our base parameters skeleton object\nconst baseParameters = require('./Parameters.js');\n\nvar FoxHound = function()\n{\n\tfunction createNew(pFable, pFromParameters)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pFable) !== 'object') || !('fable' in pFable))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\n\t\tvar _Fable = pFable;\n\n\t\t// The default parameters config object, used as a template for all new\n\t\t// queries created from this query.\n\t\tvar _DefaultParameters = (typeof(pFromParameters) === 'undefined') ? {} : pFromParameters;\n\n\t\t// The parameters config object for the current query.  This is the only\n\t\t// piece of internal state that is important to operation.\n\t\tvar _Parameters = false;\n\n\t\tvar _Dialects = require('./Foxhound-Dialects.js');\n\n\t\t// The unique identifier for a query\n\t\tvar _UUID = _Fable.getUUID();\n\n\t\t// The log level, for debugging chattiness.\n\t\tvar _LogLevel = 0;\n\n\t\t// The dialect to use when generating queries\n\t\tvar _Dialect = false;\n\n\t\t/**\n\t\t* Clone the current FoxHound Query into a new Query object, copying all\n\t\t* parameters as the new default.  Clone also copies the log level.\n\t\t*\n\t\t* @method clone\n\t\t* @return {Object} Returns a cloned Query.  This is still chainable.\n\t\t*/\n\t\tvar clone = function()\n\t\t{\n\t\t\tvar tmpFoxHound = createNew(_Fable, baseParameters)\n\t\t\t\t.setScope(_Parameters.scope)\n\t\t\t\t.setBegin(_Parameters.begin)\n\t\t\t\t.setCap(_Parameters.cap);\n\n\t\t\t// Schema is the only part of a query that carries forward.\n\t\t\ttmpFoxHound.query.schema = _Parameters.query.schema;\n\n\t\t\tif (_Parameters.dataElements)\n\t\t\t{\n\t\t\t\ttmpFoxHound.parameters.dataElements = _Parameters.dataElements.slice(); // Copy the array of dataElements\n\t\t\t}\n\t\t\tif (_Parameters.sort)\n\t\t\t{\n\t\t\t\ttmpFoxHound.parameters.sort = _Parameters.sort.slice(); // Copy the sort array.\n\t\t\t\t// TODO: Fix the side affect nature of these being objects in the array .. they are technically clones of the previous.\n\t\t\t}\n\t\t\tif (_Parameters.filter)\n\t\t\t{\n\t\t\t\ttmpFoxHound.parameters.filter = _Parameters.filter.slice(); // Copy the filter array.\n\t\t\t\t// TODO: Fix the side affect nature of these being objects in the array .. they are technically clones of the previous.\n\t\t\t}\n\n\t\t\treturn tmpFoxHound;\n\t\t};\n\n\n\t\t/**\n\t\t* Reset the parameters of the FoxHound Query to the Default.  Default\n\t\t* parameters were set during object construction.\n\t\t*\n\t\t* @method resetParameters\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar resetParameters = function()\n\t\t{\n\t\t\t_Parameters = _Fable.Utility.extend({}, baseParameters, _DefaultParameters);\n\t\t\t_Parameters.query = ({\n\t\t\t\tdisableAutoIdentity: false,\n\t\t\t\tdisableAutoDateStamp: false,\n\t\t\t\tdisableAutoUserStamp: false,\n\t\t\t\tdisableDeleteTracking: false,\n\t\t\t\tbody: false,\n\t\t\t\tschema: false,   // The schema to intersect with our records\n\t\t\t\tIDUser: 0,       // The user to stamp into records\n\t\t\t\tUUID: _Fable.getUUID(), // A UUID for this record\n\t\t\t\trecords: false,  // The records to be created or changed\n\t\t\t\tparameters: {}\n\t\t\t});\n\n\t\t\t_Parameters.result = ({\n\t\t\t\texecuted: false, // True once we've run a query.\n\t\t\t\tvalue: false,    // The return value of the last query run\n\t\t\t\t// Updated below due to changes in how Async.js responds to a false value here\n\t\t\t\terror: undefined // The error message of the last run query\n\t\t\t});\n\n\t\t\treturn this;\n\t\t};\n\t\tresetParameters();\n\n\t\t/**\n\t\t* Reset the parameters of the FoxHound Query to the Default.  Default\n\t\t* parameters were set during object construction.\n\t\t*\n\t\t* @method mergeParameters\n\t\t* @param {Object} pFromParameters A Parameters Object to merge from\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar mergeParameters = function(pFromParameters)\n\t\t{\n\t\t\t_Parameters = _Fable.Utility.extend({}, _Parameters, pFromParameters);\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the the Logging level.\n\t\t*\n\t\t* The log levels are:\n\t\t*    0  -  Don't log anything\n\t\t*    1  -  Log queries\n\t\t*    2  -  Log queries and non-parameterized queries\n\t\t*    3  -  Log everything\n\t\t*\n\t\t* @method setLogLevel\n\t\t* @param {Number} pLogLevel The log level for our object\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setLogLevel = function(pLogLevel)\n\t\t{\n\t\t\tvar tmpLogLevel = 0;\n\n\t\t\tif (typeof(pLogLevel) === 'number' && (pLogLevel % 1) === 0)\n\t\t\t{\n\t\t\t\ttmpLogLevel = pLogLevel;\n\t\t\t}\n\n\t\t\t_LogLevel = tmpLogLevel;\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the Scope for the Query.  *Scope* is the source for the data being\n\t\t* pulled.  In TSQL this would be the _table_, whereas in MongoDB this\n\t\t* would be the _collection_.\n\t\t*\n\t\t* A scope can be either a string, or an array (for JOINs and such).\n\t\t*\n\t\t* @method setScope\n\t\t* @param {String} pScope A Scope for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setScope = function(pScope)\n\t\t{\n\t\t\tvar tmpScope = false;\n\n\t\t\tif (typeof(pScope) === 'string')\n\t\t\t{\n\t\t\t\ttmpScope = pScope;\n\t\t\t}\n\t\t\telse if (pScope !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Scope set failed.  You must pass in a string or array.', {queryUUID:_UUID, parameters:_Parameters, invalidScope:pScope});\n\t\t\t}\n\n\t\t\t_Parameters.scope = tmpScope;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Scope set: '+tmpScope, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set whether the query returns DISTINCT results.\n\t\t* For count queries, returns the distinct for the selected fields, or all fields in the base table by default.\n\t\t*\n\t\t* @method setDistinct\n\t\t* @param {Boolean} pDistinct True if the query should be distinct.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setDistinct = function(pDistinct)\n\t\t{\n\t\t\t_Parameters.distinct = !!pDistinct;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Distinct set: '+_Parameters.distinct, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the Data Elements for the Query.  *Data Elements* are the fields\n\t\t* being pulled by the query.  In TSQL this would be the _columns_,\n\t\t* whereas in MongoDB this would be the _fields_.\n\t\t*\n\t\t* The passed values can be either a string, or an array.\n\t\t*\n\t\t* @method setDataElements\n\t\t* @param {String} pDataElements The Data Element(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setDataElements = function(pDataElements)\n\t\t{\n\t\t\tvar tmpDataElements = false;\n\n\t\t\tif (Array.isArray(pDataElements))\n\t\t\t{\n\t\t\t\t// TODO: Check each entry of the array are all strings\n\t\t\t\ttmpDataElements = pDataElements;\n\t\t\t}\n\t\t\tif (typeof(pDataElements) === 'string')\n\t\t\t{\n\t\t\t\ttmpDataElements = [pDataElements];\n\t\t\t}\n\n\t\t\t_Parameters.dataElements = tmpDataElements;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Data Elements set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the sort data element\n\t\t*\n\t\t* The passed values can be either a string, an object or an array of objects.\n\t\t*\n\t\t* The Sort object has two values:\n\t\t* {Column:'Birthday', Direction:'Ascending'}\n\t\t*\n\t\t* @method setSort\n\t\t* @param {String} pSort The sort criteria(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setSort = function(pSort)\n\t\t{\n\t\t\tvar tmpSort = false;\n\n\t\t\tif (Array.isArray(pSort))\n\t\t\t{\n\t\t\t\t// TODO: Check each entry of the array are all conformant sort objects\n\t\t\t\ttmpSort = pSort;\n\t\t\t}\n\t\t\telse if (typeof(pSort) === 'string')\n\t\t\t{\n\t\t\t\t// Default to ascending\n\t\t\t\ttmpSort = [{Column:pSort, Direction:'Ascending'}];\n\t\t\t}\n\t\t\telse if (typeof(pSort) === 'object')\n\t\t\t{\n\t\t\t\t// TODO: Check that this sort entry conforms to a sort entry\n\t\t\t\ttmpSort = [pSort];\n\t\t\t}\n\n\t\t\t_Parameters.sort = tmpSort;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Sort set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the join data element\n\t\t*\n\t\t* The passed values can be either an object or an array of objects.\n\t\t*\n\t\t* The join object has four values:\n\t\t* {Type:'INNER JOIN', Table:'Test', From:'Test.ID', To:'Scope.IDItem'}\n\t\t*\n\t\t* @method setJoin\n\t\t* @param {Object} pJoin The join criteria(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setJoin = function(pJoin)\n\t\t{\n\t\t\t_Parameters.join = [];\n\n\t\t\tif (Array.isArray(pJoin))\n\t\t\t{\n\t\t\t\tpJoin.forEach(function(join)\n\t\t\t\t{\n\t\t\t\t\taddJoin(join.Table, join.From, join.To, join.Type);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (typeof(pJoin) === 'object')\n\t\t\t{\n\t\t\t\taddJoin(pJoin.Table, pJoin.From, pJoin.To, pJoin.Type);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Add a sort data element\n\t\t*\n\t\t* The passed values can be either a string, an object or an array of objects.\n\t\t*\n\t\t* The Sort object has two values:\n\t\t* {Column:'Birthday', Direction:'Ascending'}\n\t\t*\n\t\t* @method setSort\n\t\t* @param {String} pSort The sort criteria to add to the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addSort = function(pSort)\n\t\t{\n\t\t\tvar tmpSort = false;\n\n\t\t\tif (typeof(pSort) === 'string')\n\t\t\t{\n\t\t\t\t// Default to ascending\n\t\t\t\ttmpSort = {Column:pSort, Direction:'Ascending'};\n\t\t\t}\n\t\t\tif (typeof(pSort) === 'object')\n\t\t\t{\n\t\t\t\t// TODO: Check that this sort entry conforms to a sort entry\n\t\t\t\ttmpSort = pSort;\n\t\t\t}\n\n\t\t\tif (!_Parameters.sort)\n\t\t\t{\n\t\t\t\t_Parameters.sort = [];\n\t\t\t}\n\n\t\t\t_Parameters.sort.push(tmpSort);\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Sort set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the the Begin index for the Query.  *Begin* is the index at which\n\t\t* a query should start returning rows.  In TSQL this would be the n\n\t\t* parameter of ```LIMIT 1,n```, whereas in MongoDB this would be the\n\t\t* n in ```skip(n)```.\n\t\t*\n\t\t* The passed value must be an Integer >= 0.\n\t\t*\n\t\t* @method setBegin\n\t\t* @param {Number} pBeginAmount The index to begin returning Query data.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setBegin = function(pBeginAmount)\n\t\t{\n\t\t\tvar tmpBegin = false;\n\n\t\t\t// Test if it is an integer > -1\n\t\t\t// http://jsperf.com/numbers-and-integers\n\t\t\tif (typeof(pBeginAmount) === 'number' && (pBeginAmount % 1) === 0 && pBeginAmount >= 0)\n\t\t\t{\n\t\t\t\ttmpBegin = pBeginAmount;\n\t\t\t}\n\t\t\telse if (pBeginAmount !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Begin set failed; non-positive or non-numeric argument.', {queryUUID:_UUID, parameters:_Parameters, invalidBeginAmount:pBeginAmount});\n\t\t\t}\n\n\t\t\t_Parameters.begin = tmpBegin;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Begin set: '+pBeginAmount, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the the Cap for the Query.  *Cap* is the maximum number of records\n\t\t* a Query should return in a set.  In TSQL this would be the n\n\t\t* parameter of ```LIMIT n```, whereas in MongoDB this would be the\n\t\t* n in ```limit(n)```.\n\t\t*\n\t\t* The passed value must be an Integer >= 0.\n\t\t*\n\t\t* @method setCap\n\t\t* @param {Number} pCapAmount The maximum records for the Query set.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setCap = function(pCapAmount)\n\t\t{\n\t\t\tvar tmpCapAmount = false;\n\n\t\t\tif (typeof(pCapAmount) === 'number' && (pCapAmount % 1) === 0 && pCapAmount >= 0)\n\t\t\t{\n\t\t\t\ttmpCapAmount = pCapAmount;\n\t\t\t}\n\t\t\telse if (pCapAmount !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Cap set failed; non-positive or non-numeric argument.', {queryUUID:_UUID, parameters:_Parameters, invalidCapAmount:pCapAmount});\n\t\t\t}\n\n\n\t\t\t_Parameters.cap = tmpCapAmount;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Cap set to: '+tmpCapAmount, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the filter expression\n\t\t*\n\t\t* The passed values can be either an object or an array of objects.\n\t\t*\n\t\t* The Filter object has a minimum of two values (which expands to the following):\n\t\t* {Column:'Name', Value:'John'}\n\t\t* {Column:'Name', Operator:'EQ', Value:'John', Connector:'And', Parameter:'Name'}\n\t\t*\n\t\t* @method setFilter\n\t\t* @param {String} pFilter The filter(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setFilter = function(pFilter)\n\t\t{\n\t\t\tvar tmpFilter = false;\n\n\t\t\tif (Array.isArray(pFilter))\n\t\t\t{\n\t\t\t\t// TODO: Check each entry of the array are all conformant Filter objects\n\t\t\t\ttmpFilter = pFilter;\n\t\t\t}\n\t\t\telse if (typeof(pFilter) === 'object')\n\t\t\t{\n\t\t\t\t// TODO: Check that this Filter entry conforms to a Filter entry\n\t\t\t\ttmpFilter = [pFilter];\n\t\t\t}\n\n\t\t\t_Parameters.filter = tmpFilter;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Filter set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\n\t\t/**\n\t\t* Add a filter expression\n\t\t*\n\t\t* {Column:'Name', Operator:'EQ', Value:'John', Connector:'And', Parameter:'Name'}\n\t\t*\n\t\t* @method addFilter\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addFilter = function(pColumn, pValue, pOperator, pConnector, pParameter)\n\t\t{\n\t\t\tif (typeof(pColumn) !== 'string')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query filter column', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (typeof(pValue) === 'undefined')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query filter value', {queryUUID:_UUID, parameters:_Parameters, invalidColumn:pColumn});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tvar tmpOperator = (typeof(pOperator) === 'undefined') ? '=' : pOperator;\n\t\t\tvar tmpConnector = (typeof(pConnector) === 'undefined') ? 'AND' : pConnector;\n\t\t\tvar tmpParameter = (typeof(pParameter) === 'undefined') ? pColumn : pParameter;\n\n\t\t\t//support table.field notation (mysql2 requires this)\n\t\t\ttmpParameter = tmpParameter.replace('.', '_');\n\n\t\t\tvar tmpFilter = (\n\t\t\t\t{\n\t\t\t\t\tColumn: pColumn,\n\t\t\t\t\tOperator: tmpOperator,\n\t\t\t\t\tValue: pValue,\n\t\t\t\t\tConnector: tmpConnector,\n\t\t\t\t\tParameter: tmpParameter\n\t\t\t\t});\n\n\t\t\tif (!Array.isArray(_Parameters.filter))\n\t\t\t{\n\t\t\t\t_Parameters.filter = [tmpFilter];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Parameters.filter.push(tmpFilter);\n\t\t\t}\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Added a filter', {queryUUID:_UUID, parameters:_Parameters, newFilter:tmpFilter});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Add a join expression\n\t\t*\n\t\t* {Type:'INNER JOIN', Table:'Test', From:'Test.ID', To:'Scope.IDItem'}\n\t\t*\n\t\t* @method addJoin\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addJoin = function(pTable, pFrom, pTo, pType)\n\t\t{\n\t\t\tif (typeof(pTable) !== 'string')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join table', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (typeof(pFrom) === 'undefined' || typeof(pTo) === 'undefined')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join field', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t//sanity check the join fields\n\t\t\tif (pFrom.indexOf(pTable)!=0)\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join field, join must come FROM the join table!', {queryUUID:_UUID, parameters:_Parameters, invalidField:pFrom});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (pTo.indexOf('.')<=0)\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join field, join must go TO a field on another table ([table].[field])!', {queryUUID:_UUID, parameters:_Parameters, invalidField:pTo});\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar tmpType = (typeof(pType) === 'undefined') ?  'INNER JOIN' : pType;\n\n\t\t\tvar tmpJoin = (\n\t\t\t\t{\n\t\t\t\t\tType: tmpType,\n\t\t\t\t\tTable: pTable,\n\t\t\t\t\tFrom: pFrom,\n\t\t\t\t\tTo: pTo\n\t\t\t\t});\n\n\t\t\tif (!Array.isArray(_Parameters.join))\n\t\t\t{\n\t\t\t\t_Parameters.join = [tmpJoin];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Parameters.join.push(tmpJoin);\n\t\t\t}\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Added a join', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\n\t\t/**\n\t\t* Add a record (for UPDATE and INSERT)\n\t\t*\n\t\t*\n\t\t* @method addRecord\n\t\t* @param {Object} pRecord The record to add.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addRecord = function(pRecord)\n\t\t{\n\t\t\tif (typeof(pRecord) !== 'object')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid record to the query -- records must be an object', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!Array.isArray(_Parameters.query.records))\n\t\t\t{\n\t\t\t\t_Parameters.query.records = [pRecord];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Parameters.query.records.push(pRecord);\n\t\t\t}\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Added a record to the query', {queryUUID:_UUID, parameters:_Parameters, newRecord:pRecord});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\n\t\t/**\n\t\t* Set the Dialect for Query generation.\n\t\t*\n\t\t* This function expects a string, case sensitive, which matches both the\n\t\t* folder and filename\n\t\t*\n\t\t* @method setDialect\n\t\t* @param {String} pDialectName The dialect for query generation.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setDialect = function(pDialectName)\n\t\t{\n\n\t\t\tif (typeof(pDialectName) !== 'string')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Dialect set to English - invalid name', {queryUUID:_UUID, parameters:_Parameters, invalidDialect:pDialectName});\n\t\t\t\treturn setDialect('English');\n\t\t\t}\n\n\t\t\tif (_Dialects.hasOwnProperty(pDialectName))\n\t\t\t{\n\t\t\t\t_Dialect = _Dialects[pDialectName](_Fable);\n\t\t\t\tif (_LogLevel > 2)\n\t\t\t\t{\n\t\t\t\t\t_Fable.log.info('Dialog set to: '+pDialectName, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Fable.log.error('Dialect not set - unknown dialect \"'+pDialectName+\"'\", {queryUUID:_UUID, parameters:_Parameters, invalidDialect:pDialectName});\n\t\t\t\tsetDialect('English');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* User to use for this query\n\t\t*\n\t\t* @method setIDUser\n\t\t*/\n\t\tvar setIDUser = function(pIDUser)\n\t\t{\n\n\t\t\tvar tmpUserID = 0;\n\n\t\t\tif (typeof(pIDUser) === 'number' && (pIDUser % 1) === 0 && pIDUser >= 0)\n\t\t\t{\n\t\t\t\ttmpUserID = pIDUser;\n\t\t\t}\n\t\t\telse if (pIDUser !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('User set failed; non-positive or non-numeric argument.', {queryUUID:_UUID, parameters:_Parameters, invalidIDUser:pIDUser});\n\t\t\t}\n\n\n\t\t\t_Parameters.userID = tmpUserID;\n\t\t\t_Parameters.query.IDUser = tmpUserID;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('IDUser set to: '+tmpUserID, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable auto identity\n\t\t*\n\t\t* @method setDisableAutoIdentity\n\t\t*/\n\t\tvar setDisableAutoIdentity = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableAutoIdentity = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable auto datestamp\n\t\t*\n\t\t* @method setDisableAutoDateStamp\n\t\t*/\n\t\tvar setDisableAutoDateStamp = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableAutoDateStamp = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable auto userstamp\n\t\t*\n\t\t* @method setDisableAutoUserStamp\n\t\t*/\n\t\tvar setDisableAutoUserStamp = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableAutoUserStamp = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable delete tracking\n\t\t*\n\t\t* @method setDisableDeleteTracking\n\t\t*/\n\t\tvar setDisableDeleteTracking = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableDeleteTracking = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Check that a valid Dialect has been set\n\t\t*\n\t\t* If there has not been a dialect set, it defaults to English.\n\t\t* TODO: Have the json configuration define a \"default\" dialect.\n\t\t*\n\t\t* @method checkDialect\n\t\t*/\n\t\tvar checkDialect = function()\n\t\t{\n\t\t\tif (_Dialect === false)\n\t\t\t{\n\t\t\t\tsetDialect('English');\n\t\t\t}\n\t\t};\n\n\n\t\tvar buildCreateQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Create(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildReadQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Read(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildUpdateQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Update(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildDeleteQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Delete(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildUndeleteQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Undelete(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildCountQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Count(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Container Object for our Factory Pattern\n\t\t*/\n\t\tvar tmpNewFoxHoundObject = (\n\t\t{\n\t\t\tresetParameters: resetParameters,\n\t\t\tmergeParameters: mergeParameters,\n\n\t\t\tsetLogLevel: setLogLevel,\n\n\t\t\tsetScope: setScope,\n\t\t\tsetDistinct: setDistinct,\n\t\t\tsetIDUser: setIDUser,\n\t\t\tsetDataElements: setDataElements,\n\t\t\tsetBegin: setBegin,\n\t\t\tsetCap: setCap,\n\t\t\tsetFilter: setFilter,\n\t\t\taddFilter: addFilter,\n\t\t\tsetSort: setSort,\n\t\t\taddSort: addSort,\n\t\t\tsetJoin: setJoin,\n\t\t\taddJoin: addJoin,\n\n\t\t\taddRecord: addRecord,\n\t\t\tsetDisableAutoIdentity: setDisableAutoIdentity,\n\t\t\tsetDisableAutoDateStamp: setDisableAutoDateStamp,\n\t\t\tsetDisableAutoUserStamp: setDisableAutoUserStamp,\n\t\t\tsetDisableDeleteTracking: setDisableDeleteTracking,\n\n\t\t\tsetDialect: setDialect,\n\n\t\t\tbuildCreateQuery: buildCreateQuery,\n\t\t\tbuildReadQuery: buildReadQuery,\n\t\t\tbuildUpdateQuery: buildUpdateQuery,\n\t\t\tbuildDeleteQuery: buildDeleteQuery,\n\t\t\tbuildUndeleteQuery: buildUndeleteQuery,\n\t\t\tbuildCountQuery: buildCountQuery,\n\n\t\t\tclone: clone,\n\t\t\tnew: createNew\n\t\t});\n\n\t\t/**\n\t\t * Query\n\t\t *\n\t\t * @property query\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'query',\n\t\t\t{\n\t\t\t\tget: function() { return _Parameters.query; },\n\t\t\t\tset: function(pQuery) { _Parameters.query = pQuery; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Result\n\t\t *\n\t\t * @property result\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'result',\n\t\t\t{\n\t\t\t\tget: function() { return _Parameters.result; },\n\t\t\t\tset: function(pResult) { _Parameters.result = pResult; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Query Parameters\n\t\t *\n\t\t * @property parameters\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'parameters',\n\t\t\t{\n\t\t\t\tget: function() { return _Parameters; },\n\t\t\t\tset: function(pParameters) { _Parameters = pParameters; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Dialect\n\t\t *\n\t\t * @property dialect\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'dialect',\n\t\t\t{\n\t\t\t\tget: function() { return _Dialect; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Universally Unique Identifier\n\t\t *\n\t\t * @property uuid\n\t\t * @type String\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'uuid',\n\t\t\t{\n\t\t\t\tget: function() { return _UUID; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Log Level\n\t\t *\n\t\t * @property logLevel\n\t\t * @type Integer\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'logLevel',\n\t\t\t{\n\t\t\t\tget: function() { return _LogLevel; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\treturn tmpNewFoxHoundObject;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = FoxHound();\n\n},{\"./Foxhound-Dialects.js\":29,\"./Parameters.js\":30}],29:[function(require,module,exports){\ngetDialects = () =>\n{\n\tlet tmpDialects = {};\n\n\ttmpDialects.ALASQL = require('./dialects/ALASQL/FoxHound-Dialect-ALASQL.js');\n\ttmpDialects.English = require('./dialects/English/FoxHound-Dialect-English.js');\n\ttmpDialects.MeadowEndpoints = require('./dialects/MeadowEndpoints/FoxHound-Dialect-MeadowEndpoints.js');\n\ttmpDialects.MySQL = require('./dialects/MySQL/FoxHound-Dialect-MySQL.js');\n\n\ttmpDialects.default = tmpDialects.English;\n\n\treturn tmpDialects;\n}\n\nmodule.exports = getDialects();\n},{\"./dialects/ALASQL/FoxHound-Dialect-ALASQL.js\":31,\"./dialects/English/FoxHound-Dialect-English.js\":32,\"./dialects/MeadowEndpoints/FoxHound-Dialect-MeadowEndpoints.js\":33,\"./dialects/MySQL/FoxHound-Dialect-MySQL.js\":34}],30:[function(require,module,exports){\n/**\n* Query Parameters Object\n*\n* @class FoxHoundQueryParameters\n* @constructor\n*/\nvar FoxHoundQueryParameters = (\n{\n\t\tscope: false,        // STR: The scope of the data\n\t\t\t\t\t\t\t\t// TSQL: the \"Table\" or \"View\"\n\t\t\t\t\t\t\t\t// MongoDB: the \"Collection\"\n\n\t\tdataElements: false, // ARR of STR: The data elements to return\n\t\t\t\t\t\t\t\t// TSQL: the \"Columns\"\n\t\t\t\t\t\t\t\t// MongoDB: the \"Fields\"\n\n\t\tbegin: false,        // INT: Record index to start at\n\t\t\t\t\t\t\t\t// TSQL: n in LIMIT 1,n\n\t\t\t\t\t\t\t\t// MongoDB: n in Skip(n)\n\n\t\tcap: false,          // INT: Maximum number of records to return\n\t\t\t\t\t\t\t\t// TSQL: n in LIMIT n\n\t\t\t\t\t\t\t\t// MongoDB: n in limit(n)\n\n\t\t// Serialization example for a query:\n\t\t// Take the filter and return an array of filter instructions\n\t\t// Basic instruction anatomy:\n\t\t//       INSTRUCTION~FIELD~OPERATOR~VALUE\n\t\t// FOP - Filter Open Paren\n\t\t//       FOP~~(~\n\t\t// FCP - Filter Close Paren\n\t\t//       FCP~~)~\n\t\t// FBV - Filter By Value\n\t\t//       FBV~Category~EQ~Books\n\t\t//       Possible comparisons:\n\t\t//       * EQ - Equals To (=)\n\t\t//       * NE - Not Equals To (!=)\n\t\t//       * GT - Greater Than (>)\n\t\t//       * GE - Greater Than or Equals To (>=)\n\t\t//       * LT - Less Than (<)\n\t\t//       * LE - Less Than or Equals To (<=)\n\t\t//       * LK - Like (Like)\n\t\t// FBL - Filter By List (value list, separated by commas)\n\t\t//       FBL~Category~EQ~Books,Movies\n\t\t// FSF - Filter Sort Field\n\t\t//       FSF~Category~ASC~0\n\t\t//       FSF~Category~DESC~0\n\t\t// FCC - Filter Constraint Cap (the limit of what is returned)\n\t\t//       FCC~~10~\n\t\t// FCB - Filter Constraint Begin (the zero-based start index of what is returned)\n\t\t//       FCB~~10~\n\t\t//\n\t\t// This means: FBV~Category~EQ~Books~FBV~PublishedYear~GT~2000~FSF~PublishedYear~DESC~0\n\t\t//             Filters down to ALL BOOKS PUBLISHED AFTER 2000 IN DESCENDING ORDER\n\t\tfilter: false,       // ARR of OBJ: Data filter expression list {Column:'Name', Operator:'EQ', Value:'John', Connector:'And', Parameter:'Name'}\n\t\t\t\t\t\t\t\t// TSQL: the WHERE clause\n\t\t\t\t\t\t\t\t// MongoDB: a find() expression\n\n\t\tsort: false,         // ARR of OBJ: The sort order    {Column:'Birthday', Direction:'Ascending'}\n\t\t\t\t\t\t\t\t// TSQL: ORDER BY\n\t\t\t\t\t\t\t\t// MongoDB: sort()\n\n\t\tjoin: false,         // ARR of OBJ: The join tables    {Type:'INNER JOIN', Table:'test', From: 'Test.ID', To: 'Scope.IDItem' }\n\t\t\t\t\t\t\t\t// TSQL: JOIN\n\n\t\t// Force a specific query to run regardless of above ... this is used to override the query generator.\n\t\tqueryOverride: false,\n\n\t\t// Where the generated query goes\n\t\tquery: false,\n\t\t/*\n\t\t\t{\n\t\t\t\tbody: false,\n\t\t\t\tschema: false,   // The schema to intersect with our records\n\t\t\t\tIDUser: 0,       // The User ID to stamp into records\n\t\t\t\tUUID: A_UUID,    // Some globally unique record id, different per cloned query.\n\t\t\t\trecords: false,  // The records to be created or changed\n\t\t\t\tparameters: {}\n\t\t\t}\n\t\t*/\n\t\t\n\t\t// Who is making the query\n\t\tuserID: 0,\n\n\t\t// Where the query results are stuck\n\t\tresult: false\n\t\t/*\n\t\t\t{\n\t\t\t\texecuted: false, // True once we've run a query.\n\t\t\t\tvalue: false,    // The return value of the last query run\n\t\t\t\terror: false     // The error message of the last run query\n\t\t\t}\n\t\t*/\n});\n\nmodule.exports = FoxHoundQueryParameters;\n},{}],31:[function(require,module,exports){\n/**\n* FoxHound ALASQL Dialect\n*\n* @license MIT\n*\n* For an ALASQL query override:\n// An underscore template with the following values:\n//      <%= DataElements %> = Field1, Field2, Field3, Field4\n//      <%= Begin %>        = 0\n//      <%= Cap %>          = 10\n//      <%= Filter %>       = WHERE StartDate > :MyStartDate\n//      <%= Sort %>         = ORDER BY Field1\n// The values are empty strings if they aren't set.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectALASQL\n*/\n\nvar FoxHoundDialectALASQL = function(pFable)\n{\n\t//Request time from SQL server with microseconds resolution\n\tconst SQL_NOW = \"NOW(3)\";\n\n\t_Fable = pFable;\n\n\t/**\n\t* Generate a table name from the scope.\n\t*\n\t* Because ALASQL is all in-memory, and can be run in two modes (anonymous\n\t* working on arrays or table-based) we are going to make this a programmable\n\t* value.  Then we can share the code across both providers.\n\t*\n\t* @method: generateTableName\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateTableName = function(pParameters)\n\t{\n\t\treturn ' '+pParameters.scope;\n\t};\n\n\t/**\n\t* Escape columns, because ALASQL has more reserved KWs than most SQL dialects\n\t*/\n\tvar escapeColumn = (pColumn, pParameters) =>\n\t{\n\t\tif (pColumn.indexOf('.') < 0)\n\t\t{\n\t\t\treturn '`'+pColumn+'`';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This could suck if the scope is not the same\n\t\t\tvar tmpTableName = pParameters.scope;\n\t\t\tif (pColumn.indexOf(tmpTableName+'.') > -1)\n\t\t\t{\n\t\t\t\treturn '`'+pColumn.replace(tmpTableName+'.', '')+'`';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This doesn't work well but we'll try it.\n\t\t\t\treturn '`'+pColumn+'`';\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Generate a field list from the array of dataElements\n\t*\n\t* Each entry in the dataElements is a simple string\n\t*\n\t* @method: generateFieldList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @param {Boolean} pIsForCountClause (optional) If true, generate fields for use within a count clause.\n\t* @return: {String} Returns the field list clause, or empty string if explicit fields are requested but cannot be fulfilled\n\t*          due to missing schema.\n\t*/\n\tvar generateFieldList = function(pParameters, pIsForCountClause)\n\t{\n\t\tvar tmpDataElements = pParameters.dataElements;\n\t\tif (!Array.isArray(tmpDataElements) || tmpDataElements.length < 1)\n\t\t{\n\t\t\tif (!pIsForCountClause)\n\t\t\t{\n\t\t\t\treturn ' *';\n\t\t\t}\n\t\t\t// we need to list all of the table fields explicitly; get them from the schema\n\t\t\tconst tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tif (tmpSchema.length < 1)\n\t\t\t{\n\t\t\t\t// this means we have no schema; returning an empty string here signals the calling code to handle this case\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tconst idColumn = tmpSchema.find((entry) => entry.Type === 'AutoIdentity');\n\t\t\tif (!idColumn)\n\t\t\t{\n\t\t\t\t// this means there is no autoincrementing unique ID column; treat as above\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn ` ${idColumn.Column}`;\n\t\t}\n\n\t\tvar tmpFieldList = ' ';\n\t\tfor (var i = 0; i < tmpDataElements.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpFieldList += ', ';\n\t\t\t}\n\t\t\ttmpFieldList += escapeColumn(tmpDataElements[i], pParameters);\n\t\t}\n\t\treturn tmpFieldList;\n\t};\n\n\t/**\n\t* Generate a query from the array of where clauses\n\t*\n\t* Each clause is an object like:\n\t\t{\n\t\t\tColumn:'Name',\n\t\t\tOperator:'EQ',\n\t\t\tValue:'John',\n\t\t\tConnector:'And',\n\t\t\tParameter:'Name'\n\t\t}\n\t*\n\t* @method: generateWhere\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the WHERE clause prefixed with WHERE, or an empty string if unnecessary\n\t*/\n\tvar generateWhere = function(pParameters)\n\t{\n\t\tvar tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\t\tvar tmpTableName = generateTableName(pParameters).trim();\n\n\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t// Check if there is a Deleted column on the Schema. If so, we add this to the filters automatically (if not already present)\n\t\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\tvar tmpSchemaEntry = tmpSchema[i];\n\n\t\t\t\tif (tmpSchemaEntry.Type === 'Deleted')\n\t\t\t\t{\n\t\t\t\t\tvar tmpHasDeletedParameter = false;\n\n\t\t\t\t\t//first, check to see if filters are already looking for Deleted column\n\t\t\t\t\tif (tmpFilter.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var x = 0; x < tmpFilter.length; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpFilter[x].Column === tmpSchemaEntry.Column)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpHasDeletedParameter = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmpHasDeletedParameter)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if not, we need to add it\n\t\t\t\t\t\ttmpFilter.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tColumn: tmpTableName + '.' + tmpSchemaEntry.Column,\n\t\t\t\t\t\t\tOperator: '=',\n\t\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\t\tConnector: 'AND',\n\t\t\t\t\t\t\tParameter: 'Deleted'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpFilter.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpWhere = ' WHERE';\n\n\t\t// This is used to disable the connectors for subsequent queries.\n\t\t// Only the open parenthesis operator uses this, currently.\n\t\tvar tmpLastOperatorNoConnector = false;\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n\t\t\tif ((tmpFilter[i].Connector != 'NONE') && (tmpFilter[i].Operator != ')') && (tmpWhere != ' WHERE') && (tmpLastOperatorNoConnector == false))\n\t\t\t{\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Connector;\n\t\t\t}\n\n\t\t\ttmpLastOperatorNoConnector = false;\n\n\t\t\tvar tmpColumnParameter;\n\n\t\t\tif (tmpFilter[i].Operator === '(')\n\t\t\t{\n\t\t\t\t// Open a logical grouping\n\t\t\t\ttmpWhere += ' (';\n\t\t\t\ttmpLastOperatorNoConnector = true;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === ')')\n\t\t\t{\n\t\t\t\t// Close a logical grouping\n\t\t\t\ttmpWhere += ' )';\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IN')\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+escapeColumn(tmpFilter[i].Column, pParameters)+' '+tmpFilter[i].Operator+' ( :'+tmpColumnParameter+' )';\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NOT NULL')\n\t\t\t{\n\t\t\t\t// IS NOT NULL is a special operator which doesn't require a value, or parameter\n\t\t\t\ttmpWhere += ' '+escapeColumn(tmpFilter[i].Column, pParameters)+' '+tmpFilter[i].Operator;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+escapeColumn(tmpFilter[i].Column, pParameters)+' '+tmpFilter[i].Operator+' :'+tmpColumnParameter;\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpWhere;\n\t};\n\n\t/**\n\t* Generate an ORDER BY clause from the sort array\n\t*\n\t* Each entry in the sort is an object like:\n\t* {Column:'Color',Direction:'Descending'}\n\t*\n\t* @method: generateOrderBy\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the field list clause\n\t*/\n\tvar generateOrderBy = function(pParameters)\n\t{\n\t\tvar tmpOrderBy = pParameters.sort;\n\t\tif (!Array.isArray(tmpOrderBy) || tmpOrderBy.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpOrderClause = ' ORDER BY';\n\t\tfor (var i = 0; i < tmpOrderBy.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpOrderClause += ',';\n\t\t\t}\n\t\t\ttmpOrderClause += ' '+escapeColumn(tmpOrderBy[i].Column, pParameters);\n\n\t\t\tif (tmpOrderBy[i].Direction == 'Descending')\n\t\t\t{\n\t\t\t\ttmpOrderClause += ' DESC';\n\t\t\t}\n\t\t}\n\t\treturn tmpOrderClause;\n\t};\n\n\t/**\n\t* Generate the limit clause\n\t*\n\t* @method: generateLimit\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateLimit = function(pParameters)\n\t{\n\t\tif (!pParameters.cap)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpLimit = ' LIMIT';\n\t\t// Cap is required for a limit clause.\n\t\ttmpLimit += ' ' + pParameters.cap;\n\n\t\t// If there is a begin record, we'll pass that in as well.\n\t\tif (pParameters.begin !== false)\n\t\t{\n\t\t\ttmpLimit += ' FETCH ' + pParameters.begin;\n\t\t}\n\n\t\treturn tmpLimit;\n\t};\n\n\t/**\n\t* Generate the update SET clause\n\t*\n\t* @method: generateUpdateSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateSetters = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpUpdate = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pParameters.query.disableAutoDateStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateDate')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pParameters.query.disableAutoUserStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateIDUser')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// These are all ignored on update\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\ttmpUpdate += ' '+escapeColumn(tmpColumn, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+escapeColumn(tmpColumn, pParameters)+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvar tmpColumnDefaultParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+escapeColumn(tmpColumn, pParameters)+' = :'+tmpColumnDefaultParameter;\n\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnDefaultParameter] = tmpRecords[0][tmpColumn];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-delete SET clause\n\t*\n\t* @method: generateUpdateDeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateDeleteSetters = function(pParameters)\n\t{\n\t\tif (pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t//Don't generate an UPDATE query if Delete tracking is disabled\n\t\t\treturn false;\n\t\t}\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = 1';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// Delete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-delete SET clause\n\t*\n\t* @method: generateUpdateDeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateUndeleteSetters = function(pParameters)\n\t{\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = 0';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// Delete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetValues = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpCreateSet += ',';\n\t\t\t}\n\n\t\t\t//define a re-usable method for setting up field definitions in a default pattern\n\t\t\tvar buildDefaultDefinition = function()\n\t\t\t{\n\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t// Set the query parameter\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpRecords[0][tmpColumn];\n\t\t\t};\n\n\t\t\tvar tmpColumnParameter;\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' NULL';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AutoGUID':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpRecords[0][tmpColumn] &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn].length >= 5 &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn] !== '0x0000000000000000') //stricture default\n\t\t\t\t\t{\n\t\t\t\t\t\t// Allow consumer to override AutoGUID\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.UUID;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\tif (pParameters.query.disableAutoDateStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' NOW()';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\tif (pParameters.query.disableAutoUserStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use an appended number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpCreateSet === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetList = function(pParameters)\n\t{\n\t\t// The records were already validated by generateCreateSetValues\n\t\tvar tmpRecords = pParameters.query.records;\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tdefault:\n\t\t\t\t\tif (tmpCreateSet != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpCreateSet += ',';\n\t\t\t\t\t}\n\t\t\t\t\ttmpCreateSet += ' '+escapeColumn(tmpColumn, pParameters);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpCreateSetList = generateCreateSetList(pParameters);\n\t\tvar tmpCreateSetValues = generateCreateSetValues(pParameters);\n\n\t\tif (!tmpCreateSetValues)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'INSERT INTO'+tmpTableName+' ('+tmpCreateSetList+') VALUES ('+tmpCreateSetValues+');';\n\t};\n\n\n\t/**\n\t* Read one or many records\n\t*\n\t* Some examples:\n\t* SELECT * FROM WIDGETS;\n\t* SELECT * FROM WIDGETS LIMIT 0, 20;\n\t* SELECT * FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20 WHERE LastName = 'Smith';\n\t*\n\t* @method Read\n\t* @param {Object} pParameters SQL Query parameters\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpFieldList = generateFieldList(pParameters);\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpOrderBy = generateOrderBy(pParameters);\n\t\tvar tmpLimit = generateLimit(pParameters);\n\t\tconst tmpOptDistinct = pParameters.distinct ? ' DISTINCT' : '';\n\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:tmpFieldList, TableName:tmpTableName, Where:tmpWhere, OrderBy:tmpOrderBy, Limit:tmpLimit, Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Read Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT${tmpOptDistinct}${tmpFieldList} FROM${tmpTableName}${tmpWhere}${tmpOrderBy}${tmpLimit};`;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateSetters = generateUpdateSetters(pParameters);\n\n\t\tif (!tmpUpdateSetters)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateSetters+tmpWhere+';';\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateDeleteSetters = generateUpdateDeleteSetters(pParameters);\n\n\t\tif (tmpUpdateDeleteSetters)\n\t\t{\n\t\t\t//If it has a deleted bit, update it instead of actually deleting the record\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateDeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'DELETE FROM'+tmpTableName+tmpWhere+';';\n\t\t}\n\t};\n\n\tvar Undelete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tlet tmpDeleteTrackingState = pParameters.query.disableDeleteTracking;\n\t\tpParameters.query.disableDeleteTracking = true;\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateUndeleteSetters = generateUpdateUndeleteSetters(pParameters);\n\t\tpParameters.query.disableDeleteTracking = tmpDeleteTrackingState;\n\n\t\tif (tmpUpdateUndeleteSetters)\n\t\t{\n\t\t\t//If it has a deleted bit, update it instead of actually deleting the record\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateUndeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'SELECT NULL;';\n\t\t}\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tconst tmpFieldList = pParameters.distinct ? generateFieldList(pParameters, true) : '*';\n\n\t\t// here, we ignore the distinct keyword if no fields have been specified and\n\t\tif (pParameters.distinct && tmpFieldList.length < 1)\n\t\t{\n\t\t\tconsole.warn('Distinct requested but no field list or schema are available, so not honoring distinct for count query.');\n\t\t}\n\t\tconst tmpOptDistinct = pParameters.distinct && tmpFieldList.length > 0 ? 'DISTINCT' : '';\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:[], TableName:tmpTableName, Where:tmpWhere, OrderBy:'', Limit:'', Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Count Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT COUNT(${tmpOptDistinct}${tmpFieldList || '*'}) AS RowCount FROM${tmpTableName}${tmpWhere};`;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tUndelete: Undelete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t* Dialect Name\n\t*\n\t* @property name\n\t* @type string\n\t*/\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'ALASQL'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectALASQL;\n\n},{}],32:[function(require,module,exports){\n/**\n* FoxHound English Dialect\n*\n* Because if I can't ask for it in my native tongue, how am I going to ask a\n* complicated server for it?\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectEnglish\n*/\nvar FoxHoundDialectEnglish = function()\n{\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'Here is a '+tmpScope+'.';\n\t};\n\n\t/**\n\t* Read one or many records\n\t*\n\t* Some examples:\n\t* Please give me all your Widget records.  Thanks.\n\t* Please give me 20 Widget records.  Thanks.\n\t* Please give me 20 Widget records starting with record 5.  Thanks.\n\t* Please give me the ID, Name and Cost of 20 Widget records starting with record 5.  Thanks.\n\t* Please give me the ID and Name of 20 Widget records starting with record 5, when LastName equals \"Smith\".  Thanks.\n\t*\n\t* @method Read\n\t* @param {Number} pLogLevel The log level for our object\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\t\tconst tmpDistinct = pParameters.distinct ? 'unique ' : '';\n\n\t\treturn `Please give me all your ${tmpDistinct}${tmpScope} records.  Thanks.`;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'I am changing your '+tmpScope+'.';\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'I am deleting your '+tmpScope+'.';\n\t};\n\n\tvar Undelete = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'I am undeleting your '+tmpScope+'.';\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\t\tconst tmpDistinct = pParameters.distinct ? 'unique ' : '';\n\n\t\treturn `Count your ${tmpDistinct}${tmpScope}.`;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tUndelete: Undelete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t * Dialect Name\n\t *\n\t * @property name\n\t * @type string\n\t */\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'English'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectEnglish;\n\n},{}],33:[function(require,module,exports){\n/**\n* FoxHound Meadow Endpoints Dialect\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectMeadowEndpoints\n*/\n\nvar FoxHoundDialectMeadowEndpoints = function()\n{\n\t/**\n\t * Generate a table name from the scope\n\t *\n\t * @method: generateTableName\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the table name clause\n\t */\n\tvar generateTableName = function(pParameters)\n\t{\n\t\treturn pParameters.scope;\n\t};\n\n\t/**\n\t * Generate the Identity column from the schema or scope\n\t * \n\t * @method: generateIdentityColumnName\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the table name clause\n\t */\n\tvar generateIdentityColumnName = function(pParameters)\n\t{\n\t\t// TODO: See about using the Schema or the Schemata for this\n\t\treturn `ID${pParameters.scope}`;\n\t};\n\n\t/**\n\t * Generate a field list from the array of dataElements\n\t *\n\t * Each entry in the dataElements is a simple string\n\t *\n\t * @method: generateFieldList\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the field list clause\n\t */\n\tvar generateFieldList = function(pParameters)\n\t{\n\t\tvar tmpDataElements = pParameters.dataElements;\n\t\tif (!Array.isArray(tmpDataElements) || tmpDataElements.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpFieldList = '';\n\t\tfor (var i = 0; i < tmpDataElements.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpFieldList += ',';\n\t\t\t}\n\n            tmpFieldList += tmpDataElements[i];\n\t\t}\n\t\treturn tmpFieldList;\n\t};\n\n\t/**\n\t * Generate a query from the array of where clauses\n\t *\n\t * Each clause is an object like:\n\t\t{\n\t\t\tColumn:'Name', \n\t\t\tOperator:'EQ', \n\t\t\tValue:'John', \n\t\t\tConnector:'And', \n\t\t\tParameter:'Name'\n\t\t}\n\t *\n\t * @method: generateWhere\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the WHERE clause prefixed with WHERE, or an empty string if unnecessary\n\t */\n\tvar generateWhere = function(pParameters)\n\t{\n\t\tvar tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\t\tvar tmpTableName = generateTableName(pParameters);\n        \n        var tmpURL = '';\n\n        let tmpfAddFilter = (pFilterCommand, pFilterParameters) =>\n        {\n            if (tmpURL.length > 0)\n            {\n                tmpURL += '~';\n            }\n            \n            tmpURL += `${pFilterCommand}~${pFilterParameters[0]}~${pFilterParameters[1]}~${pFilterParameters[2]}`;\n        };\n\n        let tmpfTranslateOperator = (pOperator) =>\n        {\n            tmpNewOperator = 'EQ';\n            switch(pOperator.toUpperCase())\n            {\n                case '!=':\n                    tmpNewOperator = 'NE';\n                    break;\n                case '>':\n                    tmpNewOperator = 'GT';\n                    break;\n                case '>=':\n                    tmpNewOperator = 'GE';\n                    break;\n                case '<=':\n                    tmpNewOperator = 'LE';\n                    break;\n                case '<':\n                    tmpNewOperator = 'LT';\n                    break;\n                case 'LIKE':\n                    tmpNewOperator = 'LK';\n                    break;\n                case 'IN':\n                    tmpNewOperator = 'INN';\n                    break;\n                case 'NOT IN':\n                    tmpNewOperator = 'NI';\n                    break;\n            }\n            return tmpNewOperator;\n        }\n\n        // Translating Delete Tracking bit on query to a query with automagic\n        // This will eventually deprecate this as part of the necessary query\n        if (pParameters.query.disableDeleteTracking)\n        {\n            tmpfAddFilter('FBV',['Deleted','GE','0'])\n        }\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n\t\t\tif (tmpFilter[i].Operator === '(')\n\t\t\t{\n                tmpfAddFilter('FOP',['0','(','0']);\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === ')')\n\t\t\t{\n\t\t\t\t// Close a logical grouping\n                tmpfAddFilter('FCP',['0',')','0']);\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IN' || tmpFilter[i].Operator === \"NOT IN\")\n\t\t\t{\n                let tmpFilterCommand = 'FBV';\n                if (tmpFilter[i].Connector == 'OR')\n                {\n                    tmpFilterCommand = 'FBVOR';\n                }\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n                tmpfAddFilter(tmpFilterCommand, [tmpFilter[i].Column, tmpfTranslateOperator(tmpFilter[i].Operator), tmpFilter[i].Value.map(encodeURIComponent).join(',')])\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NULL')\n\t\t\t{\n\t\t\t\t// IS NULL is a special operator which doesn't require a value, or parameter\n                tmpfAddFilter('FBV', [tmpFilter[i].Column, 'IN', '0']);\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NOT NULL')\n\t\t\t{\n\t\t\t\t// IS NOT NULL is a special operator which doesn't require a value, or parameter\n                tmpfAddFilter('FBV', [tmpFilter[i].Column, 'NN', '0']);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                let tmpFilterCommand = 'FBV';\n                if (tmpFilter[i].Connector == 'OR')\n                {\n                    tmpFilterCommand = 'FBVOR';\n                }\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n                tmpfAddFilter(tmpFilterCommand, [tmpFilter[i].Column, tmpfTranslateOperator(tmpFilter[i].Operator), encodeURIComponent(tmpFilter[i].Value)]);\n\t\t\t}\n\t\t}\n\n        let tmpOrderBy = generateOrderBy(pParameters);\n        if (tmpOrderBy)\n        {\n            if (tmpURL)\n            {\n                tmpURL += '~';\n            }\n            tmpURL += tmpOrderBy;\n        }\n\n\t\treturn tmpURL;\n\t};\n\n    /**\n\t * Get the flags for the request\n     * \n     * These are usually passed in for Update and Create when extra tracking is disabled.\n\t *\n\t * @method: generateFlags\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Flags to be sent, if any.\n\t */\n    function generateFlags(pParameters)\n    {\n        let tmpDisableAutoDateStamp = pParameters.query.disableAutoDateStamp;\n        let tmpDisableDeleteTracking = pParameters.query.disableDeleteTracking;\n        let tmpDisableAutoIdentity = pParameters.query.disableAutoIdentity;\n        let tmpDisableAutoUserStamp = pParameters.query.disableAutoUserStamp;\n\n        let tmpFlags = '';\n\n        let fAddFlag = (pFlagSet, pFlag) =>\n            {\n                if (pFlagSet)\n                {\n                    if (tmpFlags.length > 0)\n                    {\n                        tmpFlags += ',';\n                    }\n                    tmpFlags += pFlag;\n                }\n            };\n\n        fAddFlag(tmpDisableAutoDateStamp, 'DisableAutoDateStamp');\n        fAddFlag(tmpDisableDeleteTracking, 'DisableDeleteTracking');\n        fAddFlag(tmpDisableAutoIdentity, 'DisableAutoIdentity');\n        fAddFlag(tmpDisableAutoUserStamp, 'DisableAutoUserStamp');\n\n        return tmpFlags;\n    };\n\n    /**\n\t * Get the ID for the record, to be used in URIs\n\t *\n\t * @method: getIDRecord\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} ID of the record in string form for the URI\n\t */\n\tvar getIDRecord = function(pParameters)\n\t{\n        var tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\n\t\tvar tmpIDRecord = false;\n\n        if (tmpFilter.length < 1)\n\t\t{\n\t\t\treturn tmpIDRecord;\n\t\t}\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n            // Check Schema Entry Type\n            var tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tvar tmpSchemaEntry = {Column:tmpFilter[i].Column, Type:'Default'};\n\t\t\tfor (var j = 0; j < tmpSchema.length; j++)\n\t\t\t{\n                // If this column is the AutoIdentity, set it.\n\t\t\t\tif ((tmpFilter[i].Column == tmpSchema[j].Column) &&\n                    (tmpSchema[j].Type == 'AutoIdentity'))\n\t\t\t\t{\n                    tmpIDRecord = tmpFilter[i].Value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpIDRecord;\n    }\n\t\n    /**\n\t * Generate an ORDER BY clause from the sort array\n\t *\n\t * Each entry in the sort is an object like:\n\t * {Column:'Color',Direction:'Descending'}\n\t *\n\t * @method: generateOrderBy\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the field list clause\n\t */\n\tvar generateOrderBy = function(pParameters)\n\t{\n\t\tvar tmpOrderBy = pParameters.sort;\n\t\tvar tmpOrderClause = false;\n\n        if (!Array.isArray(tmpOrderBy) || tmpOrderBy.length < 1)\n\t\t{\n\t\t\treturn tmpOrderClause;\n\t\t}\n\n        tmpOrderClause = '';\n\n        for (var i = 0; i < tmpOrderBy.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpOrderClause += '~';\n\t\t\t}\n\t\t\ttmpOrderClause += `FSF~${tmpOrderBy[i].Column}~`;\n\n\t\t\tif (tmpOrderBy[i].Direction == 'Descending')\n\t\t\t{\n\t\t\t\ttmpOrderClause += 'DESC~0';\n\t\t\t}\n            else\n            {\n                tmpOrderClause += 'ASC~0'\n            }\n\t\t}\n\t\treturn tmpOrderClause;\n\t};\n\n\t/**\n\t * Generate the limit clause\n\t *\n\t * @method: generateLimit\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the table name clause\n\t */\n\tvar generateLimit = function(pParameters)\n\t{\n\t\tif (!pParameters.cap)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n        let tmpBegin = (pParameters.begin !== false) ? pParameters.begin : 0;\n\n        return `${tmpBegin}/${pParameters.cap}`;\n\t};\n\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n        var tmpFlags = generateFlags(pParameters);\n\n        if (tmpTableName)\n        {\n            let tmpURL = tmpTableName;\n            if (tmpFlags)\n            {\n                tmpURL = `${tmpURL}/WithFlags/${tmpFlags}`\n            }\n            return tmpURL;\n        }\n        else\n        {\n            return false;\n        }\n\t};\n\n\n\t/**\n\t* Read one or many records\n\t*\n\t* @method Read\n\t* @param {Object} pParameters SQL Query parameters\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpFieldList = generateFieldList(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpLimit = generateLimit(pParameters);\n\n\t\tvar tmpURL = `${tmpTableName}`;\n\t\t// In the case that there is only a single query parameter, and the parameter is a single identity, \n\t\t// we will cast it to the READ endpoint rather than READS.\n\t\tif ((pParameters.filter)\n\t\t\t && (pParameters.filter.length == 1)\n             // If there is exactly one query filter parameter\n\t\t\t && (pParameters.filter[0].Column === generateIdentityColumnName(pParameters))\n\t\t\t // AND It is the Identity column\n\t\t\t && (pParameters.filter[0].Operator === '=')\n\t\t\t // AND The comparators is a simple equals \n\t\t\t && (tmpLimit == '') && (tmpFieldList == '')\n\t\t\t // AND There is no limit or field list set\n\t\t\t && (!pParameters.sort))\n\t\t\t // AND There is no sort clause\n\t\t{\n\t\t\t// THEN This is a SINGLE READ by presumption.\n\t\t\t// There are some bad side affects this could cause with chaining and overridden behaviors, if \n\t\t\t// we are requesting a filtered list of 1 record.\n\t\t\ttmpURL = `${tmpURL}/${pParameters.filter[0].Value}`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpURL = `${tmpURL}s`;\n\t\t\tif (tmpFieldList)\n\t\t\t{\n\t\t\t\ttmpURL = `${tmpURL}/LiteExtended/${tmpFieldList}`\n\t\t\t}\n\t\t\tif (tmpWhere)\n\t\t\t{\n\t\t\t\ttmpURL = `${tmpURL}/FilteredTo/${tmpWhere}`;\n\t\t\t}\n\t\t\tif (tmpLimit)\n\t\t\t{\n\t\t\t\ttmpURL = `${tmpURL}/${tmpLimit}`;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpURL;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n        var tmpFlags = generateFlags(pParameters);\n\n        if (tmpTableName)\n        {\n            let tmpURL = tmpTableName;\n            if (tmpFlags)\n            {\n                tmpURL = `${tmpURL}/WithFlags/${tmpFlags}`\n            }\n            return tmpURL;\n        }\n        else\n        {\n            return false;\n        }\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpIDRecord = getIDRecord(pParameters);\n\n        if (!tmpIDRecord)\n        {\n            return false;\n        }\n\n\t\treturn `${tmpTableName}/${tmpIDRecord}`;\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\n        let tmpCountQuery = `${tmpTableName}s/Count`;\n\n        if (tmpWhere)\n        {\n            return `${tmpTableName}s/Count/FilteredTo/${tmpWhere}`;\n        }\n\n        return tmpCountQuery;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t * Dialect Name\n\t *\n\t * @property name\n\t * @type string\n\t */\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'MeadowEndpoints'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectMeadowEndpoints;\n\n},{}],34:[function(require,module,exports){\n/**\n* FoxHound MySQL Dialect\n*\n* @license MIT\n*\n* For a MySQL query override:\n// An underscore template with the following values:\n//      <%= DataElements %> = Field1, Field2, Field3, Field4\n//      <%= Begin %>        = 0\n//      <%= Cap %>          = 10\n//      <%= Filter %>       = WHERE StartDate > :MyStartDate\n//      <%= Sort %>         = ORDER BY Field1\n// The values are empty strings if they aren't set.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectMySQL\n*/\n\nvar FoxHoundDialectMySQL = function(pFable)\n{\n\t//Request time from SQL server with microseconds resolution\n\tconst SQL_NOW = \"NOW(3)\";\n\n\t_Fable = pFable;\n\n\t/**\n\t* Generate a table name from the scope\n\t*\n\t* @method: generateTableName\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateTableName = function(pParameters)\n\t{\n\t\tif (pParameters.scope && pParameters.scope.indexOf('`') >= 0)\n\t\t\treturn ' '+pParameters.scope+'';\n\t\telse\n\t\t\treturn ' `'+pParameters.scope+'`';\n\t};\n\n\t/**\n\t* Generate a field list from the array of dataElements\n\t*\n\t* Each entry in the dataElements is a simple string\n\t*\n\t* @method: generateFieldList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @param {Boolean} pIsForCountClause (optional) If true, generate fields for use within a count clause.\n\t* @return: {String} Returns the field list clause, or empty string if explicit fields are requested but cannot be fulfilled\n\t*          due to missing schema.\n\t*/\n\tvar generateFieldList = function(pParameters, pIsForCountClause)\n\t{\n\t\tvar tmpDataElements = pParameters.dataElements;\n\t\tif (!Array.isArray(tmpDataElements) || tmpDataElements.length < 1)\n\t\t{\n\t\t\tconst tmpTableName = generateTableName(pParameters);\n\t\t\tif (!pIsForCountClause)\n\t\t\t{\n\t\t\t\treturn tmpTableName + '.*';\n\t\t\t}\n\t\t\t// we need to list all of the table fields explicitly; get them from the schema\n\t\t\tconst tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tif (tmpSchema.length < 1)\n\t\t\t{\n\t\t\t\t// this means we have no schema; returning an empty string here signals the calling code to handle this case\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tconst idColumn = tmpSchema.find((entry) => entry.Type === 'AutoIdentity');\n\t\t\tif (!idColumn)\n\t\t\t{\n\t\t\t\t// this means there is no autoincrementing unique ID column; treat as above\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tconst qualifiedIDColumn = `${tmpTableName}.${idColumn.Column}`;\n\t\t\treturn ` ${generateSafeFieldName(qualifiedIDColumn)}`;\n\t\t}\n\n\t\tvar tmpFieldList = ' ';\n\t\tfor (var i = 0; i < tmpDataElements.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpFieldList += ', ';\n\t\t\t}\n\t\t\tif (Array.isArray(tmpDataElements[i]))\n\t\t\t{\n\t\t\t\ttmpFieldList += generateSafeFieldName(tmpDataElements[i][0]);\n\t\t\t\tif (tmpDataElements[i].length > 1 && tmpDataElements[i][1])\n\t\t\t\t{\n\t\t\t\t\ttmpFieldList += \" AS \" + generateSafeFieldName(tmpDataElements[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpFieldList += generateSafeFieldName(tmpDataElements[i]);\n\t\t\t}\n\t\t}\n\t\treturn tmpFieldList;\n\t};\n\n\tconst SURROUNDING_QUOTES_AND_WHITESPACE_REGEX = /^[` ]+|[` ]+$/g;\n\n\tconst cleanseQuoting = (str) =>\n\t{\n\t\treturn str.replace(SURROUNDING_QUOTES_AND_WHITESPACE_REGEX, '');\n\t};\n\n\t/**\n\t* Ensure a field name is properly escaped.\n\t*/\n\tvar generateSafeFieldName = function(pFieldName)\n\t{\n\t\tlet pFieldNames = pFieldName.split('.');\n\t\tif (pFieldNames.length > 1)\n\t\t{\n\t\t\tconst cleansedFieldName = cleanseQuoting(pFieldNames[1]);\n\t\t\tif (cleansedFieldName === '*')\n\t\t\t{\n\t\t\t\t// do not put * as `*`\n\t\t\t\treturn \"`\" + cleanseQuoting(pFieldNames[0]) + \"`.*\";\n\t\t\t}\n\t\t\treturn \"`\" + cleanseQuoting(pFieldNames[0]) + \"`.`\" + cleansedFieldName + \"`\";\n\t\t}\n\t\tconst cleansedFieldName = cleanseQuoting(pFieldNames[0]);\n\t\tif (cleansedFieldName === '*')\n\t\t{\n\t\t\t// do not put * as `*`\n\t\t\treturn '*';\n\t\t}\n\t\treturn \"`\" + cleanseQuoting(pFieldNames[0]) + \"`\";\n\t}\n\n\t/**\n\t* Generate a query from the array of where clauses\n\t*\n\t* Each clause is an object like:\n\t\t{\n\t\t\tColumn:'Name',\n\t\t\tOperator:'EQ',\n\t\t\tValue:'John',\n\t\t\tConnector:'And',\n\t\t\tParameter:'Name'\n\t\t}\n\t*\n\t* @method: generateWhere\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the WHERE clause prefixed with WHERE, or an empty string if unnecessary\n\t*/\n\tvar generateWhere = function(pParameters)\n\t{\n\t\tvar tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\t\tvar tmpTableName = generateTableName(pParameters);\n\n\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t// Check if there is a Deleted column on the Schema. If so, we add this to the filters automatically (if not already present)\n\t\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\tvar tmpSchemaEntry = tmpSchema[i];\n\n\t\t\t\tif (tmpSchemaEntry.Type === 'Deleted')\n\t\t\t\t{\n\t\t\t\t\tvar tmpHasDeletedParameter = false;\n\n\t\t\t\t\t//first, check to see if filters are already looking for Deleted column\n\t\t\t\t\tif (tmpFilter.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var x = 0; x < tmpFilter.length; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpFilter[x].Column === tmpSchemaEntry.Column)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpHasDeletedParameter = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmpHasDeletedParameter)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if not, we need to add it\n\t\t\t\t\t\ttmpFilter.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tColumn: tmpTableName + '.' + tmpSchemaEntry.Column,\n\t\t\t\t\t\t\tOperator: '=',\n\t\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\t\tConnector: 'AND',\n\t\t\t\t\t\t\tParameter: 'Deleted'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpFilter.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpWhere = ' WHERE';\n\n\t\t// This is used to disable the connectors for subsequent queries.\n\t\t// Only the open parenthesis operator uses this, currently.\n\t\tvar tmpLastOperatorNoConnector = false;\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n\t\t\tif ((tmpFilter[i].Connector != 'NONE') && (tmpFilter[i].Operator != ')') && (tmpWhere != ' WHERE') && (tmpLastOperatorNoConnector == false))\n\t\t\t{\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Connector;\n\t\t\t}\n\n\t\t\ttmpLastOperatorNoConnector = false;\n\n\t\t\tvar tmpColumnParameter;\n\n\t\t\tif (tmpFilter[i].Operator === '(')\n\t\t\t{\n\t\t\t\t// Open a logical grouping\n\t\t\t\ttmpWhere += ' (';\n\t\t\t\ttmpLastOperatorNoConnector = true;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === ')')\n\t\t\t{\n\t\t\t\t// Close a logical grouping\n\t\t\t\ttmpWhere += ' )';\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IN' || tmpFilter[i].Operator === \"NOT IN\")\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator+' ( :'+tmpColumnParameter+' )';\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NULL')\n\t\t\t{\n\t\t\t\t// IS NULL is a special operator which doesn't require a value, or parameter\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NOT NULL')\n\t\t\t{\n\t\t\t\t// IS NOT NULL is a special operator which doesn't require a value, or parameter\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator+' :'+tmpColumnParameter;\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpWhere;\n\t};\n\n\t/**\n\t* Generate an ORDER BY clause from the sort array\n\t*\n\t* Each entry in the sort is an object like:\n\t* {Column:'Color',Direction:'Descending'}\n\t*\n\t* @method: generateOrderBy\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the field list clause\n\t*/\n\tvar generateOrderBy = function(pParameters)\n\t{\n\t\tvar tmpOrderBy = pParameters.sort;\n\t\tif (!Array.isArray(tmpOrderBy) || tmpOrderBy.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpOrderClause = ' ORDER BY';\n\t\tfor (var i = 0; i < tmpOrderBy.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpOrderClause += ',';\n\t\t\t}\n\t\t\ttmpOrderClause += ' '+tmpOrderBy[i].Column;\n\n\t\t\tif (tmpOrderBy[i].Direction == 'Descending')\n\t\t\t{\n\t\t\t\ttmpOrderClause += ' DESC';\n\t\t\t}\n\t\t}\n\t\treturn tmpOrderClause;\n\t};\n\n\t/**\n\t* Generate the limit clause\n\t*\n\t* @method: generateLimit\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateLimit = function(pParameters)\n\t{\n\t\tif (!pParameters.cap)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpLimit = ' LIMIT';\n\t\t// If there is a begin record, we'll pass that in as well.\n\t\tif (pParameters.begin !== false)\n\t\t{\n\t\t\ttmpLimit += ' ' + pParameters.begin + ',';\n\t\t}\n\t\t// Cap is required for a limit clause.\n\t\ttmpLimit += ' ' + pParameters.cap;\n\n\t\treturn tmpLimit;\n\t};\n\n\t/**\n\t* Generate the join clause\n\t*\n\t* @method: generateJoins\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the join clause\n\t*/\n\tvar generateJoins = function(pParameters)\n\t{\n\t\tvar tmpJoins = pParameters.join;\n\t\tif (!Array.isArray(tmpJoins) || tmpJoins.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpJoinClause = ''; //ex. ' INNER JOIN';\n\t\tfor (var i = 0; i < tmpJoins.length; i++)\n\t\t{\n\t\t\tvar join = tmpJoins[i];\n\t\t\t//verify that all required fields are valid\n\t\t\tif (join.Type && join.Table && join.From && join.To)\n\t\t\t{\n\t\t\t\ttmpJoinClause += ` ${join.Type} ${join.Table} ON ${join.From} = ${join.To}`;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpJoinClause;\n\t}\n\n\t/**\n\t* Generate the update SET clause\n\t*\n\t* @method: generateUpdateSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateSetters = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpUpdate = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pParameters.query.disableAutoDateStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateDate')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pParameters.query.disableAutoUserStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateIDUser')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// These are all ignored on update\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\ttmpUpdate += ' '+tmpColumn+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+tmpColumn+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvar tmpColumnDefaultParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+tmpColumn+' = :'+tmpColumnDefaultParameter;\n\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnDefaultParameter] = tmpRecords[0][tmpColumn];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-delete SET clause\n\t*\n\t* @method: generateUpdateDeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateDeleteSetters = function(pParameters)\n\t{\n\t\tif (pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t//Don't generate an UPDATE query if Delete tracking is disabled\n\t\t\treturn false;\n\t\t}\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = 1';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// Delete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-undelete SET clause\n\t*\n\t* @method: generateUpdateUndeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateUndeleteSetters = function(pParameters)\n\t{\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = 0';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// The undelete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = :'+tmpColumnParameter;\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetValues = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpCreateSet += ',';\n\t\t\t}\n\n\t\t\t//define a re-usable method for setting up field definitions in a default pattern\n\t\t\tvar buildDefaultDefinition = function()\n\t\t\t{\n\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t// Set the query parameter\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpRecords[0][tmpColumn];\n\t\t\t};\n\n\t\t\tvar tmpColumnParameter;\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' NULL';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AutoGUID':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpRecords[0][tmpColumn] &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn].length >= 5 &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn] !== '0x0000000000000000') //stricture default\n\t\t\t\t\t{\n\t\t\t\t\t\t// Allow consumer to override AutoGUID\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.UUID;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\tif (pParameters.query.disableAutoDateStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' ' + SQL_NOW;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\t\tif (pParameters.query.disableAutoUserStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use an appended number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpCreateSet === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetList = function(pParameters)\n\t{\n\t\t// The records were already validated by generateCreateSetValues\n\t\tvar tmpRecords = pParameters.query.records;\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tdefault:\n\t\t\t\t\tif (tmpCreateSet != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpCreateSet += ',';\n\t\t\t\t\t}\n\t\t\t\t\ttmpCreateSet += ' '+tmpColumn;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpCreateSetList = generateCreateSetList(pParameters);\n\t\tvar tmpCreateSetValues = generateCreateSetValues(pParameters);\n\n\t\tif (!tmpCreateSetValues)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'INSERT INTO'+tmpTableName+' ('+tmpCreateSetList+') VALUES ('+tmpCreateSetValues+');';\n\t};\n\n\n\t/**\n\t* Read one or many records\n\t*\n\t* Some examples:\n\t* SELECT * FROM WIDGETS;\n\t* SELECT * FROM WIDGETS LIMIT 0, 20;\n\t* SELECT * FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20 WHERE LastName = 'Smith';\n\t*\n\t* @method Read\n\t* @param {Object} pParameters SQL Query parameters\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpFieldList = generateFieldList(pParameters);\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpJoin = generateJoins(pParameters);\n\t\tvar tmpOrderBy = generateOrderBy(pParameters);\n\t\tvar tmpLimit = generateLimit(pParameters);\n\t\tconst tmpOptDistinct = pParameters.distinct ? ' DISTINCT' : '';\n\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:tmpFieldList, TableName:tmpTableName, Where:tmpWhere, Join:tmpJoin, OrderBy:tmpOrderBy, Limit:tmpLimit, Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Read Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT${tmpOptDistinct}${tmpFieldList} FROM${tmpTableName}${tmpJoin}${tmpWhere}${tmpOrderBy}${tmpLimit};`;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateSetters = generateUpdateSetters(pParameters);\n\n\t\tif (!tmpUpdateSetters)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateSetters+tmpWhere+';';\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateDeleteSetters = generateUpdateDeleteSetters(pParameters);\n\n\t\tif (tmpUpdateDeleteSetters)\n\t\t{\n\t\t\t//If it has a deleted bit, update it instead of actually deleting the record\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateDeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'DELETE FROM'+tmpTableName+tmpWhere+';';\n\t\t}\n\t};\n\n\tvar Undelete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\t// TODO: Fix these\n\t\tlet tmpDeleteTrackingState = pParameters.query.disableDeleteTracking;\n\t\tpParameters.query.disableDeleteTracking = true;\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateUndeleteSetters = generateUpdateUndeleteSetters(pParameters);\n\t\tpParameters.query.disableDeleteTracking = tmpDeleteTrackingState;\n\n\t\tif (tmpUpdateUndeleteSetters)\n\t\t{\n\t\t\t//If the table has a deleted bit, go forward with the update to change things.\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateUndeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This is a no-op because the record can't be undeleted.\n\t\t\t// TODO: Should it throw instead?\n\t\t\treturn 'SELECT NULL;';\n\t\t}\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpFieldList = pParameters.distinct ? generateFieldList(pParameters, true) : '*';\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpJoin = generateJoins(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\t// here, we ignore the distinct keyword if no fields have been specified and\n\t\tif (pParameters.distinct && tmpFieldList.length < 1)\n\t\t{\n\t\t\tconsole.warn('Distinct requested but no field list or schema are available, so not honoring distinct for count query.');\n\t\t}\n\t\tconst tmpOptDistinct = pParameters.distinct && tmpFieldList.length > 0 ? 'DISTINCT' : '';\n\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:[], TableName:tmpTableName, Where:tmpWhere, OrderBy:'', Limit:'', Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Count Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT COUNT(${tmpOptDistinct}${tmpFieldList || '*'}) AS RowCount FROM${tmpTableName}${tmpJoin}${tmpWhere};`;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tUndelete: Undelete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t* Dialect Name\n\t*\n\t* @property name\n\t* @type string\n\t*/\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'MySQL'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectMySQL;\n\n},{}],35:[function(require,module,exports){\n'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n},{}],36:[function(require,module,exports){\n'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n\n},{\"./implementation\":35}],37:[function(require,module,exports){\nvar util = require('util')\nvar isProperty = require('is-property')\n\nvar INDENT_START = /[\\{\\[]/\nvar INDENT_END = /[\\}\\]]/\n\n// from https://mathiasbynens.be/notes/reserved-keywords\nvar RESERVED = [\n  'do',\n  'if',\n  'in',\n  'for',\n  'let',\n  'new',\n  'try',\n  'var',\n  'case',\n  'else',\n  'enum',\n  'eval',\n  'null',\n  'this',\n  'true',\n  'void',\n  'with',\n  'await',\n  'break',\n  'catch',\n  'class',\n  'const',\n  'false',\n  'super',\n  'throw',\n  'while',\n  'yield',\n  'delete',\n  'export',\n  'import',\n  'public',\n  'return',\n  'static',\n  'switch',\n  'typeof',\n  'default',\n  'extends',\n  'finally',\n  'package',\n  'private',\n  'continue',\n  'debugger',\n  'function',\n  'arguments',\n  'interface',\n  'protected',\n  'implements',\n  'instanceof',\n  'NaN',\n  'undefined'\n]\n\nvar RESERVED_MAP = {}\n\nfor (var i = 0; i < RESERVED.length; i++) {\n  RESERVED_MAP[RESERVED[i]] = true\n}\n\nvar isVariable = function (name) {\n  return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name)\n}\n\nvar formats = {\n  s: function(s) {\n    return '' + s\n  },\n  d: function(d) {\n    return '' + Number(d)\n  },\n  o: function(o) {\n    return JSON.stringify(o)\n  }\n}\n\nvar genfun = function() {\n  var lines = []\n  var indent = 0\n  var vars = {}\n\n  var push = function(str) {\n    var spaces = ''\n    while (spaces.length < indent*2) spaces += '  '\n    lines.push(spaces+str)\n  }\n\n  var pushLine = function(line) {\n    if (INDENT_END.test(line.trim()[0]) && INDENT_START.test(line[line.length-1])) {\n      indent--\n      push(line)\n      indent++\n      return\n    }\n    if (INDENT_START.test(line[line.length-1])) {\n      push(line)\n      indent++\n      return\n    }\n    if (INDENT_END.test(line.trim()[0])) {\n      indent--\n      push(line)\n      return\n    }\n\n    push(line)\n  }\n\n  var line = function(fmt) {\n    if (!fmt) return line\n\n    if (arguments.length === 1 && fmt.indexOf('\\n') > -1) {\n      var lines = fmt.trim().split('\\n')\n      for (var i = 0; i < lines.length; i++) {\n        pushLine(lines[i].trim())\n      }\n    } else {\n      pushLine(util.format.apply(util, arguments))\n    }\n\n    return line\n  }\n\n  line.scope = {}\n  line.formats = formats\n\n  line.sym = function(name) {\n    if (!name || !isVariable(name)) name = 'tmp'\n    if (!vars[name]) vars[name] = 0\n    return name + (vars[name]++ || '')\n  }\n\n  line.property = function(obj, name) {\n    if (arguments.length === 1) {\n      name = obj\n      obj = ''\n    }\n\n    name = name + ''\n\n    if (isProperty(name)) return (obj ? obj + '.' + name : name)\n    return obj ? obj + '[' + JSON.stringify(name) + ']' : JSON.stringify(name)\n  }\n\n  line.toString = function() {\n    return lines.join('\\n')\n  }\n\n  line.toFunction = function(scope) {\n    if (!scope) scope = {}\n\n    var src = 'return ('+line.toString()+')'\n\n    Object.keys(line.scope).forEach(function (key) {\n      if (!scope[key]) scope[key] = line.scope[key]\n    })\n\n    var keys = Object.keys(scope).map(function(key) {\n      return key\n    })\n\n    var vals = keys.map(function(key) {\n      return scope[key]\n    })\n\n    return Function.apply(null, keys.concat(src)).apply(null, vals)\n  }\n\n  if (arguments.length) line.apply(null, arguments)\n\n  return line\n}\n\ngenfun.formats = formats\nmodule.exports = genfun\n\n},{\"is-property\":54,\"util\":171}],38:[function(require,module,exports){\nvar isProperty = require('is-property')\n\nvar gen = function(obj, prop) {\n  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'\n}\n\ngen.valid = isProperty\ngen.property = function (prop) {\n return isProperty(prop) ? prop : JSON.stringify(prop)\n}\n\nmodule.exports = gen\n\n},{\"is-property\":54}],39:[function(require,module,exports){\n'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\ntry {\n\tnull.error; // eslint-disable-line no-unused-expressions\n} catch (e) {\n\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\tvar errorProto = getProto(getProto(e));\n\tINTRINSICS['%Error.prototype%'] = errorProto;\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('has');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n},{\"function-bind\":36,\"has\":44,\"has-symbols\":41}],40:[function(require,module,exports){\n'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n},{\"get-intrinsic\":39}],41:[function(require,module,exports){\n'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n},{\"./shams\":42}],42:[function(require,module,exports){\n'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n},{}],43:[function(require,module,exports){\n'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n\n},{\"has-symbols/shams\":42}],44:[function(require,module,exports){\n'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n},{\"function-bind\":36}],45:[function(require,module,exports){\nvar http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n\n},{\"http\":144,\"url\":166}],46:[function(require,module,exports){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],47:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n},{}],48:[function(require,module,exports){\n'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n\n},{\"call-bind/callBound\":24,\"has-tostringtag/shams\":43}],49:[function(require,module,exports){\n'use strict';\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar objectClass = '[object Object]';\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar ddaClass = '[object HTMLAllCollection]'; // IE 11\nvar ddaClass2 = '[object HTML document.all class]';\nvar ddaClass3 = '[object HTMLCollection]'; // IE 9-10\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\n\nvar isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing\n\nvar isDDA = function isDocumentDotAll() { return false; };\nif (typeof document === 'object') {\n\t// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly\n\tvar all = document.all;\n\tif (toStr.call(all) === toStr.call(document.all)) {\n\t\tisDDA = function isDocumentDotAll(value) {\n\t\t\t/* globals document: false */\n\t\t\t// in IE 6-8, typeof document.all is \"object\" and it's truthy\n\t\t\tif ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {\n\t\t\t\ttry {\n\t\t\t\t\tvar str = toStr.call(value);\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstr === ddaClass\n\t\t\t\t\t\t|| str === ddaClass2\n\t\t\t\t\t\t|| str === ddaClass3 // opera 12.16\n\t\t\t\t\t\t|| str === objectClass // IE 6-8\n\t\t\t\t\t) && value('') == null; // eslint-disable-line eqeqeq\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n}\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value) && tryFunctionObject(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\tif (strClass !== fnClass && strClass !== genClass && !(/^\\[object HTML/).test(strClass)) { return false; }\n\t\treturn tryFunctionObject(value);\n\t};\n\n},{}],50:[function(require,module,exports){\n'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n\n},{\"has-tostringtag/shams\":43}],51:[function(require,module,exports){\nvar reIpv4FirstPass = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/\n\nvar reSubnetString = /\\/\\d{1,3}(?=%|$)/\nvar reForwardSlash = /\\//\nvar reZone = /%.*$/\nvar reBadCharacters = /([^0-9a-f:/%])/i\nvar reBadAddress = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\\/$)/i\n\nfunction validate4 (input) {\n  if (!(reIpv4FirstPass.test(input))) return false\n\n  var parts = input.split('.')\n\n  if (parts.length !== 4) return false\n\n  if (parts[0][0] === '0' && parts[0].length > 1) return false\n  if (parts[1][0] === '0' && parts[1].length > 1) return false\n  if (parts[2][0] === '0' && parts[2].length > 1) return false\n  if (parts[3][0] === '0' && parts[3].length > 1) return false\n\n  var n0 = Number(parts[0])\n  var n1 = Number(parts[1])\n  var n2 = Number(parts[2])\n  var n3 = Number(parts[3])\n\n  return (n0 >= 0 && n0 < 256 && n1 >= 0 && n1 < 256 && n2 >= 0 && n2 < 256 && n3 >= 0 && n3 < 256)\n}\n\nfunction validate6 (input) {\n  var withoutSubnet = input.replace(reSubnetString, '')\n  var hasSubnet = (input.length !== withoutSubnet.length)\n\n  // FIXME: this should probably be an option in the future\n  if (hasSubnet) return false\n\n  if (!hasSubnet) {\n    if (reForwardSlash.test(input)) return false\n  }\n\n  var withoutZone = withoutSubnet.replace(reZone, '')\n  var lastPartSeparator = withoutZone.lastIndexOf(':')\n\n  if (lastPartSeparator === -1) return false\n\n  var lastPart = withoutZone.substring(lastPartSeparator + 1)\n  var hasV4Part = validate4(lastPart)\n  var address = (hasV4Part ? withoutZone.substring(0, lastPartSeparator + 1) + '1234:5678' : withoutZone)\n\n  if (reBadCharacters.test(address)) return false\n  if (reBadAddress.test(address)) return false\n\n  var halves = address.split('::')\n\n  if (halves.length > 2) return false\n\n  if (halves.length === 2) {\n    var first = (halves[0] === '' ? [] : halves[0].split(':'))\n    var last = (halves[1] === '' ? [] : halves[1].split(':'))\n    var remainingLength = 8 - (first.length + last.length)\n\n    if (remainingLength <= 0) return false\n  } else {\n    if (address.split(':').length !== 8) return false\n  }\n\n  return true\n}\n\nfunction validate (input) {\n  return validate4(input) || validate6(input)\n}\n\nmodule.exports = function validator (options) {\n  if (!options) options = {}\n\n  if (options.version === 4) return validate4\n  if (options.version === 6) return validate6\n  if (options.version == null) return validate\n\n  throw new Error('Unknown version: ' + options.version)\n}\n\nmodule.exports['__all_regexes__'] = [\n  reIpv4FirstPass,\n  reSubnetString,\n  reForwardSlash,\n  reZone,\n  reBadCharacters,\n  reBadAddress\n]\n\n},{}],52:[function(require,module,exports){\nvar createIpValidator = require('is-my-ip-valid')\n\nvar reEmailWhitespace = /\\s/\nvar reHostnameFirstPass = /^[a-zA-Z0-9.-]+$/\nvar reHostnamePart = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/\nvar rePhoneFirstPass = /^\\+[0-9][0-9 ]{5,27}[0-9]$/\nvar rePhoneDoubleSpace = / {2}/\nvar rePhoneGlobalSpace = / /g\n\nexports['date-time'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+|)([zZ]|[+-]\\d{2}:\\d{2})$/\nexports['date'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/\nexports['time'] = /^\\d{2}:\\d{2}:\\d{2}$/\nexports['email'] = function (input) { return (input.indexOf('@') !== -1) && (!reEmailWhitespace.test(input)) }\nexports['ip-address'] = exports['ipv4'] = createIpValidator({ version: 4 })\nexports['ipv6'] = createIpValidator({ version: 6 })\nexports['uri'] = /^[a-zA-Z][a-zA-Z0-9+\\-.]*:[^\\s]*$/\nexports['color'] = /(#?([0-9A-Fa-f]{3,6})\\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\))/\nexports['hostname'] = function (input) {\n  if (!(reHostnameFirstPass.test(input))) return false\n\n  var parts = input.split('.')\n\n  for (var i = 0; i < parts.length; i++) {\n    if (!(reHostnamePart.test(parts[i]))) return false\n  }\n\n  return true\n}\nexports['alpha'] = /^[a-zA-Z]+$/\nexports['alphanumeric'] = /^[a-zA-Z0-9]+$/\nexports['style'] = /.:\\s*[^;]/g\nexports['phone'] = function (input) {\n  if (!(rePhoneFirstPass.test(input))) return false\n  if (rePhoneDoubleSpace.test(input)) return false\n\n  var digits = input.substring(1).replace(rePhoneGlobalSpace, '').length\n\n  return (digits >= 7 && digits <= 15)\n}\nexports['utc-millisec'] = /^[0-9]{1,15}\\.?[0-9]{0,15}$/\n\n},{\"is-my-ip-valid\":51}],53:[function(require,module,exports){\nvar genobj = require('generate-object-property')\nvar genfun = require('generate-function')\nvar jsonpointer = require('jsonpointer')\nvar xtend = require('xtend')\nvar formats = require('./formats')\n\nvar get = function(obj, additionalSchemas, ptr) {\n\n  var visit = function(sub) {\n    if (sub && sub.id === ptr) return sub\n    if (typeof sub !== 'object' || !sub) return null\n    return Object.keys(sub).reduce(function(res, k) {\n      return res || visit(sub[k])\n    }, null)\n  }\n\n  var res = visit(obj)\n  if (res) return res\n\n  ptr = ptr.replace(/^#/, '')\n  ptr = ptr.replace(/\\/$/, '')\n\n  try {\n    return jsonpointer.get(obj, decodeURI(ptr))\n  } catch (err) {\n    var end = ptr.indexOf('#')\n    var other\n    // external reference\n    if (end !== 0) {\n      // fragment doesn't exist.\n      if (end === -1) {\n        other = additionalSchemas[ptr]\n      } else {\n        var ext = ptr.slice(0, end)\n        other = additionalSchemas[ext]\n        var fragment = ptr.slice(end).replace(/^#/, '')\n        try {\n          return jsonpointer.get(other, fragment)\n        } catch (err) {}\n      }\n    } else {\n      other = additionalSchemas[ptr]\n    }\n    return other || null\n  }\n}\n\nvar types = {}\n\ntypes.any = function() {\n  return 'true'\n}\n\ntypes.null = function(name) {\n  return name+' === null'\n}\n\ntypes.boolean = function(name) {\n  return 'typeof '+name+' === \"boolean\"'\n}\n\ntypes.array = function(name) {\n  return 'Array.isArray('+name+')'\n}\n\ntypes.object = function(name) {\n  return 'typeof '+name+' === \"object\" && '+name+' && !Array.isArray('+name+')'\n}\n\ntypes.number = function(name) {\n  return 'typeof '+name+' === \"number\" && isFinite('+name+')'\n}\n\ntypes.integer = function(name) {\n  return 'typeof '+name+' === \"number\" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'\n}\n\ntypes.string = function(name) {\n  return 'typeof '+name+' === \"string\"'\n}\n\nvar unique = function(array, len) {\n  len = Math.min(len === -1 ? array.length : len, array.length)\n  var list = []\n  for (var i = 0; i < len; i++) {\n    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])\n  }\n  for (var i = 1; i < list.length; i++) {\n    if (list.indexOf(list[i]) !== i) return false\n  }\n  return true\n}\n\nvar isMultipleOf = function(name, multipleOf) {\n  var res;\n  var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1\n  if (factor > 1) {\n    var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1\n    if (factorName > factor) res = true\n    else res = Math.round(factor * name) % (factor * multipleOf)\n  }\n  else res = name % multipleOf;\n  return !res;\n}\n\nvar testLimitedRegex = function (r, s, maxLength) {\n  if (maxLength > -1 && s.length > maxLength) return true\n  return r.test(s)\n}\n\nvar compile = function(schema, cache, root, reporter, opts) {\n  var fmts = opts ? xtend(formats, opts.formats) : formats\n  var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf, testLimitedRegex:testLimitedRegex}\n  var verbose = opts ? !!opts.verbose : false;\n  var greedy = opts && opts.greedy !== undefined ?\n    opts.greedy : false;\n\n  var syms = {}\n  var allocated = []\n  var gensym = function(name) {\n    var res = name+(syms[name] = (syms[name] || 0)+1)\n    allocated.push(res)\n    return res\n  }\n\n  var formatName = function(field) {\n    var s = JSON.stringify(field)\n    try {\n      var pattern = /\\[([^\\[\\]\"]+)\\]/\n      while (pattern.test(s)) s = s.replace(pattern, replacer)\n      return s\n    } catch (_) {\n      return JSON.stringify(field)\n    }\n\n    function replacer (match, v) {\n      if (allocated.indexOf(v) === -1) throw new Error('Unreplaceable')\n      return '.\" + ' + v + ' + \"'\n    }\n  }\n\n  var reversePatterns = {}\n  var patterns = function(p) {\n    if (reversePatterns[p]) return reversePatterns[p]\n    var n = gensym('pattern')\n    scope[n] = new RegExp(p)\n    reversePatterns[p] = n\n    return n\n  }\n\n  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']\n  var genloop = function() {\n    var v = vars.shift()\n    vars.push(v+v[0])\n    allocated.push(v)\n    return v\n  }\n\n  var visit = function(name, node, reporter, filter, schemaPath) {\n    var properties = node.properties\n    var type = node.type\n    var tuple = false\n\n    if (Array.isArray(node.items)) { // tuple type\n      properties = {}\n      node.items.forEach(function(item, i) {\n        properties[i] = item\n      })\n      type = 'array'\n      tuple = true\n    }\n\n    var indent = 0\n    var error = function(msg, prop, value) {\n      validate('errors++')\n      if (reporter === true) {\n        validate('if (validate.errors === null) validate.errors = []')\n        if (verbose) {\n          validate(\n            'validate.errors.push({field:%s,message:%s,value:%s,type:%s,schemaPath:%s})',\n            formatName(prop || name),\n            JSON.stringify(msg),\n            value || name,\n            JSON.stringify(type),\n            JSON.stringify(schemaPath)\n          )\n        } else {\n          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))\n        }\n      }\n    }\n\n    if (node.required === true) {\n      indent++\n      validate('if (%s === undefined) {', name)\n      error('is required')\n      validate('} else {')\n    } else {\n      indent++\n      validate('if (%s !== undefined) {', name)\n    }\n\n    var valid = [].concat(type)\n      .map(function(t) {\n        if (t && !types.hasOwnProperty(t)) {\n          throw new Error('Unknown type: ' + t)\n        }\n\n        return types[t || 'any'](name)\n      })\n      .join(' || ') || 'true'\n\n    if (valid !== 'true') {\n      indent++\n      validate('if (!(%s)) {', valid)\n      error('is the wrong type')\n      validate('} else {')\n    }\n\n    if (tuple) {\n      if (node.additionalItems === false) {\n        validate('if (%s.length > %d) {', name, node.items.length)\n        error('has additional items')\n        validate('}')\n      } else if (node.additionalItems) {\n        var i = genloop()\n        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)\n        visit(name+'['+i+']', node.additionalItems, reporter, filter, schemaPath.concat('additionalItems'))\n        validate('}')\n      }\n    }\n\n    if (node.format && fmts[node.format]) {\n      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))\n      var n = gensym('format')\n      scope[n] = fmts[node.format]\n\n      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)\n      else validate('if (!testLimitedRegex(%s, %s, %d)) {', n, name, typeof node.maxLength === 'undefined' ? -1 : node.maxLength)\n      error('must be '+node.format+' format')\n      validate('}')\n      if (type !== 'string' && formats[node.format]) validate('}')\n    }\n\n    if (Array.isArray(node.required)) {\n      var n = gensym('missing')\n      validate('var %s = 0', n)\n      var checkRequired = function (req) {\n        var prop = genobj(name, req);\n        validate('if (%s === undefined) {', prop)\n        error('is required', prop)\n        validate('%s++', n)\n        validate('}')\n      }\n      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')\n      node.required.map(checkRequired)\n      validate('}');\n      if (!greedy) {\n        validate('if (%s === 0) {', n)\n        indent++\n      }\n    }\n\n    if (node.uniqueItems) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n      validate('if (!(unique(%s, %d))) {', name, node.maxItems || -1)\n      error('must be unique')\n      validate('}')\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.enum) {\n      var complex = node.enum.some(function(e) {\n        return typeof e === 'object'\n      })\n\n      var compare = complex ?\n        function(e) {\n          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'\n        } :\n        function(e) {\n          return name+' !== '+JSON.stringify(e)\n        }\n\n      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')\n      error('must be an enum value')\n      validate('}')\n    }\n\n    if (node.dependencies) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      Object.keys(node.dependencies).forEach(function(key) {\n        var deps = node.dependencies[key]\n        if (typeof deps === 'string') deps = [deps]\n\n        var exists = function(k) {\n          return genobj(name, k) + ' !== undefined'\n        }\n\n        if (Array.isArray(deps)) {\n          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')\n          error('dependencies not set')\n          validate('}')\n        }\n        if (typeof deps === 'object') {\n          validate('if (%s !== undefined) {', genobj(name, key))\n          visit(name, deps, reporter, filter, schemaPath.concat(['dependencies', key]))\n          validate('}')\n        }\n      })\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.additionalProperties || node.additionalProperties === false) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      var i = genloop()\n      var keys = gensym('keys')\n\n      var toCompare = function(p) {\n        return keys+'['+i+'] !== '+JSON.stringify(p)\n      }\n\n      var toTest = function(p) {\n        return '!'+patterns(p)+'.test('+keys+'['+i+'])'\n      }\n\n      var additionalProp = Object.keys(properties || {}).map(toCompare)\n        .concat(Object.keys(node.patternProperties || {}).map(toTest))\n        .join(' && ') || 'true'\n\n      validate('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n          ('if (%s) {', additionalProp)\n\n      if (node.additionalProperties === false) {\n        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')\n        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')\n      } else {\n        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter, schemaPath.concat(['additionalProperties']))\n      }\n\n      validate\n          ('}')\n        ('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.$ref) {\n      var sub = get(root, opts && opts.schemas || {}, node.$ref)\n      if (sub) {\n        var fn = cache[node.$ref]\n        if (!fn) {\n          cache[node.$ref] = function proxy(data) {\n            return fn(data)\n          }\n          fn = compile(sub, cache, root, false, opts)\n        }\n        var n = gensym('ref')\n        scope[n] = fn\n        validate('if (!(%s(%s))) {', n, name)\n        error('referenced schema does not match')\n        validate('}')\n      }\n    }\n\n    if (node.not) {\n      var prev = gensym('prev')\n      validate('var %s = errors', prev)\n      visit(name, node.not, false, filter, schemaPath.concat('not'))\n      validate('if (%s === errors) {', prev)\n      error('negative schema matches')\n      validate('} else {')\n        ('errors = %s', prev)\n      ('}')\n    }\n\n    if (node.items && !tuple) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      var i = genloop()\n      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)\n      visit(name+'['+i+']', node.items, reporter, filter, schemaPath.concat('items'))\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.patternProperties) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n      var keys = gensym('keys')\n      var i = genloop()\n      validate\n        ('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n\n      Object.keys(node.patternProperties).forEach(function(key) {\n        var p = patterns(key)\n        validate('if (%s.test(%s)) {', p, keys+'['+i+']')\n        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter, schemaPath.concat(['patternProperties', key]))\n        validate('}')\n      })\n\n      validate('}')\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.pattern) {\n      var p = patterns(node.pattern)\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n      validate('if (!(testLimitedRegex(%s, %s, %d))) {', p, name, typeof node.maxLength === 'undefined' ? -1 : node.maxLength)\n      error('pattern mismatch')\n      validate('}')\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.allOf) {\n      node.allOf.forEach(function(sch, key) {\n        visit(name, sch, reporter, filter, schemaPath.concat(['allOf', key]))\n      })\n    }\n\n    if (node.anyOf && node.anyOf.length) {\n      var prev = gensym('prev')\n\n      node.anyOf.forEach(function(sch, i) {\n        if (i === 0) {\n          validate('var %s = errors', prev)\n        } else {\n          validate('if (errors !== %s) {', prev)\n            ('errors = %s', prev)\n        }\n        visit(name, sch, false, false, schemaPath)\n      })\n      node.anyOf.forEach(function(sch, i) {\n        if (i) validate('}')\n      })\n      validate('if (%s !== errors) {', prev)\n      error('no schemas match')\n      validate('}')\n    }\n\n    if (node.oneOf && node.oneOf.length) {\n      var prev = gensym('prev')\n      var passes = gensym('passes')\n\n      validate\n        ('var %s = errors', prev)\n        ('var %s = 0', passes)\n\n      node.oneOf.forEach(function(sch, i) {\n        visit(name, sch, false, false, schemaPath)\n        validate('if (%s === errors) {', prev)\n          ('%s++', passes)\n        ('} else {')\n          ('errors = %s', prev)\n        ('}')\n      })\n\n      validate('if (%s !== 1) {', passes)\n      error('no (or more than one) schemas match')\n      validate('}')\n    }\n\n    if (node.multipleOf !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)\n\n      error('has a remainder')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maxProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)\n      error('has more properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.minProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)\n      error('has less properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.maxItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length > %d) {', name, node.maxItems)\n      error('has more items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.minItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length < %d) {', name, node.minItems)\n      error('has less items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.maxLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length > %d) {', name, node.maxLength)\n      error('has longer length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length < %d) {', name, node.minLength)\n      error('has less length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minimum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)\n      error('is less than minimum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maximum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)\n      error('is more than maximum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (properties) {\n      Object.keys(properties).forEach(function(p) {\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)\n\n        visit(\n          genobj(name, p),\n          properties[p],\n          reporter,\n          filter,\n          schemaPath.concat(tuple ? p : ['properties', p])\n        )\n\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')\n      })\n    }\n\n    while (indent--) validate('}')\n  }\n\n  var validate = genfun\n    ('function validate(data) {')\n      // Since undefined is not a valid JSON value, we coerce to null and other checks will catch this\n      ('if (data === undefined) data = null')\n      ('validate.errors = null')\n      ('var errors = 0')\n\n  visit('data', schema, reporter, opts && opts.filter, [])\n\n  validate\n      ('return errors === 0')\n    ('}')\n\n  validate = validate.toFunction(scope)\n  validate.errors = null\n\n  if (Object.defineProperty) {\n    Object.defineProperty(validate, 'error', {\n      get: function() {\n        if (!validate.errors) return ''\n        return validate.errors.map(function(err) {\n          return err.field + ' ' + err.message;\n        }).join('\\n')\n      }\n    })\n  }\n\n  validate.toJSON = function() {\n    return schema\n  }\n\n  return validate\n}\n\nmodule.exports = function(schema, opts) {\n  if (typeof schema === 'string') schema = JSON.parse(schema)\n  return compile(schema, {}, schema, true, opts)\n}\n\nmodule.exports.filter = function(schema, opts) {\n  var validate = module.exports(schema, xtend(opts, {filter: true}))\n  return function(sch) {\n    validate(sch)\n    return sch\n  }\n}\n\n},{\"./formats\":52,\"generate-function\":37,\"generate-object-property\":38,\"jsonpointer\":57,\"xtend\":174}],54:[function(require,module,exports){\n\"use strict\"\nfunction isProperty(str) {\n  return /^[$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc][$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc0-9\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19b0-\\u19c0\\u19c8\\u19c9\\u19d0-\\u19d9\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1dc0-\\u1de6\\u1dfc-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f]*$/.test(str)\n}\nmodule.exports = isProperty\n},{}],55:[function(require,module,exports){\n(function (global){(function (){\n'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar gOPD = require('gopd');\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"available-typed-arrays\":18,\"call-bind/callBound\":24,\"for-each\":27,\"gopd\":40,\"has-tostringtag/shams\":43}],56:[function(require,module,exports){\n(function (Buffer){(function (){\n/*global Buffer*/\n// Named constants with unique integer values\nvar C = {};\n// Tokens\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;\nvar COLON         = C.COLON         = 0x5;\nvar COMMA         = C.COMMA         = 0x6;\nvar TRUE          = C.TRUE          = 0x7;\nvar FALSE         = C.FALSE         = 0x8;\nvar NULL          = C.NULL          = 0x9;\nvar STRING        = C.STRING        = 0xa;\nvar NUMBER        = C.NUMBER        = 0xb;\n// Tokenizer States\nvar START   = C.START   = 0x11;\nvar STOP    = C.STOP    = 0x12;\nvar TRUE1   = C.TRUE1   = 0x21;\nvar TRUE2   = C.TRUE2   = 0x22;\nvar TRUE3   = C.TRUE3   = 0x23;\nvar FALSE1  = C.FALSE1  = 0x31;\nvar FALSE2  = C.FALSE2  = 0x32;\nvar FALSE3  = C.FALSE3  = 0x33;\nvar FALSE4  = C.FALSE4  = 0x34;\nvar NULL1   = C.NULL1   = 0x41;\nvar NULL2   = C.NULL2   = 0x42;\nvar NULL3   = C.NULL3   = 0x43;\nvar NUMBER1 = C.NUMBER1 = 0x51;\nvar NUMBER3 = C.NUMBER3 = 0x53;\nvar STRING1 = C.STRING1 = 0x61;\nvar STRING2 = C.STRING2 = 0x62;\nvar STRING3 = C.STRING3 = 0x63;\nvar STRING4 = C.STRING4 = 0x64;\nvar STRING5 = C.STRING5 = 0x65;\nvar STRING6 = C.STRING6 = 0x66;\n// Parser States\nvar VALUE   = C.VALUE   = 0x71;\nvar KEY     = C.KEY     = 0x72;\n// Parser Modes\nvar OBJECT  = C.OBJECT  = 0x81;\nvar ARRAY   = C.ARRAY   = 0x82;\n// Character constants\nvar BACK_SLASH =      \"\\\\\".charCodeAt(0);\nvar FORWARD_SLASH =   \"\\/\".charCodeAt(0);\nvar BACKSPACE =       \"\\b\".charCodeAt(0);\nvar FORM_FEED =       \"\\f\".charCodeAt(0);\nvar NEWLINE =         \"\\n\".charCodeAt(0);\nvar CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nvar TAB =             \"\\t\".charCodeAt(0);\n\nvar STRING_BUFFER_SIZE = 64 * 1024;\n\nfunction Parser() {\n  this.tState = START;\n  this.value = undefined;\n\n  this.string = undefined; // string data\n  this.stringBuffer = Buffer.alloc ? Buffer.alloc(STRING_BUFFER_SIZE) : new Buffer(STRING_BUFFER_SIZE);\n  this.stringBufferOffset = 0;\n  this.unicode = undefined; // unicode escapes\n  this.highSurrogate = undefined;\n\n  this.key = undefined;\n  this.mode = undefined;\n  this.stack = [];\n  this.state = VALUE;\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n  this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n\n  // Stream offset\n  this.offset = -1;\n}\n\n// Slow code to string converter (only used when throwing syntax errors)\nParser.toknam = function (code) {\n  var keys = Object.keys(C);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (C[key] === code) { return key; }\n  }\n  return code && (\"0x\" + code.toString(16));\n};\n\nvar proto = Parser.prototype;\nproto.onError = function (err) { throw err; };\nproto.charError = function (buffer, i) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n};\nproto.appendStringChar = function (char) {\n  if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8');\n    this.stringBufferOffset = 0;\n  }\n\n  this.stringBuffer[this.stringBufferOffset++] = char;\n};\nproto.appendStringBuf = function (buf, start, end) {\n  var size = buf.length;\n  if (typeof start === 'number') {\n    if (typeof end === 'number') {\n      if (end < 0) {\n        // adding a negative end decreeses the size\n        size = buf.length - start + end;\n      } else {\n        size = end - start;\n      }\n    } else {\n      size = buf.length - start;\n    }\n  }\n\n  if (size < 0) {\n    size = 0;\n  }\n\n  if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n    this.stringBufferOffset = 0;\n  }\n\n  buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);\n  this.stringBufferOffset += size;\n};\nproto.write = function (buffer) {\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);\n  var n;\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    if (this.tState === START){\n      n = buffer[i];\n      this.offset++;\n      if(n === 0x7b){ this.onToken(LEFT_BRACE, \"{\"); // {\n      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, \"}\"); // }\n      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, \"[\"); // [\n      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, \"]\"); // ]\n      }else if(n === 0x3a){ this.onToken(COLON, \":\");  // :\n      }else if(n === 0x2c){ this.onToken(COMMA, \",\"); // ,\n      }else if(n === 0x74){ this.tState = TRUE1;  // t\n      }else if(n === 0x66){ this.tState = FALSE1;  // f\n      }else if(n === 0x6e){ this.tState = NULL1; // n\n      }else if(n === 0x22){ // \"\n        this.string = \"\";\n        this.stringBufferOffset = 0;\n        this.tState = STRING1;\n      }else if(n === 0x2d){ this.string = \"-\"; this.tState = NUMBER1; // -\n      }else{\n        if (n >= 0x30 && n < 0x40) { // 1-9\n          this.string = String.fromCharCode(n); this.tState = NUMBER3;\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {\n          // whitespace\n        } else {\n          return this.charError(buffer, i);\n        }\n      }\n    }else if (this.tState === STRING1){ // After open quote\n      n = buffer[i]; // get current byte from buffer\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];\n        }\n\n        this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n        i = i + j - 1;\n      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if (n <= 193 || n > 244) {\n          return this.onError(new Error(\"Invalid UTF-8 character at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n        }\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= (buffer.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;\n          i = buffer.length - 1;\n        } else {\n          this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);\n          i = i + this.bytes_in_sequence - 1;\n        }\n      } else if (n === 0x22) {\n        this.tState = START;\n        this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n        this.stringBufferOffset = 0;\n        this.onToken(STRING, this.string);\n        this.offset += Buffer.byteLength(this.string, 'utf8') + 1;\n        this.string = undefined;\n      }\n      else if (n === 0x5c) {\n        this.tState = STRING2;\n      }\n      else if (n >= 0x20) { this.appendStringChar(n); }\n      else {\n          return this.charError(buffer, i);\n      }\n    }else if (this.tState === STRING2){ // After backslash\n      n = buffer[i];\n      if(n === 0x22){ this.appendStringChar(n); this.tState = STRING1;\n      }else if(n === 0x5c){ this.appendStringChar(BACK_SLASH); this.tState = STRING1;\n      }else if(n === 0x2f){ this.appendStringChar(FORWARD_SLASH); this.tState = STRING1;\n      }else if(n === 0x62){ this.appendStringChar(BACKSPACE); this.tState = STRING1;\n      }else if(n === 0x66){ this.appendStringChar(FORM_FEED); this.tState = STRING1;\n      }else if(n === 0x6e){ this.appendStringChar(NEWLINE); this.tState = STRING1;\n      }else if(n === 0x72){ this.appendStringChar(CARRIAGE_RETURN); this.tState = STRING1;\n      }else if(n === 0x74){ this.appendStringChar(TAB); this.tState = STRING1;\n      }else if(n === 0x75){ this.unicode = \"\"; this.tState = STRING3;\n      }else{\n        return this.charError(buffer, i);\n      }\n    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes\n      n = buffer[i];\n      // 0-9 A-F a-f\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {\n        this.unicode += String.fromCharCode(n);\n        if (this.tState++ === STRING6) {\n          var intVal = parseInt(this.unicode, 16);\n          this.unicode = undefined;\n          if (this.highSurrogate !== undefined && intVal >= 0xDC00 && intVal < (0xDFFF + 1)) { //<56320,57343> - lowSurrogate\n            this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal)));\n            this.highSurrogate = undefined;\n          } else if (this.highSurrogate === undefined && intVal >= 0xD800 && intVal < (0xDBFF + 1)) { //<55296,56319> - highSurrogate\n            this.highSurrogate = intVal;\n          } else {\n            if (this.highSurrogate !== undefined) {\n              this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate)));\n              this.highSurrogate = undefined;\n            }\n            this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));\n          }\n          this.tState = STRING1;\n        }\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {\n        n = buffer[i];\n\n        switch (n) {\n          case 0x30: // 0\n          case 0x31: // 1\n          case 0x32: // 2\n          case 0x33: // 3\n          case 0x34: // 4\n          case 0x35: // 5\n          case 0x36: // 6\n          case 0x37: // 7\n          case 0x38: // 8\n          case 0x39: // 9\n          case 0x2e: // .\n          case 0x65: // e\n          case 0x45: // E\n          case 0x2b: // +\n          case 0x2d: // -\n            this.string += String.fromCharCode(n);\n            this.tState = NUMBER3;\n            break;\n          default:\n            this.tState = START;\n            var result = Number(this.string);\n\n            if (isNaN(result)){\n              return this.charError(buffer, i);\n            }\n\n            if ((this.string.match(/[0-9]+/) == this.string) && (result.toString() != this.string)) {\n              // Long string of digits which is an ID string and not valid and/or safe JavaScript integer Number\n              this.onToken(STRING, this.string);\n            } else {\n              this.onToken(NUMBER, result);\n            }\n\n            this.offset += this.string.length - 1;\n            this.string = undefined;\n            i--;\n            break;\n        }\n    }else if (this.tState === TRUE1){ // r\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === TRUE2){ // u\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === TRUE3){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); this.offset+= 3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE1){ // a\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE2){ // l\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE3){ // s\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE4){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); this.offset+= 4; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL1){ // u\n      if (buffer[i] === 0x75) { this.tState = NULL2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL2){ // l\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL3){ // l\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); this.offset += 3; }\n      else { return this.charError(buffer, i); }\n    }\n  }\n};\nproto.onToken = function (token, value) {\n  // Override this to get events\n};\n\nproto.parseError = function (token, value) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + Parser.toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + Parser.toknam(this.state)));\n};\nproto.push = function () {\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});\n};\nproto.pop = function () {\n  var value = this.value;\n  var parent = this.stack.pop();\n  this.value = parent.value;\n  this.key = parent.key;\n  this.mode = parent.mode;\n  this.emit(value);\n  if (!this.mode) { this.state = VALUE; }\n};\nproto.emit = function (value) {\n  if (this.mode) { this.state = COMMA; }\n  this.onValue(value);\n};\nproto.onValue = function (value) {\n  // Override me\n};\nproto.onToken = function (token, value) {\n  if(this.state === VALUE){\n    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){\n      if (this.value) {\n        this.value[this.key] = value;\n      }\n      this.emit(value);\n    }else if(token === LEFT_BRACE){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = {};\n      } else {\n        this.value = {};\n      }\n      this.key = undefined;\n      this.state = KEY;\n      this.mode = OBJECT;\n    }else if(token === LEFT_BRACKET){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = [];\n      } else {\n        this.value = [];\n      }\n      this.key = 0;\n      this.mode = ARRAY;\n      this.state = VALUE;\n    }else if(token === RIGHT_BRACE){\n      if (this.mode === OBJECT) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    }else if(token === RIGHT_BRACKET){\n      if (this.mode === ARRAY) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    }else{\n      return this.parseError(token, value);\n    }\n  }else if(this.state === KEY){\n    if (token === STRING) {\n      this.key = value;\n      this.state = COLON;\n    } else if (token === RIGHT_BRACE) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  }else if(this.state === COLON){\n    if (token === COLON) { this.state = VALUE; }\n    else { return this.parseError(token, value); }\n  }else if(this.state === COMMA){\n    if (token === COMMA) {\n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }\n      else if (this.mode === OBJECT) { this.state = KEY; }\n\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  }else{\n    return this.parseError(token, value);\n  }\n};\n\nParser.C = C;\n\nmodule.exports = Parser;\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":22}],57:[function(require,module,exports){\nvar hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    if (pointer[p] === 'constructor' || pointer[p] === 'prototype' || pointer[p] === '__proto__') return obj\n\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    for (const part of pointer) {\n      if (typeof part !== 'string' && typeof part !== 'number') {\n        throw new Error('Invalid JSON pointer. Must be of type string or number.')\n      }\n    }\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object' || obj === null) return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n\n},{}],58:[function(require,module,exports){\nvar root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n},{\"./_root\":74}],59:[function(require,module,exports){\nvar baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n},{\"./_baseTimes\":64,\"./_isIndex\":68,\"./isArguments\":75,\"./isArray\":76,\"./isBuffer\":78,\"./isTypedArray\":83}],60:[function(require,module,exports){\nvar Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n},{\"./_Symbol\":58,\"./_getRawTag\":67,\"./_objectToString\":72}],61:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n},{\"./_baseGetTag\":60,\"./isObjectLike\":82}],62:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n},{\"./_baseGetTag\":60,\"./isLength\":80,\"./isObjectLike\":82}],63:[function(require,module,exports){\nvar isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n},{\"./_isPrototype\":69,\"./_nativeKeys\":70}],64:[function(require,module,exports){\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n},{}],65:[function(require,module,exports){\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n},{}],66:[function(require,module,exports){\n(function (global){(function (){\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],67:[function(require,module,exports){\nvar Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n},{\"./_Symbol\":58}],68:[function(require,module,exports){\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n},{}],69:[function(require,module,exports){\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n},{}],70:[function(require,module,exports){\nvar overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n},{\"./_overArg\":73}],71:[function(require,module,exports){\nvar freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n},{\"./_freeGlobal\":66}],72:[function(require,module,exports){\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n},{}],73:[function(require,module,exports){\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n},{}],74:[function(require,module,exports){\nvar freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n},{\"./_freeGlobal\":66}],75:[function(require,module,exports){\nvar baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n},{\"./_baseIsArguments\":61,\"./isObjectLike\":82}],76:[function(require,module,exports){\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n},{}],77:[function(require,module,exports){\nvar isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n},{\"./isFunction\":79,\"./isLength\":80}],78:[function(require,module,exports){\nvar root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n},{\"./_root\":74,\"./stubFalse\":86}],79:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n},{\"./_baseGetTag\":60,\"./isObject\":81}],80:[function(require,module,exports){\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n},{}],81:[function(require,module,exports){\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n},{}],82:[function(require,module,exports){\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n},{}],83:[function(require,module,exports){\nvar baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n},{\"./_baseIsTypedArray\":62,\"./_baseUnary\":65,\"./_nodeUtil\":71}],84:[function(require,module,exports){\nvar arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n},{\"./_arrayLikeKeys\":59,\"./_baseKeys\":63,\"./isArrayLike\":77}],85:[function(require,module,exports){\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n\n},{}],86:[function(require,module,exports){\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n},{}],87:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _initialParams = require('./internal/initialParams.js');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if ((0, _wrapAsync.isAsync)(func)) {\n        return function (...args /*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback);\n        };\n    }\n\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback);\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        (0, _setImmediate2.default)(e => {\n            throw e;\n        }, err);\n    }\n}\nmodule.exports = exports['default'];\n},{\"./internal/initialParams.js\":95,\"./internal/setImmediate.js\":100,\"./internal/wrapAsync.js\":102}],88:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit = require('./internal/eachOfLimit.js');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _withoutIndex = require('./internal/withoutIndex.js');\n\nvar _withoutIndex2 = _interopRequireDefault(_withoutIndex);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachLimit(coll, limit, iteratee, callback) {\n  return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);\n}\nexports.default = (0, _awaitify2.default)(eachLimit, 4);\nmodule.exports = exports['default'];\n},{\"./internal/awaitify.js\":91,\"./internal/eachOfLimit.js\":93,\"./internal/withoutIndex.js\":101,\"./internal/wrapAsync.js\":102}],89:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachLimit = require('./eachLimit.js');\n\nvar _eachLimit2 = _interopRequireDefault(_eachLimit);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n * in series and therefore the iteratee functions will complete in order.\n\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachSeries(coll, iteratee, callback) {\n  return (0, _eachLimit2.default)(coll, 1, iteratee, callback);\n}\nexports.default = (0, _awaitify2.default)(eachSeries, 3);\nmodule.exports = exports['default'];\n},{\"./eachLimit.js\":88,\"./internal/awaitify.js\":91}],90:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncEachOfLimit;\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return;\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({ value, done: iterDone }) => {\n            //console.log('got value', value)\n            if (canceled || done) return;\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return;\n        if (err) return handleError(err);\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return;\n        }\n\n        if (result === _breakLoop2.default || done && running <= 0) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return;\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\nmodule.exports = exports['default'];\n},{\"./breakLoop.js\":92}],91:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = awaitify;\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify(asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined');\n    function awaitable(...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args);\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err);\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        });\n    }\n\n    return awaitable;\n}\nmodule.exports = exports['default'];\n},{}],92:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\nexports.default = breakLoop;\nmodule.exports = exports[\"default\"];\n},{}],93:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator.js');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./wrapAsync.js');\n\nvar _asyncEachOfLimit = require('./asyncEachOfLimit.js');\n\nvar _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = limit => {\n    return (obj, iteratee, callback) => {\n        callback = (0, _once2.default)(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1');\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);\n        }\n        if ((0, _wrapAsync.isAsyncIterable)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return;\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (err === false) {\n                done = true;\n                canceled = true;\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\nmodule.exports = exports['default'];\n},{\"./asyncEachOfLimit.js\":90,\"./breakLoop.js\":92,\"./iterator.js\":97,\"./once.js\":98,\"./onlyOnce.js\":99,\"./wrapAsync.js\":102}],94:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n};\n\nmodule.exports = exports[\"default\"];\n},{}],95:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function (...args /*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n};\n\nmodule.exports = exports[\"default\"];\n},{}],96:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isArrayLike;\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\nmodule.exports = exports['default'];\n},{}],97:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = createIterator;\n\nvar _isArrayLike = require('./isArrayLike.js');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator.js');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? { value: obj[key], key } : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];\n},{\"./getIterator.js\":94,\"./isArrayLike.js\":96}],98:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    function wrapper(...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n}\nmodule.exports = exports[\"default\"];\n},{}],99:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\nmodule.exports = exports[\"default\"];\n},{}],100:[function(require,module,exports){\n(function (process,setImmediate){(function (){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fallback = fallback;\nexports.wrap = wrap;\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);\n}).call(this)}).call(this,require('_process'),require(\"timers\").setImmediate)\n\n},{\"_process\":121,\"timers\":165}],101:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _withoutIndex;\nfunction _withoutIndex(iteratee) {\n    return (value, index, callback) => iteratee(value, callback);\n}\nmodule.exports = exports[\"default\"];\n},{}],102:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify.js');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function');\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;\nexports.isAsyncGenerator = isAsyncGenerator;\nexports.isAsyncIterable = isAsyncIterable;\n},{\"../asyncify.js\":87}],103:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall(tasks, callback) {\n    callback = (0, _once2.default)(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        task(...args, (0, _onlyOnce2.default)(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return;\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nexports.default = (0, _awaitify2.default)(waterfall);\nmodule.exports = exports['default'];\n},{\"./internal/awaitify.js\":91,\"./internal/once.js\":98,\"./internal/onlyOnce.js\":99,\"./internal/wrapAsync.js\":102}],104:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Load the schema and metadata from a package file\n*\n* @method loadFromPackageFile\n* @return {Object} Returns a new Meadow, or false if it failed\n*/\nvar loadFromPackageFile = function(pMeadow, pPackage)\n{\n\t// Use the package loader to grab the configuration objects and clone a new Meadow.\n\tvar tmpPackage = false;\n\ttry\n\t{\n\t\ttmpPackage = require(pPackage);\n\t}\n\tcatch(pError)\n\t{\n\t\tpMeadow.fable.log.error('Error loading Fable package', {Package:pPackage});\n\t\treturn false;\n\t}\n\n\t// Spool up a new Meadow object\n\tvar tmpNewMeadow = pMeadow.new(pMeadow.fable);\n\n\t// Safely set the parameters\n\tif (typeof(tmpPackage.Scope) === 'string')\n\t{\n\t\ttmpNewMeadow.setScope(tmpPackage.Scope);\n\t}\n\t\n\tif (typeof(tmpPackage.Domain) === 'string')\n\t{\n\t\ttmpNewMeadow.setDomain(tmpPackage.Domain);\n\t}\n\n\tif (typeof(tmpPackage.DefaultIdentifier) === 'string')\n\t{\n\t\ttmpNewMeadow.setDefaultIdentifier(tmpPackage.DefaultIdentifier);\n\t}\n\tif (Array.isArray(tmpPackage.Schema))\n\t{\n\t\ttmpNewMeadow.setSchema(tmpPackage.Schema);\n\t}\n\tif (typeof(tmpPackage.JsonSchema) === 'object')\n\t{\n\t\ttmpNewMeadow.setJsonSchema(tmpPackage.JsonSchema);\n\t}\n\tif (typeof(tmpPackage.DefaultObject) === 'object')\n\t{\n\t\ttmpNewMeadow.setDefault(tmpPackage.DefaultObject);\n\t}\n\n\tif (typeof(tmpPackage.Authorization) === 'object')\n\t{\n\t\ttmpNewMeadow.setAuthorizer(tmpPackage.Authorization);\n\t}\n\n\treturn tmpNewMeadow;\n};\n\nmodule.exports = loadFromPackageFile;\n},{}],105:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Load the schema and metadata from a package object\n*\n* @method loadFromPackageObject\n* @return {Object} Returns a new Meadow, or false if it failed\n*/\nvar loadFromPackageObject = function(pMeadow, pPackage)\n{\n\t// Use the package loader to grab the configuration objects and clone a new Meadow.\n\tvar tmpPackage = (typeof(pPackage) == 'object') ? pPackage : {};\n\n\tif (!pPackage.hasOwnProperty('Scope'))\n\t{\n\t\tpMeadow.fable.log.error('Error loading Fable package -- scope not defined.', {Package:pPackage});\n\t}\n\n\t// Spool up a new Meadow object\n\tvar tmpNewMeadow = pMeadow.new(pMeadow.fable);\n\n\t// Safely set the parameters\n\tif (typeof(tmpPackage.Scope) === 'string')\n\t{\n\t\ttmpNewMeadow.setScope(tmpPackage.Scope);\n\t}\n\t\n\tif (typeof(tmpPackage.Domain) === 'string')\n\t{\n\t\ttmpNewMeadow.setDomain(tmpPackage.Domain);\n\t}\n\n\tif (typeof(tmpPackage.DefaultIdentifier) === 'string')\n\t{\n\t\ttmpNewMeadow.setDefaultIdentifier(tmpPackage.DefaultIdentifier);\n\t}\n\tif (Array.isArray(tmpPackage.Schema))\n\t{\n\t\ttmpNewMeadow.setSchema(tmpPackage.Schema);\n\t}\n\tif (typeof(tmpPackage.JsonSchema) === 'object')\n\t{\n\t\ttmpNewMeadow.setJsonSchema(tmpPackage.JsonSchema);\n\t}\n\tif (typeof(tmpPackage.DefaultObject) === 'object')\n\t{\n\t\ttmpNewMeadow.setDefault(tmpPackage.DefaultObject);\n\t}\n\n\tif (typeof(tmpPackage.Authorization) === 'object')\n\t{\n\t\ttmpNewMeadow.setAuthorizer(tmpPackage.Authorization);\n\t}\n\n\treturn tmpNewMeadow;\n};\n\nmodule.exports = loadFromPackageObject;\n},{}],106:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libFS = require('fs');\n\n/**\n* ### Meadow Raw Query Library\n*\n* This library loads and stores raw queries for FoxHound to use.\n* You can overload the default query that is built for each of\n* the following query archetypes:\n*\n* `Create`, `Read`, `Reads`, `Update`, `Delete`, `Count`\n*\n* You can also load other custom queries and give them an\n* arbitrary name.\n*\n* @class MeadowRawQuery\n*/\nvar MeadowRawQuery = function()\n{\n\tfunction createNew(pMeadow)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pMeadow) !== 'object') || !('fable' in pMeadow))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Meadow = pMeadow;\n\n\t\tvar _Queries = {};\n\n\n\t\t/**\n\t\t* Load a Custom Query from a File\n\t\t*\n\t\t* @method doLoadQuery\n\t\t*/\n\t\tfunction doLoadQuery(pQueryTag, pFileName, fCallBack)\n\t\t{\n\t\t\tvar tmpCallBack = (typeof(fCallBack) === 'function') ? fCallBack : function() {};\n\n\t\t\tlibFS.readFile(pFileName, 'utf8',\n\t\t\t\tfunction (pError, pData)\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\t_Meadow.fable.log.error('Problem loading custom query file.', {QueryTag:pQueryTag, FileName:pFileName, Error:pError});\n\t\t\t\t\t\t// There is some debate whether we should leave the queries entry unset or set it to empty so nothing happens.\n\t\t\t\t\t\t// If this were to set the query to `false` instead of `''`, FoxHound would be used to generate a query.\n\t\t\t\t\t\tdoSetQuery(pQueryTag, '');\n\t\t\t\t\t\ttmpCallBack(false);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_Meadow.fable.log.trace('Loaded custom query file.', {QueryTag:pQueryTag, FileName:pFileName});\n\t\t\t\t\t\tdoSetQuery(pQueryTag, pData);\n\t\t\t\t\t\ttmpCallBack(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\treturn _Meadow;\n\t\t}\n\n\n\t\t/**\n\t\t* Sets a Custom Query from a String\n\t\t*\n\t\t* @method doSetQuery\n\t\t*/\n\t\tfunction doSetQuery(pQueryTag, pQueryString)\n\t\t{\n\t\t\t_Queries[pQueryTag] = pQueryString;\n\t\t\treturn _Meadow;\n\t\t}\n\n\n\t\t/**\n\t\t* Returns a Custom Query if one has been set for this tag\n\t\t*\n\t\t* @method doGetQuery\n\t\t*/\n\t\tfunction doGetQuery(pQueryTag)\n\t\t{\n\t\t\tif (_Queries.hasOwnProperty(pQueryTag))\n\t\t\t{\n\t\t\t\treturn _Queries[pQueryTag];\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\n\t\t/**\n\t\t* Check if a Custom Query exists\n\t\t*\n\t\t* @method doCheckQuery\n\t\t*/\n\t\tfunction doCheckQuery(pQueryTag)\n\t\t{\n\t\t\treturn _Queries.hasOwnProperty(pQueryTag);\n\t\t}\n\n\t\tvar tmpNewMeadowRawQuery = (\n\t\t{\n\t\t\tloadQuery: doLoadQuery,\n\t\t\tsetQuery: doSetQuery,\n\n\t\t\tcheckQuery: doCheckQuery,\n\t\t\tgetQuery: doGetQuery,\n\n\t\t\tnew: createNew\n\t\t});\n\n\t\treturn tmpNewMeadowRawQuery;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowRawQuery();\n\n},{\"fs\":21}],107:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libValidator = require('is-my-json-valid');\n\n/**\n* @class MeadowSchema\n*/\nvar MeadowSchema = function()\n{\n\tfunction createNew(pOriginalJsonSchema, pOriginalSchema)\n\t{\n\t\t/* ^ An Example Meadow Schema Object\n\t\t    [\n\t\t    \t{ \"Column\": \"IDAnimal\", \"Type\":\"AutoIdentity\" },\n\t\t    \t{ \"Column\": \"GUIDAnimal\", \"Type\":\"AutoGUID\" },\n\t\t    \t{ \"Column\": \"Created\", \"Type\":\"CreateDate\" },\n\t\t    \t{ \"Column\": \"CreatingIDUser\", \"Type\":\"CreateIDUser\" },\n\t\t    \t{ \"Column\": \"Modified\", \"Type\":\"UpdateDate\" },\n\t\t    \t{ \"Column\": \"ModifyingIDUser\", \"Type\":\"UpdateIDUser\" },\n\t\t    \t{ \"Column\": \"Deleted\", \"Type\":\"Deleted\" },\n\t\t    \t{ \"Column\": \"DeletingIDUser\", \"Type\":\"DeleteIDUser\" },\n\t\t    \t{ \"Column\": \"DeleteDate\", \"Type\":\"DeleteDate\" }\n\t\t    ]\n\t\t*/\n\t\t/* #### The Meadow Schema\n\t\t *\n\t\t * Meadow uses this description object to create queries, broker data and generate interfaces.\n\t\t */\n\t\tvar _Schema = false;\n\n\t\t/* ^ An Example JSONSchema Object:\n\t\t    \t{\n\t\t    \t\t\"$schema\": \"http://json-schema.org/draft-04/schema#\",\n\t\t    \t\t\"title\": \"Product\",\n\t\t    \t\t\"description\": \"A product from Acme's catalog\",\n\t\t    \t\t\"type\": \"object\",\n\t\t    \t\t\"properties\": {\n\t\t    \t\t\t\"id\": {\n\t\t    \t\t\t\t\"description\": \"The unique identifier for a product\",\n\t\t    \t\t\t\t\"type\": \"integer\"\n\t\t    \t\t\t},\n\t\t    \t\t\t\"name\": {\n\t\t    \t\t\t\t\"description\": \"Name of the product\",\n\t\t    \t\t\t\t\"type\": \"string\"\n\t\t    \t\t\t},\n\t\t    \t\t\t\"price\": {\n\t\t    \t\t\t\t\"type\": \"number\",\n\t\t    \t\t\t\t\"minimum\": 0,\n\t\t    \t\t\t\t\"exclusiveMinimum\": true\n\t\t    \t\t\t},\n\t\t    \t\t\t\"tags\": {\n\t\t    \t\t\t\t\"type\": \"array\",\n\t\t    \t\t\t\t\"items\": {\n\t\t    \t\t\t\t\t\"type\": \"string\"\n\t\t    \t\t\t\t},\n\t\t    \t\t\t\t\"minItems\": 1,\n\t\t    \t\t\t\t\"uniqueItems\": true\n\t\t    \t\t\t}\n\t\t    \t\t},\n\t\t    \t\t\"required\": [\"id\", \"name\", \"price\"]\n\t\t    \t}\n\t\t*/\n\t\t/* #### A JSONSchema Description\n\t\t *\n\t\t * http://json-schema.org/examples.html\n\t\t *\n\t\t * http://json-schema.org/latest/json-schema-core.html\n\t\t */\n\t\tvar _JsonSchema = false;\n\n\t\t/* #### An \"empty\" ORM object\n\t\t * This is the basis for being filled out by the marshalling code.\n\t\t */\n\t\tvar _Default = false;\n\n\t\t// The cached validator, which uses the JSONSchema\n\t\tvar _Validate = false;\n\n\t\t// The authorizers available to this meadow object\n\t\tvar _Authorizers = {};\n\n\n\t\t/**\n\t\t* Set the Meadow schema\n\t\t*\n\t\t* Our schemas are really instructions for *what* to do *when*.  We track:\n\t\t*   - Column\n\t\t*   - Type _(e.g. AutoIdentity, AutoGUID, CreateDate, CreateIDUser, UpdateDate, UpdateIDUser, DeleteDate, Deleted, DeleteIDUser)_\n\t\t*   - Optionally Special Instractions\n\t\t*\n\t\t* @method setSchema\n\t\t*/\n\t\tvar setSchema = function(pSchema)\n\t\t{\n\t\t\t_Schema = (typeof(pSchema) === 'object') ? pSchema : (\n\t\t\t{\n\t\t\t\ttitle: 'Unknown',\n\t\t\t\ttype: 'object',\n\t\t\t\trequired: []\n\t\t\t});\n\t\t};\n\t\tsetSchema(pOriginalSchema);\n\n\t\t/**\n\t\t* Set the JSONSchema\n\t\t*\n\t\t* @method setJsonSchema\n\t\t*/\n\t\tvar setJsonSchema = function(pJsonSchema)\n\t\t{\n\t\t\t_JsonSchema = (typeof(pJsonSchema) === 'object') ? pJsonSchema : (\n\t\t\t{\n\t\t\t\ttitle: 'Unknown',\n\t\t\t\ttype: 'object',\n\t\t\t\trequired: []\n\t\t\t});\n\t\t\t_Validate = libValidator(_JsonSchema, { greedy:true, verbose:true });\n\t\t};\n\t\tsetJsonSchema(pOriginalJsonSchema);\n\n\t\t/**\n\t\t* Set the Default ORM object\n\t\t*\n\t\t* @method setDefault\n\t\t*/\n\t\tvar setDefault = function(pDefault)\n\t\t{\n\t\t\t_Default = (typeof(pDefault) === 'object') ? pDefault : {};\n\t\t};\n\t\tsetDefault();\n\n\t\t/**\n\t\t* Set the authorizer set\n\t\t*\n\t\t* @method setAuthorizer\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setAuthorizer = function(pAuthorizer)\n\t\t{\n\t\t\t_Authorizers = (typeof(pAuthorizer) === 'object') ? pAuthorizer : {};\n\t\t};\n\n\t\t/**\n\t\t* Validate an object against the current schema\n\t\t*\n\t\t* @method validateObject\n\t\t*/\n\t\tvar validateObject = function(pObject)\n\t\t{\n\t\t\tvar tmpValidation = { Valid:_Validate(pObject) };\n\n\t\t\t// Stuff the errors in if it is invalid\n\t\t\tif (!tmpValidation.Valid)\n\t\t\t{\n\t\t\t\ttmpValidation.Errors = _Validate.errors;\n\t\t\t}\n\n\t\t\treturn tmpValidation;\n\t\t};\n\n\n\t\tvar tmpNewMeadowSchemaObject = (\n\t\t{\n\t\t\tsetSchema: setSchema,\n\t\t\tsetJsonSchema: setJsonSchema,\n\t\t\tsetDefault: setDefault,\n\t\t\tsetAuthorizer: setAuthorizer,\n\t\t\tvalidateObject: validateObject,\n\n\t\t\tnew: createNew\n\t\t});\n\n\t\t/**\n\t\t * The Meadow Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'schema',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\t/**\n\t\t * The JsonSchema\n\t\t *\n\t\t * @property jsonSchema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'jsonSchema',\n\t\t\t{\n\t\t\t\tget: function() { return _JsonSchema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\t/**\n\t\t * Default Object\n\t\t *\n\t\t * @property defaultObject\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'defaultObject',\n\t\t\t{\n\t\t\t\tget: function() { return _Default; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\t/**\n\t\t * Authorizer\n\t\t *\n\t\t * @property defaultObject\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'authorizer',\n\t\t\t{\n\t\t\t\tget: function() { return _Authorizers; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\treturn tmpNewMeadowSchemaObject;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowSchema();\n\n},{\"is-my-json-valid\":53}],108:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libFoxHound = require('foxhound');\n\n/**\n* Meadow Data Broker Library\n*\n* @class Meadow\n*/\nvar Meadow = function()\n{\n\tfunction createNew(pFable, pScope, pJsonSchema, pSchema)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pFable) !== 'object') || !('fable' in pFable))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\t// Make sure there is a valid data broker set\n\t\t_Fable.settingsManager.fill({MeadowProvider:'None'});\n\n\t\tvar _IDUser = 0;\n\n\t\t// The scope of this broker.\n\t\tvar _Scope = (typeof(pScope) === 'string') ? pScope : 'Unknown';\n\t\tvar _Domain = 'Default';\n\n\t\t// The schema for this broker\n\t\tvar _Schema = require('./Meadow-Schema.js').new(pJsonSchema, pSchema);\n\t\t// The query for this broker\n\t\tvar _Query = libFoxHound.new(_Fable).setScope(_Scope);\n\t\t// The custom query loader\n\t\tvar _RawQueries = require('./Meadow-RawQuery.js').new(_Fable);\n\n\t\t// The core behaviors.. abstracted into their own modules to encapsulate complexity\n\t\tvar _CreateBehavior = require('./behaviors/Meadow-Create.js');\n\t\tvar _ReadBehavior = require('./behaviors/Meadow-Read.js');\n\t\tvar _ReadsBehavior = require('./behaviors/Meadow-Reads.js');\n\t\tvar _UpdateBehavior = require('./behaviors/Meadow-Update.js');\n\t\tvar _DeleteBehavior = require('./behaviors/Meadow-Delete.js');\n\t\tvar _UndeleteBehavior = require('./behaviors/Meadow-Undelete.js');\n\t\tvar _CountBehavior = require('./behaviors/Meadow-Count.js');\n\n\t\t// The data provider\n\t\tvar _Provider = false;\n\t\tvar _ProviderName = false;\n\n\t\t// The default identifier for this broker.\n\t\t// This is what is used for the automated endpoint queries\n\t\t// For example the 198 in GET http://myapi.com/Widget/198\n\t\t//\n\t\t// Our development model prefers IDWidget as the column name for the default identifier.\n\t\tvar _DefaultIdentifier = 'ID'+_Scope;\n\t\tvar _DefaultGUIdentifier = 'GUID'+_Scope;\n\n\n\t\t/**\n\t\t * Load a Meadow Package JSON, create a Meadow object from it.\n\t\t */\n\t\tvar _MeadowPackageLoader = require('./Meadow-PackageFileLoader.js');\n\t\tvar loadFromPackage = function(pPackage)\n\t\t{\n\t\t\treturn _MeadowPackageLoader(this, pPackage);\n\t\t};\n\n\t\t/**\n\t\t * Load a Meadow Package JSON from file, create a Meadow object from it.\n\t\t */\n\t\tvar _MeadowPackageObjectLoader = require('./Meadow-PackageObjectLoader.js');\n\t\tvar loadFromPackageObject = function(pPackage)\n\t\t{\n\t\t\treturn _MeadowPackageObjectLoader(this, pPackage);\n\t\t};\n\n\t\t/**\n\t\t* Pass relevant state into the provider\n\t\t*\n\t\t* @method updateProviderState\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar updateProviderState = ()=>\n\t\t{\n\t\t\tif (typeof(_Provider.setSchema) === 'function')\n\t\t\t{\n\t\t\t\t_Provider.setSchema(_Scope, _Schema.schema, _DefaultIdentifier, _DefaultGUIdentifier);\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the scope\n\t\t*\n\t\t* @method setScope\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar setScope = function(pScope)\n\t\t{\n\t\t\t_Scope = pScope;\n\t\t\t_Query.setScope(pScope);\n\t\t\tupdateProviderState();\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the user ID for inserts and updates\n\t\t*\n\t\t* @method setIDUser\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar setIDUser = function(pIDUser)\n\t\t{\n\t\t\t_IDUser = pIDUser;\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the Provider for Query execution.\n\t\t*\n\t\t* This function expects a string, case sensitive, which matches the\n\t\t* provider filename\n\t\t*\n\t\t* @method setProvider\n\t\t* @param {String} pProviderName The provider for query generation.\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar _PROVIDERS = (\n\t\t{\n\t\t\t'ALASQL': require(`./providers/Meadow-Provider-ALASQL.js`),\n\t\t\t'MeadowEndpoints': require(`./providers/Meadow-Provider-MeadowEndpoints.js`),\n\t\t\t'MySQL': require(`./providers/Meadow-Provider-MySQL.js`),\n\t\t\t'None': require(`./providers/Meadow-Provider-None.js`),\n\t\t});\n\t\tvar setProvider = function(pProviderName)\n\t\t{\n\t\t\tif (typeof(pProviderName) !== 'string')\n\t\t\t{\n\t\t\t\tpProviderName = 'None';\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_Provider = _PROVIDERS[pProviderName].new(_Fable);\n\t\t\t\t// Give the provider access to the schema object\n\t\t\t\tupdateProviderState();\n\n\t\t\t\t_ProviderName = pProviderName;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Provider not set - require load problem', {InvalidProvider:pProviderName, error:pError});\n\t\t\t\tsetProvider('None');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\t\tsetProvider(_Fable.settings.MeadowProvider);\n\n\t\t/**\n\t\t* Set the schema to be something else\n\t\t*\n\t\t* @method setSchema\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setSchema = function(pSchema)\n\t\t{\n\t\t\t_Schema.setSchema(pSchema);\n\t\t\tupdateProviderState();\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the Jsonschema to be something else\n\t\t*\n\t\t* @method setJsonSchema\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setJsonSchema = function(pJsonSchema)\n\t\t{\n\t\t\t_Schema.setJsonSchema(pJsonSchema);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the default object to be something else\n\t\t*\n\t\t* @method setDefault\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setDefault = function(pDefault)\n\t\t{\n\t\t\t_Schema.setDefault(pDefault);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the authorizer set\n\t\t*\n\t\t* @method setAuthorizer\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setAuthorizer = function(pAuthorizer)\n\t\t{\n\t\t\t_Schema.setAuthorizer(pAuthorizer);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the domain\n\t\t*\n\t\t* @method setDomain\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setDomain = function(pDomain)\n\t\t{\n\t\t\t_Domain = pDomain;\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the default identifier\n\t\t*\n\t\t* @method setDefaultIdentifier\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setDefaultIdentifier = function(pDefaultIdentifier)\n\t\t{\n\t\t\t_DefaultIdentifier = pDefaultIdentifier;\n\t\t\t_DefaultGUIdentifier = 'GU' + pDefaultIdentifier;\n\t\t\tupdateProviderState();\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t * Create a record\n\t\t */\n\t\tvar doCreate = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _CreateBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Read a record\n\t\t */\n\t\tvar doRead = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _ReadBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Read multiple records\n\t\t */\n\t\tvar doReads = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _ReadsBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\n\t\t/**\n\t\t * Update a record\n\t\t */\n\t\tvar doUpdate = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _UpdateBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\n\t\t/**\n\t\t * Delete a record\n\t\t */\n\t\tvar doDelete = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _DeleteBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Undelete a record\n\t\t */\n\t\tvar doUndelete = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _UndeleteBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Count multiple records\n\t\t */\n\t\tvar doCount = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _CountBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Get the role name for an index\n\t\t */\n\t\tlet _RoleNames;\n\t\tif (Array.isArray(_Fable.settings.MeadowRoleNames))\n\t\t{\n\t\t\t_RoleNames = _Fable.settings.MeadowRoleNames;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_RoleNames =\n\t\t\t[\n\t\t\t\t'Unauthenticated',\n\t\t\t\t'User',\n\t\t\t\t'Manager',\n\t\t\t\t'Director',\n\t\t\t\t'Executive',\n\t\t\t\t'Administrator',\n\t\t\t];\n\t\t}\n\t\tvar getRoleName = function(pRoleIndex)\n\t\t{\n\t\t\tif (pRoleIndex < 0 || pRoleIndex >= _RoleNames.length)\n\t\t\t{\n\t\t\t\treturn 'Unauthenticated';\n\t\t\t}\n\n\t\t\treturn _RoleNames[pRoleIndex];\n\t\t};\n\n\t\t/**\n\t\t * Take the stored representation of our object and stuff the proper values\n\t\t * into our record, translating where necessary.\n\t\t */\n\t\tvar marshalRecordFromSourceToObject = function(pRecord)\n\t\t{\n\t\t\t// Create an object from the default schema object\n\t\t\tvar tmpNewObject = _Fable.Utility.extend({}, _Schema.defaultObject);\n\t\t\t// Now marshal the values from pRecord into tmpNewObject, based on schema\n\t\t\t_Provider.marshalRecordFromSourceToObject(tmpNewObject, pRecord, _Schema.schema);\n\t\t\t// This turns on magical validation\n\t\t\t//_Fable.log.trace('Validation', {Value:tmpNewObject, Validation:_Schema.validateObject(tmpNewObject)})\n\t\t\treturn tmpNewObject;\n\t\t};\n\n\t\t/**\n\t\t * Method to log slow queries in a consistent pattern\n\t\t */\n\t\tvar logSlowQuery = function(pProfileTime, pQuery)\n\t\t{\n\t\t\tvar tmpQuery = pQuery.query || {body: '', parameters: {}};\n\t\t\tvar tmpFullQuery = tmpQuery.body;\n\t\t\tif (tmpQuery.parameters.length)\n\t\t\t{\n\t\t\t\tfor (var tmpKey in tmpQuery.parameters)\n\t\t\t\t{\n\t\t\t\t\ttmpFullQuery = tmpFullQuery.replace(':' + tmpKey, tmpQuery.parameters[tmpKey]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_Fable.log.warn('Slow Read query took ' + pProfileTime + 'ms',\n\t\t\t\t{\n\t\t\t\t\tProvider: _ProviderName,\n\t\t\t\t\tQuery:\n\t\t\t\t\t{\n\t\t\t\t\t\tBody: tmpQuery.body,\n\t\t\t\t\t\tParameters: tmpQuery.parameters,\n\t\t\t\t\t\tFullQuery: tmpFullQuery\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t* Container Object for our Factory Pattern\n\t\t*/\n\t\tvar tmpNewMeadowObject = (\n\t\t{\n\t\t\tdoCreate: doCreate,\n\t\t\tdoRead: doRead,\n\t\t\tdoReads: doReads,\n\t\t\tdoUpdate: doUpdate,\n\t\t\tdoDelete: doDelete,\n\t\t\tdoUndelete: doUndelete,\n\t\t\tdoCount: doCount,\n\n\t\t\tvalidateObject: _Schema.validateObject,\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tsetProvider: setProvider,\n\t\t\tsetIDUser: setIDUser,\n\n\t\t\tloadFromPackage: loadFromPackage,\n\t\t\tloadFromPackageObject: loadFromPackageObject,\n\t\t\tsetScope: setScope,\n\t\t\tsetDomain: setDomain,\n\t\t\tsetSchema: setSchema,\n\t\t\tsetJsonSchema: setJsonSchema,\n\t\t\tsetDefault: setDefault,\n\t\t\tsetDefaultIdentifier: setDefaultIdentifier,\n\t\t\tsetAuthorizer: setAuthorizer,\n\n\t\t\tgetRoleName: getRoleName,\n\n\t\t\tlogSlowQuery: logSlowQuery,\n\n\t\t\t// Factory\n\t\t\tnew: createNew\n\t\t});\n\n\t\t/**\n\t\t * Entity Scope -- usually the name of the entity it represents\n\t\t *\n\t\t * @property scope\n\t\t * @type string\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'scope',\n\t\t\t{\n\t\t\t\tget: function() { return _Scope; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Entity Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'schema',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema.schema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Entity Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'schemaFull',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Default Identifier\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'defaultIdentifier',\n\t\t\t{\n\t\t\t\tget: function() { return _DefaultIdentifier; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Default GUIdentifier\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'defaultGUIdentifier',\n\t\t\t{\n\t\t\t\tget: function() { return _DefaultGUIdentifier; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Json Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'jsonSchema',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema.jsonSchema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * User Identifier\n\t\t *\n\t\t * Used to stamp user identity into Create/Update operations.\n\t\t *\n\t\t * @property userIdentifier\n\t\t * @type string\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'userIdentifier',\n\t\t\t{\n\t\t\t\tget: function() { return _IDUser; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Query (FoxHound) object\n\t\t *\n\t\t * This always returns a cloned query, so it's safe to get queries with a simple:\n\t\t *   var tmpQuery = libSomeFableObject.query;\n\t\t *\n\t\t * and not expect leakage of basic (cap, begin, filter, dataelements) cloned values.\n\t\t *\n\t\t * @property query\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'query',\n\t\t\t{\n\t\t\t\tget: function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmpQuery = _Query.clone();\n\t\t\t\t\t\t\t// Set the default schema\n\t\t\t\t\t\t\ttmpQuery.query.schema = _Schema.schema;\n\t\t\t\t\t\t\treturn tmpQuery;\n\t\t\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Raw Queries\n\t\t *\n\t\t * @property rawQueries\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'rawQueries',\n\t\t\t{\n\t\t\t\tget: function() { return _RawQueries; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Provider\n\t\t *\n\t\t * @property provider\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'provider',\n\t\t\t{\n\t\t\t\tget: function() { return _Provider; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Provider Name\n\t\t *\n\t\t * @property providerName\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'providerName',\n\t\t\t{\n\t\t\t\tget: function() { return _ProviderName; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t// addServices removed in fable 2.x\n\t\tif (typeof(_Fable.addServices) === 'function')\n\t\t{\n\t\t\t_Fable.addServices(tmpNewMeadowObject);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// bring over addServices implementation from Fable 1.x for backward compatibility\n\t\t\tObject.defineProperty(tmpNewMeadowObject, 'fable',\n\t\t\t{\n\t\t\t\tget: function() { return _Fable; },\n\t\t\t\tenumerable: false,\n\t\t\t});\n\n\t\t\tObject.defineProperty(tmpNewMeadowObject, 'settings',\n\t\t\t{\n\t\t\t\tget: function() { return _Fable.settings; },\n\t\t\t\tenumerable: false,\n\t\t\t});\n\n\t\t\tObject.defineProperty(tmpNewMeadowObject, 'log',\n\t\t\t{\n\t\t\t\tget: function() { return _Fable.log; },\n\t\t\t\tenumerable: false,\n\t\t\t});\n\t\t}\n\n\t\treturn tmpNewMeadowObject;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new Meadow();\n\n},{\"./Meadow-PackageFileLoader.js\":104,\"./Meadow-PackageObjectLoader.js\":105,\"./Meadow-RawQuery.js\":106,\"./Meadow-Schema.js\":107,\"./behaviors/Meadow-Count.js\":109,\"./behaviors/Meadow-Create.js\":110,\"./behaviors/Meadow-Delete.js\":111,\"./behaviors/Meadow-Read.js\":112,\"./behaviors/Meadow-Reads.js\":113,\"./behaviors/Meadow-Undelete.js\":114,\"./behaviors/Meadow-Update.js\":115,\"./providers/Meadow-Provider-ALASQL.js\":116,\"./providers/Meadow-Provider-MeadowEndpoints.js\":117,\"./providers/Meadow-Provider-MySQL.js\":118,\"./providers/Meadow-Provider-None.js\":119,\"foxhound\":28}],109:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Count multiple records\n*\n* @function meadowBehaviorCount\n*/\nvar meadowBehaviorCount = function(pMeadow, pQuery, fCallBack)\n{\n\tvar tmpProfileStart = new Date(); //for profiling query time\n\n\t// Count the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Get the record countfrom the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Count'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Count');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Count(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Validate the resulting value\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// Check if query time exceeded threshold in settings. Log if slow.\n\t\t\t\tvar tmpProfileTime = new Date().getTime() - tmpProfileStart.getTime();\n\t\t\t\tif (tmpProfileTime > (pMeadow.fable.settings['QueryThresholdWarnTime'] || 200))\n\t\t\t\t{\n\t\t\t\t\tpMeadow.logSlowQuery(tmpProfileTime, pQuery);\n\t\t\t\t}\n\n\t\t\t\tif (typeof(pQuery.parameters.result.value) !== 'number')\n\t\t\t\t{\n\t\t\t\t\t// The return value is a number.. something is wrong.\n\t\t\t\t\treturn fStageComplete('Count did not return valid results.', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, pQuery.result.value);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pCount)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the count waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pCount);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorCount;\n},{\"async/waterfall\":103}],110:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Create\n*\n* @function meadowBehaviorCreate\n*/\nvar meadowBehaviorCreate = function(pMeadow, pQuery, fCallBack)\n{\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 0: If GUID is specified, make sure the record does not already exist\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\t// Make sure the user submitted a record\n\t\t\t\tif (!pQuery.query.records)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('No record submitted', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tif (pQuery.query.records[0][pMeadow.defaultGUIdentifier] &&\n\t\t\t\t\tpQuery.query.records[0][pMeadow.defaultGUIdentifier].length >= 5) //see Foxhound mysql build create query: GUID min len must be 5\n\t\t\t\t{\n\t\t\t\t\tvar tmpGUIDRecord = pQuery.query.records[0][pMeadow.defaultGUIdentifier];\n\n\t\t\t\t\tvar tmpQueryRead = pQuery.clone().addFilter(pMeadow.defaultGUIdentifier, tmpGUIDRecord)\n\t\t\t\t\t\t\t\t\t\t\t\t .setDisableDeleteTracking(true); //this check is to guarantee uniqueness across the entire table, so always do this\n\n\t\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpQueryRead.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t\t}\n\t\t\t\t\tpMeadow.provider.Read(tmpQueryRead, function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmpError = tmpQueryRead.error;\n\n\t\t\t\t\t\t\tif (!tmpError &&\n\t\t\t\t\t\t\t\ttmpQueryRead.result.value.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpError = 'Record with GUID ' + tmpGUIDRecord + ' already exists!';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (tmpError)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn fStageComplete(tmpError, tmpQueryRead, tmpQueryRead, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete();\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Step 1: Create the record in the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (!pQuery.query.IDUser)\n\t\t\t\t{\n\t\t\t\t\t// The user ID is not already set, set it magically.\n\t\t\t\t\tif (typeof(pQuery.userID) === 'number' && (pQuery.userID % 1) === 0 && pQuery.userID >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pQuery.userID;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pMeadow.userIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Merge in the default record with the passed-in record for completeness\n\t\t\t\tpQuery.query.records[0] = pMeadow.fable.Utility.extend({}, pMeadow.schemaFull.defaultObject, pQuery.query.records[0]);\n\t\t\t\t// Create override is too complex ... punting for now\n\t\t\t\t// if (pMeadow.rawQueries.checkQuery('Create'))\n\t\t\t\t//\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Create');\n\t\t\t\tpMeadow.provider.Create(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Setup a read operation\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// The value is not set (it should be set to the value for our DefaultIdentifier)\n\t\t\t\tif (pQuery.parameters.result.value === false)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('Creation failed', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tvar tmpIDRecord = pQuery.result.value;\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, tmpIDRecord);\n\t\t\t},\n\t\t\t// Step 3: Read the record\n\t\t\tfunction (pQuery, pIDRecord, fStageComplete)\n\t\t\t{\n\t\t\t\tvar tmpQueryRead = pQuery.clone().addFilter(pMeadow.defaultIdentifier, pIDRecord)\n\t\t\t\t\t\t\t\t\t\t\t\t .setDisableDeleteTracking(pQuery.parameters.query.disableDeleteTracking); //if delete tracking is disabled, we need to disable it on this Read operation\n\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t{\n\t\t\t\t\ttmpQueryRead.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(tmpQueryRead, function(){ fStageComplete(tmpQueryRead.result.error, pQuery, tmpQueryRead); });\n\t\t\t},\n\t\t\t// Step 4: Marshal the record into a POJO\n\t\t\tfunction (pQuery, pQueryRead, fStageComplete)\n\t\t\t{\n\t\t\t\t// Ensure there is not at least one record returned\n\t\t\t\tif (pQueryRead.parameters.result.value.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('No record found after create.', pQuery, pQueryRead, false);\n\t\t\t\t}\n\n\t\t\t\tvar tmpRecord = pMeadow.marshalRecordFromSourceToObject(pQueryRead.result.value[0]);\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, pQueryRead, tmpRecord);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pQueryRead, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the create waterfall', {Error:pError, Message: pError.message, Query: pQuery.query, Stack: pError.stack});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pQueryRead, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorCreate;\n},{\"async/waterfall\":103}],111:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Delete a single record\n*\n* @function meadowBehaviorDelete\n*/\nvar meadowBehaviorDelete = function(pMeadow, pQuery, fCallBack)\n{\n\t// TODO: Check if this recordset has implicit delete tracking, branch in this module.\n\t// Delete the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Delete the record\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Delete'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Delete');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Delete(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery, pQuery.result.value); });\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the delete waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorDelete;\n},{\"async/waterfall\":103}],112:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Read a single record\n*\n* @function meadowBehaviorRead\n*/\nvar meadowBehaviorRead = function(pMeadow, pQuery, fCallBack)\n{\n\t// Read the record from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Get the record from the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\t// If there is a Read override query, use it!\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Marshal the record into a POJO\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// Check that a record was returned\n\t\t\t\tif (pQuery.parameters.result.value.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(undefined, pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tvar tmpRecord = pMeadow.marshalRecordFromSourceToObject(pQuery.result.value[0]);\n\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, tmpRecord);\n\t\t\t}\n\t\t],\n\t\t(pError, pQuery, pRecord)=>\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the read waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorRead;\n},{\"async/waterfall\":103}],113:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\nvar libAsyncEach = require('async/eachSeries');\n\n/**\n* Meadow Behavior - Read multiple records\n*\n* @function meadowBehaviorReads\n*/\nvar meadowBehaviorReads = function(pMeadow, pQuery, fCallBack)\n{\n\tvar tmpProfileStart = new Date(); //for profiling query time\n\n\t// Read the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Get the record(s) from the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Reads'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Reads');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Marshal all the records into an array of POJOs\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// Check if query time exceeded threshold in settings. Log if slow.\n\t\t\t\tvar tmpProfileTime = new Date().getTime() - tmpProfileStart.getTime();\n\t\t\t\tif (tmpProfileTime > (pMeadow.fable.settings['QueryThresholdWarnTime'] || 200))\n\t\t\t\t{\n\t\t\t\t\tpMeadow.logSlowQuery(tmpProfileTime, pQuery);\n\t\t\t\t}\n\n\t\t\t\tvar tmpRecords = [];\n\n\t\t\t\tlibAsyncEach\n\t\t\t\t(\n\t\t\t\t\tpQuery.parameters.result.value,\n\t\t\t\t\tfunction(pRow, pQueueCallback)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRecords.push(pMeadow.marshalRecordFromSourceToObject(pRow));\n\t\t\t\t\t\tpQueueCallback();\n\t\t\t\t\t},\n\t\t\t\t\tfunction()\n\t\t\t\t\t{\n\t\t\t\t\t\t// After we've pushed every record into the array in order, complete the waterfall\n\t\t\t\t\t\tfStageComplete(pQuery.result.error, pQuery, tmpRecords);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pRecords)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the read multiple waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecords);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorReads;\n},{\"async/eachSeries\":89,\"async/waterfall\":103}],114:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Undelete a single record\n*\n* @function meadowBehaviorUndelete\n*/\nvar meadowBehaviorUndelete = function(pMeadow, pQuery, fCallBack)\n{\n\t// TODO: Check if this recordset has implicit delete tracking, branch in this module?\n\t// Undelete the record(s) if they were deleted with a bit\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Undelete the record\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Undelete'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Undelete');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Undelete(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery, pQuery.result.value); });\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the undelete waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorUndelete;\n},{\"async/waterfall\":103}],115:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Update a single record\n*\n* @function meadowBehaviorUpdate\n*/\nvar meadowBehaviorUpdate = function(pMeadow, pQuery, fCallBack)\n{\n\t// Update the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Update the record\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (!pQuery.query.IDUser)\n\t\t\t\t{\n\t\t\t\t\t// The user ID is not already set, set it magically.\n\t\t\t\t\tif (typeof(pQuery.userID) === 'number' && (pQuery.userID % 1) === 0 && pQuery.userID >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pQuery.userID;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pMeadow.userIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Make sure the developer submitted a record\n\t\t\t\tif (!pQuery.query.records)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('No record submitted', pQuery, false);\n\t\t\t\t}\n\t\t\t\t// Make sure there is a default identifier\n\t\t\t\tif (!pQuery.query.records[0].hasOwnProperty(pMeadow.defaultIdentifier))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('Automated update missing default identifier', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\t// Now see if there is anything in the schema that is an Update action that isn't in this query\n\t\t\t\tfor (var i = 0; i < pMeadow.schema.length; i++)\n\t\t\t\t{\n\t\t\t\t\tswitch (pMeadow.schema[i].Type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t\t\tpQuery.query.records[0][pMeadow.schema[i].Column] = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Set the update filter\n\t\t\t\tpQuery.addFilter(pMeadow.defaultIdentifier, pQuery.query.records[0][pMeadow.defaultIdentifier]);\n\n\t\t\t\t// Sanity check on update to make sure we don't update EVERY record.\n\t\t\t\tif ((pQuery.parameters.filter === false) || (pQuery.parameters.filter.length < 1))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('Automated update missing filters... aborting!', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\t// Updates are too complex to override for now, punting on this feature.\n\t\t\t\t//if (pMeadow.rawQueries.checkQuery('Update'))\n\t\t\t\t//\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Update');\n\t\t\t\tpMeadow.provider.Update(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Check that the record was updated\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\tif (typeof(pQuery.parameters.result.value) !== 'object')\n\t\t\t\t{\n\t\t\t\t\t// The value is not an object\n\t\t\t\t\treturn fStageComplete('No record updated.', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery);\n\t\t\t},\n\t\t\t// Step 3: Read the record\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// We can clone the query, since it has the criteria for the update in it already (filters survive a clone)\n\t\t\t\tvar tmpQueryRead = pQuery.clone();\n\t\t\t\t// Make sure to load the record with the custom query if necessary.\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t{\n\t\t\t\t\ttmpQueryRead.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(tmpQueryRead, function(){ fStageComplete(tmpQueryRead.result.error, pQuery, tmpQueryRead); });\n\t\t\t},\n\t\t\t// Step 4: Marshal the record into a POJO\n\t\t\tfunction (pQuery, pQueryRead, fStageComplete)\n\t\t\t{\n\t\t\t\tif (pQueryRead.result.value.length === 0)\n\t\t\t\t{\n\t\t\t\t\t//No record found to update\n\t\t\t\t\treturn fStageComplete('No record found to update!', pQueryRead.result, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar tmpRecord = pMeadow.marshalRecordFromSourceToObject(pQueryRead.result.value[0]);\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, pQueryRead, tmpRecord);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pQueryRead, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during Update waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pQueryRead, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorUpdate;\n},{\"async/waterfall\":103}],116:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif (typeof(pFable) !== 'object')\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\tvar _GlobalLogLevel = 0;\n\t\tif (_Fable.settings.ArrayStorage)\n\t\t{\n\t\t\t _GlobalLogLevel = _Fable.settings.ArrayStorage.GlobalLogLevel || 0;\n\t\t}\n\t\t\n\t\tif (!_Fable.hasOwnProperty('ALASQL'))\n\t\t{\n\t\t\t// This is going to be problematic.\n\t\t\t_Fable.log.fatal('Meadow is trying to perform queries without a valid [Fable.ALASQL] object.  See the documentation for how to initialize one.');\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar libALASQL = _Fable.ALASQL;\n\n\t\tvar _Scope = 'Unknown_Meadow_ALASQL_Scope';\n\t\tvar _Schema = {};\n\t\tvar _DefaultIdentifier = 'ID';\n\t\tvar _DefaultGUIDentifier = 'GUID';\n\t\tvar setSchema = (pScope, pSchema, pDefaultIdentifier, pDefaultGUIdentifier) => \n\t\t{\n\t\t\t_Scope = pScope;\n\t\t\t_Schema = pSchema;\n\t\t\t_DefaultIdentifier = pDefaultIdentifier;\n\t\t\t_DefaultGUIDentifier = pDefaultGUIdentifier;\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t// Create a table for this schema on the fly\n\t\t// This is ripped off from https://github.com/stevenvelozo/stricture/blob/master/source/Stricture-Generate-MySQL.js\n\t\tvar createTableDynamically = () =>\n\t\t{\n\t\t\tvar tmpCreateStatement = '';\n\t\t\tvar tmpTable = _Scope;\n\t\t\tvar tmpSchema = _Schema;\n\t\t\t\n\t\t\t// Check if the scope in the query matches the passed-in scope\n\t\t\t// Check if the schema does not contain all columns in the query, and add them if it doesn't.\n\t\t\n\t\t\ttmpCreateStatement += \"CREATE TABLE IF NOT EXISTS\\n    \"+tmpTable+\"\\n\";\n\t\t\tif (tmpSchema.length > 0)\n\t\t\t{\n\t\t\t\ttmpCreateStatement += \"    (\\n\";\n\t\t\t\tfor (var j = 0; j < tmpSchema.length; j++)\n\t\t\t\t{\n\t\t\t\t\t// If we aren't the first element, append a comma.\n\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\ttmpCreateStatement += \",\";\n\t\t\n\t\t\t\t\ttmpCreateStatement += \"\\n\";\n\t\t\t\t\t// Dump out each column......\n\t\t\t\t\tswitch (tmpSchema[j].Type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'AutoIdentity':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` INT UNSIGNED NOT NULL AUTO_INCREMENT\";\n\t\t\t\t\t\t\t_DefaultIdentifier = tmpSchema[j].Column;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'AutoGUID':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` CHAR(36) NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000'\";\n\t\t\t\t\t\t\t_DefaultGUIDentifier = tmpSchema[j].Column;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Boolean':\n\t\t\t\t\t\tcase 'Deleted':\n\t\t\t\t\t\tcase 'CreateIDUser':\n\t\t\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t\tcase 'Numeric':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` INT NOT NULL DEFAULT 0\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Decimal':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` DECIMAL(\"+tmpSchema[j].Size+\")\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'String':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` VARCHAR NOT NULL DEFAULT ''\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Text':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` TEXT\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'CreateDate':\n\t\t\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` DATETIME\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmpCreateStatement += \"\\n    )\";\n\t\t\t}\n\t\t\ttmpCreateStatement += \";\";\n\t\t\t\n\t\t\t_Fable.log.info('Auto Creating ALASQL database `'+tmpTable+'`', {CreateStatement:tmpCreateStatement});\n\n\t\t\tlibALASQL(tmpCreateStatement);\n\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t// Determine if the table has been created in ALASQL.  If not, create it.\n\t\tvar checkDataExists = (pParameters) =>\n\t\t{\n\t\t\t// Check if the scope was passed in via the query and it hasn't been set yet.\n\t\t\tif ((_Scope == 'Unknown_Meadow_ALASQL_Scope') && (typeof(pParameters.scope) !== 'undefined'))\n\t\t\t{\n\t\t\t\t_Scope = pParameters.scope;\n\t\t\t}\n\t\t\t// Per https://github.com/agershun/alasql/wiki/How-to-insert-data-into-the-table\n\t\t\tif (!_Fable.ALASQL.tables.hasOwnProperty(_Scope))\n\t\t\t{\n\t\t\t\t// Create the table with the schema\n\t\t\t\tcreateTableDynamically();\n\t\t\t}\n\t\t};\n\n\t\tvar bindObject = (pObject) =>\n\t\t{\n\t\t\tif (!Array.isArray(pObject))\n\t\t\t\treturn false;\n\n\t\t\t// Check that the database is created in ALASQL first\n\t\t\tcheckDataExists({});\n\t\t\t\n\t\t\tif (!_Fable.ALASQL.tables.hasOwnProperty(_Scope))\n\t\t\t\treturn false;\n\n\t\t\t// Per https://github.com/agershun/alasql/wiki/How-to-insert-data-into-the-table\n\t\t\t_Fable.ALASQL.tables[_Scope].data = pObject;\n\t\t\treturn true;\n\t\t};\n\n\t\t// The Meadow marshaller also passes in the Schema as the third parameter, but this is a blunt function ATM.\n\t\tvar marshalRecordFromSourceToObject = function(pObject, pRecord)\n\t\t{\n\t\t\t// For now, crudely assign everything in pRecord to pObject\n\t\t\t// This is safe in this context, and we don't want to slow down marshalling with millions of hasOwnProperty checks\n\t\t\tfor(var tmpColumn in pRecord)\n\t\t\t{\n\t\t\t\tpObject[tmpColumn] = pRecord[tmpColumn];\n\t\t\t}\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildCreateQuery();\n\n\t\t\t// Compile the ALASQL query\n\t\t\t// Per https://github.com/agershun/alasql/wiki/Compile\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\t// TODO: Test the query before executing\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\t// No iops so this is not async\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\t\t\t\ttmpResult.value = 0;\n\n\t\t\t\tvar tmpQueryResponse = fQuery(pQuery.query.parameters);\n\n\t\t\t\tif (tmpQueryResponse > 0)\n\t\t\t\t{\n\t\t\t\t\t// Check if there is an ALASQL autoval for this insert\n\t\t\t\t\tif (libALASQL.tables[pQuery.parameters.scope].identities[_DefaultIdentifier])\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResult.value = libALASQL.autoval(pQuery.parameters.scope, _DefaultIdentifier);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((pQuery.query.records.length > 0) && (pQuery.query.records[0].hasOwnProperty(_DefaultIdentifier)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResult.value = pQuery.query.records[0][_DefaultIdentifier];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildReadQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value = fQuery(pQuery.query.parameters);\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildUpdateQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value = {affectedRows: fQuery(pQuery.query.parameters)};\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildDeleteQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value =  fQuery(pQuery.query.parameters);\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Undelete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildUndeleteQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value =  fQuery(pQuery.query.parameters);\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildCountQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value =  fQuery(pQuery.query.parameters)[0].RowCount;\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\t\t\n\t\t/**\n\t\t * Construct a new Meadow from a record prototype, optionally passing in records.\n\t\t * \n\t\t * Takes an object\n\t\t * {\n\t\t *\t\tMeadow:          Meadow object to use (required)\n\t\t *      Scope:           \"DATA\" (string)\n\t\t *      ObjectPrototype: {}     (the object to base the schema off of -- REQUIRED)\n\t\t *      AuditData:       true   (boolean -- whether or not to add audit columns)\n\t\t *      Import:          true   (boolean -- whether or not to import them using the DAL)\n\t\t *      Data:            []     (optional array of records, one object each)\n\t\t * }\n\t\t */\n\t\tvar constructFromObject = (pParameters) =>\n\t\t{\n\t\t\tif ((typeof(pParameters) !== 'object') || (typeof(pParameters.Meadow) !== 'object'))\n\t\t\t\treturn false;\n\n\t\t\t// I know there are better ways to do this, but for now I want to keep it very manual\n\t\t\tif (!(typeof(pParameters.Scope) === 'string'))\n\t\t\t\tpParameters.Scope = 'DATA';\n\t\t\tif (!(typeof(pParameters.ObjectPrototype) === 'object'))\n\t\t\t\tpParameters.ObjectPrototype = {};\n\t\t\tif (!(typeof(pParameters.AuditData) === 'boolean'))\n\t\t\t\tpParameters.AuditData = true;\n\t\t\tif (!(typeof(pParameters.Import) === 'boolean'))\n\t\t\t\tpParameters.Import = true;\n\t\t\tif (!Array.isArray(pParameters.Data))\n\t\t\t\tpParameters.Data = [];\n\t\t\t\t\n\t\t\t// Construct a meadow\n\t\t\tvar tmpMeadow = pParameters.Meadow\n\t\t\t\t.new(_Fable, pParameters.Scope)\n\t\t\t\t.setProvider('ALASQL');\n\t\t\t\n\t\t\tvar tmpSchema = [];\n\t\t\tvar tmpDefaultIdentifier;\n\n\t\t\tif (pParameters.AuditData)\n\t\t\t{\n\t\t\t\t// Add the audit fields to the schema\n\t\t\t\ttmpDefaultIdentifier = 'ID'+pParameters.Scope;\n\t\t\t\ttmpSchema.push({ Column: tmpDefaultIdentifier, Type:\"AutoIdentity\" });\n\t\t\t\ttmpSchema.push({ Column: \"GU\"+tmpDefaultIdentifier, Type:\"AutoGUID\" });\n\t\t\t\ttmpSchema.push({ Column: \"CreateDate\", Type:\"CreateDate\" });\n\t\t\t\ttmpSchema.push({ Column: \"CreatingIDUser\", Type:\"CreateIDUser\" });\n\t\t\t\ttmpSchema.push({ Column: \"UpdateDate\", Type:\"UpdateDate\" });\n\t\t\t\ttmpSchema.push({ Column: \"UpdatingIDUser\", Type:\"UpdateIDUser\" });\n\t\t\t\ttmpSchema.push({ Column: \"DeleteDate\", Type:\"DeleteDate\" });\n\t\t\t\ttmpSchema.push({ Column: \"DeletingIDUser\", Type:\"DeleteIDUser\" });\n\t\t\t\ttmpSchema.push({ Column: \"Deleted\", Type:\"Deleted\" });\n\t\t\t}\n\n\t\t\t// Now add the fields from the object in\n\t\t\tfor (var tmpProperty in pParameters.ObjectPrototype)\n\t\t\t{\n\t\t\t\tvar tmpAdded = false;\n\n\t\t\t\t// Add it to the schema\n\t\t\t\tswitch(typeof(pParameters.ObjectPrototype[tmpProperty]))\n\t\t\t\t{\n\t\t\t\t\tcase \"undefined\":\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\t// Do nothing with these types of properties\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\ttmpSchema.push({ Column: tmpProperty, Type:\"Boolean\" });\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Because we can't tell the difference between floating point and not\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttmpSchema.push({ Column: tmpProperty, Type:\"Text\" });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (tmpAdded && (typeof(tmpDefaultIdentifier) === 'undefined'))\n\t\t\t\t\t// Just use the first property of the prototype object as the default identifier\n\t\t\t\t\ttmpDefaultIdentifier = tmpProperty;\n\t\t\t}\n\t\t\ttmpMeadow.setSchema(tmpSchema);\n\n\t\t\tif (typeof(tmpDefaultIdentifier) === 'undefined')\n\t\t\t\ttmpMeadow.setDefaultIdentifier(tmpDefaultIdentifier);\n\n\t\t\t// Now import the data\n\t\t\tif(pParameters.Import)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < pParameters.Data.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMeadow.doCreate(tmpMeadow.query.clone().addRecord(pParameters.Data[j]),\n\t\t\t\t\t\t\tfunction(pError, pQuery, pQueryRead, pRecord)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Maybe log the error?\n\t\t\t\t\t\t\t\t_Fable.log.trace('Auto imported record', pRecord);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just assign the object\n\t\t\t\ttmpMeadow.provider.bindObject(pParameters.Data);\n\t\t\t}\n\t\t\t\n\t\t\treturn tmpMeadow;\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tsetSchema: setSchema,\n\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\t\t\t\n\t\t\tconstructFromObject: constructFromObject,\n\n\t\t\tbindObject:bindObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tUndelete: Undelete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n\n},{}],117:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libSimpleGet = require('simple-get');\n\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif (typeof(pFable) !== 'object')\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\tvar _GlobalLogLevel = 0;\n\n\t\tvar _Dialect = 'MeadowEndpoints';\n\n\t\tvar _Headers = {};\n\t\tvar _Cookies = [];\n\n\t\tvar _EndpointSettings = (_Fable.settings.hasOwnProperty('MeadowEndpoints')) ? JSON.parse(JSON.stringify(_Fable.settings.MedaowEndpoints)) : (\n\t\t\t{\n\t\t\t\tServerProtocol: 'http',\n\t\t\t\tServerAddress: '127.0.0.1',\n\t\t\t\tServerPort: '8086',\n\t\t\t\tServerEndpointPrefix: '1.0/'\n\t\t\t}\n\t\t)\n\n\t\tvar buildURL = function(pAddress)\n\t\t{\n\t\t\treturn `${_EndpointSettings.ServerProtocol}://${_EndpointSettings.ServerAddress}:${_EndpointSettings.ServerPort}/${_EndpointSettings.ServerEndpointPrefix}${pAddress}`;\n\t\t};\n\n\t\tvar buildRequestOptions = function(pQuery)\n\t\t{\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.records);\n\t\t\t}\n\n\t\t\tlet tmpURL = buildURL(pQuery.query.body);\n\n\t\t\tlet tmpRequestOptions = (\n\t\t\t{\n\t\t\t\turl: tmpURL,\n\t\t\t\theaders: _Fable.Utility.extend({cookie: ''}, _Headers)\n\t\t\t});\n\n\t\t\ttmpRequestOptions.headers.cookie = _Cookies.join(';');\n\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t_Fable.log.debug(`Request options built...`,tmpRequestOptions);\n\n\t\t\t\treturn tmpRequestOptions;\n\t\t};\n\n\t\t// The Meadow marshaller also passes in the Schema as the third parameter, but this is a blunt function ATM.\n\t\tvar marshalRecordFromSourceToObject = function(pObject, pRecord)\n\t\t{\n\t\t\tfor(var tmpColumn in pRecord)\n\t\t\t{\n\t\t\t\tpObject[tmpColumn] = pRecord[tmpColumn];\n\t\t\t}\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildCreateQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\n\t\t\t// TODO: Should this test for exactly one?\n\t\t\tif (!pQuery.query.records.length > 0)\n\t\t\t{\n\t\t\t\ttmpResult.error = 'No records passed for proxying to Meadow-Endpoints.';\n\n\t\t\t\treturn fCallback();\n\t\t\t}\n\n\t\t\ttmpRequestOptions.body = pQuery.query.records[0];\n\t\t\ttmpRequestOptions.json = true;\n\t\n\t\t\tlibSimpleGet.post(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> POST request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> POST data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\t// TODO Because this was proxied, read happens at this layer too.  Inefficient -- fixable\n\t\t\t\t\t\t\tlet tmpIdentityColumn = `ID${pQuery.parameters.scope}`;\n\t\t\t\t\t\t\tif (tmpResult.value.hasOwnProperty(tmpIdentityColumn))\n\t\t\t\t\t\t\ttmpResult.value = tmpResult.value[tmpIdentityColumn];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> POST completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildReadQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\t\n\t\t\tlibSimpleGet.get(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> GET request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> GET data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\tif (pQuery.query.body.startsWith(`${pQuery.parameters.scope}/`))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// If this is not a plural read, make the result into an array.\n\t\t\t\t\t\t\t\ttmpResult.value = [tmpResult.value];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> GET completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildUpdateQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\n\t\t\t// TODO: Should this test for exactly one?\n\t\t\tif (!pQuery.query.records.length > 0)\n\t\t\t{\n\t\t\t\ttmpResult.error = 'No records passed for proxying to Meadow-Endpoints.';\n\n\t\t\t\treturn fCallback();\n\t\t\t}\n\n\t\t\ttmpRequestOptions.body = pQuery.query.records[0];\n\t\t\ttmpRequestOptions.json = true;\n\t\n\t\t\tlibSimpleGet.put(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> PUT request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> PUT data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\t// TODO Because this was proxied, read happens at this layer too.  Inefficient -- fixable\n\t\t\t\t\t\t\tlet tmpIdentityColumn = `ID${pQuery.parameters.scope}`;\n\t\t\t\t\t\t\tif (tmpResult.value.hasOwnProperty(tmpIdentityColumn))\n\t\t\t\t\t\t\ttmpResult.value = tmpResult.value[tmpIdentityColumn];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> PUT completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t}\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildDeleteQuery();\n\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\t\n\t\t\tlibSimpleGet.delete(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> DEL request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> DEL data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (tmpResult.value.hasOwnProperty('Count'))\n\t\t\t\t\t\t\t\ttmpResult.value = tmpResult.value.Count;\n\t\n\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> DEL completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildCountQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\t\n\t\t\tlibSimpleGet.get(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> GET request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> GET data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmpResult.value = tmpResult.value.Count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// This is an error state...\n\t\t\t\t\t\t\t\t\ttmpResult.value = -1;\n\t\t\t\t\t\t\t\t\t_Fable.log.warn('Error getting rowcount during count query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> GET completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n\n},{\"simple-get\":128}],118:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif (typeof(pFable) !== 'object')\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\tvar _GlobalLogLevel = 0;\n\t\tif (_Fable.settings.MySQL)\n\t\t{\n\t\t\t _GlobalLogLevel = _Fable.settings.MySQL.GlobalLogLevel || 0;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Build a connection pool, shared within this provider.\n\t\t * This may be more performant as a shared object.\n\t\t */\n\t\tvar getSQLPool = function()\n\t\t{\n\t\t\tif (typeof(_Fable.MeadowMySQLConnectionPool) !== 'object')\n\t\t\t{\n\t\t\t\t// This is going to be problematic.\n\t\t\t\t_Fable.log.fatal('Meadow is trying to perform queries without a valid [Fable.MeadowMySQLConnectionPool] object.  See the documentation for how to initialize one.');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn _Fable.MeadowMySQLConnectionPool;\n\t\t};\n\n\t\t// The Meadow marshaller also passes in the Schema as the third parameter, but this is a blunt function ATM.\n\t\tvar marshalRecordFromSourceToObject = function(pObject, pRecord)\n\t\t{\n\t\t\t// For now, crudely assign everything in pRecord to pObject\n\t\t\t// This is safe in this context, and we don't want to slow down marshalling with millions of hasOwnProperty checks\n\t\t\tfor(var tmpColumn in pRecord)\n\t\t\t{\n\t\t\t\tpObject[tmpColumn] = pRecord[tmpColumn];\n\t\t\t}\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildCreateQuery();\n\n\t\t\t// TODO: Test the query before executing\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows.insertId;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting insert ID during create query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildReadQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = pRows;\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildUpdateQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = pRows;\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildDeleteQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query\n\t\t\t\t(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows.affectedRows;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting affected rowcount during delete query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar Undelete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildUndeleteQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query\n\t\t\t\t(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows.affectedRows;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting affected rowcount during delete query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildCountQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows[0].RowCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting rowcount during count query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tUndelete: Undelete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n\n},{}],119:[function(require,module,exports){\n// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pFable) !== 'object') || !('fable' in pFable))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\t//var _Fable = pFable;\n\n\t\t//var marshalRecordFromSourceToObject = function(pObject, pRecord, pSchema)\n\t\tvar marshalRecordFromSourceToObject = function()\n\t\t{\n\t\t\t// Do nothing ... this is the NONE provider after all\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tpQuery.parameters.result.value = [true];\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Undelete = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tUndelete: Undelete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n\n},{}],120:[function(require,module,exports){\nvar wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n},{\"wrappy\":173}],121:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],122:[function(require,module,exports){\n(function (global){(function (){\n/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],123:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],124:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],125:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":123,\"./encode\":124}],126:[function(require,module,exports){\n/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":22}],127:[function(require,module,exports){\n(function (Buffer){(function (){\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = function (stream, cb) {\n  var chunks = []\n  stream.on('data', function (chunk) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":22}],128:[function(require,module,exports){\n(function (Buffer){(function (){\n/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const originalHost = opts.hostname // hostname before potential redirect\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      const redirectHost = url.parse(opts.url).hostname // eslint-disable-line node/no-deprecated-api\n      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)\n      if (redirectHost !== null && redirectHost !== originalHost) {\n        delete opts.headers.cookie\n        delete opts.headers.authorization\n      }\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = { url: opts }\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n\n}).call(this)}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":22,\"decompress-response\":20,\"http\":144,\"https\":45,\"once\":120,\"querystring\":125,\"simple-concat\":127,\"url\":166}],129:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/lib/_stream_readable.js');\nStream.Writable = require('readable-stream/lib/_stream_writable.js');\nStream.Duplex = require('readable-stream/lib/_stream_duplex.js');\nStream.Transform = require('readable-stream/lib/_stream_transform.js');\nStream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');\nStream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')\nStream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":26,\"inherits\":47,\"readable-stream/lib/_stream_duplex.js\":131,\"readable-stream/lib/_stream_passthrough.js\":132,\"readable-stream/lib/_stream_readable.js\":133,\"readable-stream/lib/_stream_transform.js\":134,\"readable-stream/lib/_stream_writable.js\":135,\"readable-stream/lib/internal/streams/end-of-stream.js\":139,\"readable-stream/lib/internal/streams/pipeline.js\":141}],130:[function(require,module,exports){\n'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n\n},{}],131:[function(require,module,exports){\n(function (process){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nconst Readable = require('./_stream_readable');\nconst Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  const keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    const method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n}).call(this)}).call(this,require('_process'))\n\n},{\"./_stream_readable\":133,\"./_stream_writable\":135,\"_process\":121,\"inherits\":47}],132:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nconst Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":134,\"inherits\":47}],133:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nconst EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nconst debugUtil = require('util');\nlet debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nconst BufferList = require('./internal/streams/buffer_list');\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nlet StringDecoder;\nlet createReadableStreamAsyncIterator;\nlet from;\nrequire('inherits')(Readable, Stream);\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nconst kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  let p = this._readableState.buffer.head;\n  let content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', () => {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) this.push(chunk);\n    }\n    this.push(null);\n  });\n  stream.on('data', chunk => {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = n => {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      const wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../errors\":130,\"./_stream_duplex\":131,\"./internal/streams/async_iterator\":136,\"./internal/streams/buffer_list\":137,\"./internal/streams/destroy\":138,\"./internal/streams/from\":140,\"./internal/streams/state\":142,\"./internal/streams/stream\":143,\"_process\":121,\"buffer\":22,\"events\":26,\"inherits\":47,\"string_decoder/\":163,\"util\":20}],134:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nconst _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nconst Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush((er, data) => {\n      done(this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, err2 => {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n},{\"../errors\":130,\"./_stream_duplex\":131,\"inherits\":47}],135:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  this.next = null;\n  this.entry = null;\n  this.finish = () => {\n    onCorkedFinish(this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nconst internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk,\n      encoding,\n      isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(err => {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        const rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../errors\":130,\"./_stream_duplex\":131,\"./internal/streams/destroy\":138,\"./internal/streams/state\":142,\"./internal/streams/stream\":143,\"_process\":121,\"buffer\":22,\"inherits\":47,\"util-deprecate\":168}],136:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\nconst finished = require('./end-of-stream');\nconst kLastResolve = Symbol('lastResolve');\nconst kLastReject = Symbol('lastReject');\nconst kError = Symbol('error');\nconst kEnded = Symbol('ended');\nconst kLastPromise = Symbol('lastPromise');\nconst kHandlePromise = Symbol('handlePromise');\nconst kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value,\n    done\n  };\n}\nfunction readAndResolve(iter) {\n  const resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    const data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return (resolve, reject) => {\n    lastPromise.then(() => {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nconst AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nconst ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({\n  get stream() {\n    return this[kStream];\n  },\n  next() {\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    const error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise((resolve, reject) => {\n        process.nextTick(() => {\n          if (this[kError]) {\n            reject(this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    const lastPromise = this[kLastPromise];\n    let promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      const data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  },\n  [Symbol.asyncIterator]() {\n    return this;\n  },\n  return() {\n    // destroy(err, cb) is a private API\n    // we can guarantee we have that here, because we control the\n    // Readable class this is attached to\n    return new Promise((resolve, reject) => {\n      this[kStream].destroy(null, err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(createIterResult(undefined, true));\n      });\n    });\n  }\n}, AsyncIteratorPrototype);\nconst createReadableStreamAsyncIterator = stream => {\n  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {\n    [kStream]: {\n      value: stream,\n      writable: true\n    },\n    [kLastResolve]: {\n      value: null,\n      writable: true\n    },\n    [kLastReject]: {\n      value: null,\n      writable: true\n    },\n    [kError]: {\n      value: null,\n      writable: true\n    },\n    [kEnded]: {\n      value: stream._readableState.endEmitted,\n      writable: true\n    },\n    // the function passed to new Promise\n    // is cached so we avoid allocating a new\n    // closure at every run\n    [kHandlePromise]: {\n      value: (resolve, reject) => {\n        const data = iterator[kStream].read();\n        if (data) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          resolve(createIterResult(data, false));\n        } else {\n          iterator[kLastResolve] = resolve;\n          iterator[kLastReject] = reject;\n        }\n      },\n      writable: true\n    }\n  });\n  iterator[kLastPromise] = null;\n  finished(stream, err => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      const reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    const resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;\n}).call(this)}).call(this,require('_process'))\n\n},{\"./end-of-stream\":139,\"_process\":121}],137:[function(require,module,exports){\n'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst _require = require('buffer'),\n  Buffer = _require.Buffer;\nconst _require2 = require('util'),\n  inspect = _require2.inspect;\nconst custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n  shift() {\n    if (this.length === 0) return;\n    const ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n  join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) ret += s + p.data;\n    return ret;\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    var ret;\n    if (n < this.head.data.length) {\n      // `slice` is the same for buffers and strings.\n      ret = this.head.data.slice(0, n);\n      this.head.data = this.head.data.slice(n);\n    } else if (n === this.head.data.length) {\n      // First chunk is a perfect match.\n      ret = this.shift();\n    } else {\n      // Result spans more than one buffer.\n      ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n    }\n    return ret;\n  }\n  first() {\n    return this.head.data;\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    var p = this.head;\n    var c = 1;\n    var ret = p.data;\n    n -= ret.length;\n    while (p = p.next) {\n      const str = p.data;\n      const nb = n > str.length ? str.length : n;\n      if (nb === str.length) ret += str;else ret += str.slice(0, n);\n      n -= nb;\n      if (n === 0) {\n        if (nb === str.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = str.slice(nb);\n        }\n        break;\n      }\n      ++c;\n    }\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    var p = this.head;\n    var c = 1;\n    p.data.copy(ret);\n    n -= p.data.length;\n    while (p = p.next) {\n      const buf = p.data;\n      const nb = n > buf.length ? buf.length : n;\n      buf.copy(ret, ret.length - n, 0, nb);\n      n -= nb;\n      if (n === 0) {\n        if (nb === buf.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = buf.slice(nb);\n        }\n        break;\n      }\n      ++c;\n    }\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [custom](_, options) {\n    return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    }));\n  }\n};\n},{\"buffer\":22,\"util\":20}],138:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState && this._readableState.destroyed;\n  const writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, err => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const rState = stream._readableState;\n  const wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy,\n  undestroy,\n  errorOrDestroy\n};\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":121}],139:[function(require,module,exports){\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nconst ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  let called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  let readable = opts.readable || opts.readable !== false && stream.readable;\n  let writable = opts.writable || opts.writable !== false && stream.writable;\n  const onlegacyfinish = () => {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  const onfinish = () => {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  const onend = () => {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  const onerror = err => {\n    callback.call(stream, err);\n  };\n  const onclose = () => {\n    let err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  const onrequest = () => {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;\n},{\"../../../errors\":130}],140:[function(require,module,exports){\nmodule.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n\n},{}],141:[function(require,module,exports){\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nlet eos;\nfunction once(callback) {\n  let called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback(...arguments);\n  };\n}\nconst _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  let closed = false;\n  stream.on('close', () => {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, err => {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  let destroyed = false;\n  return err => {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  const callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  let error;\n  const destroys = streams.map(function (stream, i) {\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;\n},{\"../../../errors\":130,\"./end-of-stream\":139}],142:[function(require,module,exports){\n'use strict';\n\nconst ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      const name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark\n};\n},{\"../../../errors\":130}],143:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":26}],144:[function(require,module,exports){\n(function (global){(function (){\nvar ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./lib/request\":146,\"./lib/response\":147,\"builtin-status-codes\":23,\"url\":166,\"xtend\":174}],145:[function(require,module,exports){\n(function (global){(function (){\nexports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],146:[function(require,module,exports){\n(function (process,global,Buffer){(function (){\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\tself._socketTimeout = null\n\tself._socketTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tif ('timeout' in opts && opts.timeout !== 0) {\n\t\tself.setTimeout(opts.timeout)\n\t}\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n        body = new Blob(self._body, {\n            type: (headersObj['content-type'] || {}).value || ''\n        });\n    }\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._resetTimers(false)\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself._resetTimers(true)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself._resetTimers(true)\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tself._resetTimers(false)\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress(self._resetTimers.bind(self))\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype._resetTimers = function (done) {\n\tvar self = this\n\n\tglobal.clearTimeout(self._socketTimer)\n\tself._socketTimer = null\n\n\tif (done) {\n\t\tglobal.clearTimeout(self._fetchTimer)\n\t\tself._fetchTimer = null\n\t} else if (self._socketTimeout) {\n\t\tself._socketTimer = global.setTimeout(function () {\n\t\t\tself.emit('timeout')\n\t\t}, self._socketTimeout)\n\t}\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {\n\tvar self = this\n\tself._destroyed = true\n\tself._resetTimers(true)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n\n\tif (err)\n\t\tself.emit('error', err)\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.setTimeout = function (timeout, cb) {\n\tvar self = this\n\n\tif (cb)\n\t\tself.once('timeout', cb)\n\n\tself._socketTimeout = timeout\n\tself._resetTimers(false)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":145,\"./response\":147,\"_process\":121,\"buffer\":22,\"inherits\":47,\"readable-stream\":162}],147:[function(require,module,exports){\n(function (process,global,Buffer){(function (){\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\tresetTimers(false)\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tresetTimers(result.done)\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(Buffer.from(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tresetTimers(true)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function (resetTimers) {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text':\n\t\t\tresponse = xhr.responseText\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tresetTimers(true)\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tresetTimers(true)\n\t\tself.push(null)\n\t}\n}\n\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":145,\"_process\":121,\"buffer\":22,\"inherits\":47,\"readable-stream\":162}],148:[function(require,module,exports){\narguments[4][130][0].apply(exports,arguments)\n},{\"dup\":130}],149:[function(require,module,exports){\n(function (process){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nconst Readable = require('./_stream_readable');\nconst Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  const keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    const method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n}).call(this)}).call(this,require('_process'))\n\n},{\"./_stream_readable\":151,\"./_stream_writable\":153,\"_process\":121,\"inherits\":47}],150:[function(require,module,exports){\narguments[4][132][0].apply(exports,arguments)\n},{\"./_stream_transform\":152,\"dup\":132,\"inherits\":47}],151:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nconst EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nconst debugUtil = require('util');\nlet debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nconst BufferList = require('./internal/streams/buffer_list');\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nlet StringDecoder;\nlet createReadableStreamAsyncIterator;\nlet from;\nrequire('inherits')(Readable, Stream);\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nconst kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  let p = this._readableState.buffer.head;\n  let content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', () => {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) this.push(chunk);\n    }\n    this.push(null);\n  });\n  stream.on('data', chunk => {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = n => {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      const wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../errors\":148,\"./_stream_duplex\":149,\"./internal/streams/async_iterator\":154,\"./internal/streams/buffer_list\":155,\"./internal/streams/destroy\":156,\"./internal/streams/from\":158,\"./internal/streams/state\":160,\"./internal/streams/stream\":161,\"_process\":121,\"buffer\":22,\"events\":26,\"inherits\":47,\"string_decoder/\":163,\"util\":20}],152:[function(require,module,exports){\narguments[4][134][0].apply(exports,arguments)\n},{\"../errors\":148,\"./_stream_duplex\":149,\"dup\":134,\"inherits\":47}],153:[function(require,module,exports){\n(function (process,global){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  this.next = null;\n  this.entry = null;\n  this.finish = () => {\n    onCorkedFinish(this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nconst internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk,\n      encoding,\n      isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(err => {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        const rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n}).call(this)}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../errors\":148,\"./_stream_duplex\":149,\"./internal/streams/destroy\":156,\"./internal/streams/state\":160,\"./internal/streams/stream\":161,\"_process\":121,\"buffer\":22,\"inherits\":47,\"util-deprecate\":168}],154:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\nconst finished = require('./end-of-stream');\nconst kLastResolve = Symbol('lastResolve');\nconst kLastReject = Symbol('lastReject');\nconst kError = Symbol('error');\nconst kEnded = Symbol('ended');\nconst kLastPromise = Symbol('lastPromise');\nconst kHandlePromise = Symbol('handlePromise');\nconst kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value,\n    done\n  };\n}\nfunction readAndResolve(iter) {\n  const resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    const data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return (resolve, reject) => {\n    lastPromise.then(() => {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nconst AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nconst ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({\n  get stream() {\n    return this[kStream];\n  },\n  next() {\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    const error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise((resolve, reject) => {\n        process.nextTick(() => {\n          if (this[kError]) {\n            reject(this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    const lastPromise = this[kLastPromise];\n    let promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      const data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  },\n  [Symbol.asyncIterator]() {\n    return this;\n  },\n  return() {\n    // destroy(err, cb) is a private API\n    // we can guarantee we have that here, because we control the\n    // Readable class this is attached to\n    return new Promise((resolve, reject) => {\n      this[kStream].destroy(null, err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(createIterResult(undefined, true));\n      });\n    });\n  }\n}, AsyncIteratorPrototype);\nconst createReadableStreamAsyncIterator = stream => {\n  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {\n    [kStream]: {\n      value: stream,\n      writable: true\n    },\n    [kLastResolve]: {\n      value: null,\n      writable: true\n    },\n    [kLastReject]: {\n      value: null,\n      writable: true\n    },\n    [kError]: {\n      value: null,\n      writable: true\n    },\n    [kEnded]: {\n      value: stream._readableState.endEmitted,\n      writable: true\n    },\n    // the function passed to new Promise\n    // is cached so we avoid allocating a new\n    // closure at every run\n    [kHandlePromise]: {\n      value: (resolve, reject) => {\n        const data = iterator[kStream].read();\n        if (data) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          resolve(createIterResult(data, false));\n        } else {\n          iterator[kLastResolve] = resolve;\n          iterator[kLastReject] = reject;\n        }\n      },\n      writable: true\n    }\n  });\n  iterator[kLastPromise] = null;\n  finished(stream, err => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      const reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    const resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;\n}).call(this)}).call(this,require('_process'))\n\n},{\"./end-of-stream\":157,\"_process\":121}],155:[function(require,module,exports){\narguments[4][137][0].apply(exports,arguments)\n},{\"buffer\":22,\"dup\":137,\"util\":20}],156:[function(require,module,exports){\n(function (process){(function (){\n'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState && this._readableState.destroyed;\n  const writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, err => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const rState = stream._readableState;\n  const wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy,\n  undestroy,\n  errorOrDestroy\n};\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":121}],157:[function(require,module,exports){\narguments[4][139][0].apply(exports,arguments)\n},{\"../../../errors\":148,\"dup\":139}],158:[function(require,module,exports){\narguments[4][140][0].apply(exports,arguments)\n},{\"dup\":140}],159:[function(require,module,exports){\narguments[4][141][0].apply(exports,arguments)\n},{\"../../../errors\":148,\"./end-of-stream\":157,\"dup\":141}],160:[function(require,module,exports){\narguments[4][142][0].apply(exports,arguments)\n},{\"../../../errors\":148,\"dup\":142}],161:[function(require,module,exports){\narguments[4][143][0].apply(exports,arguments)\n},{\"dup\":143,\"events\":26}],162:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n\n},{\"./lib/_stream_duplex.js\":149,\"./lib/_stream_passthrough.js\":150,\"./lib/_stream_readable.js\":151,\"./lib/_stream_transform.js\":152,\"./lib/_stream_writable.js\":153,\"./lib/internal/streams/end-of-stream.js\":157,\"./lib/internal/streams/pipeline.js\":159}],163:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":126}],164:[function(require,module,exports){\n(function (process){(function (){\nvar Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"_process\":121,\"stream\":129}],165:[function(require,module,exports){\n(function (setImmediate,clearImmediate){(function (){\nvar nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n}).call(this)}).call(this,require(\"timers\").setImmediate,require(\"timers\").clearImmediate)\n\n},{\"process/browser.js\":121,\"timers\":165}],166:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n},{\"./util\":167,\"punycode\":122,\"querystring\":125}],167:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n},{}],168:[function(require,module,exports){\n(function (global){(function (){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],169:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],170:[function(require,module,exports){\n// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n\n},{\"is-arguments\":48,\"is-generator-function\":50,\"is-typed-array\":55,\"which-typed-array\":172}],171:[function(require,module,exports){\n(function (process){(function (){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').slice(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.slice(1, -1);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n}).call(this)}).call(this,require('_process'))\n\n},{\"./support/isBuffer\":169,\"./support/types\":170,\"_process\":121,\"inherits\":47}],172:[function(require,module,exports){\n(function (global){(function (){\n'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\nvar gOPD = require('gopd');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = require('is-typed-array');\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n\n}).call(this)}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"available-typed-arrays\":18,\"call-bind/callBound\":24,\"for-each\":27,\"gopd\":40,\"has-tostringtag/shams\":43,\"is-typed-array\":55}],173:[function(require,module,exports){\n// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n},{}],174:[function(require,module,exports){\nmodule.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n},{}],175:[function(require,module,exports){\n/**\n* Simple browser shim loader - assign the npm module to a window global automatically\n*\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libNPMModuleWrapper = require('./Meadow-Endpoints.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('MeadowEndpoints'))\n{\n\twindow.MeadowEndpoints = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;\n},{\"./Meadow-Endpoints.js\":176}],176:[function(require,module,exports){\n/**\n* Meadow Endpoints Service Data Broker Library\n*\n* @license MIT\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nconst libMeadowEndpointsControllerBase = require('./controller/Meadow-Endpoints-Controller-Base.js');\nconst libMeadow = require('meadow');\n\nclass MeadowEndpoints\n{\n\tconstructor(pMeadow, pControllerOptions)\n\t{\n\t\tthis._Meadow = pMeadow;\n\t\t// This is for backwards compatibility\n\t\tthis.DAL = this._Meadow;\n\n\t\tthis._Controller = false;\n\t\tthis._ControllerOptions = (typeof(pControllerOptions) == 'object') ? pControllerOptions : {};\n\n\t\tif (typeof(pMeadow) != 'object')\n\t\t{\n\t\t\tthrow new Error('Meadow endpoints requires a valid Meadow DAL object as the first parameter of the constructor.');\n\t\t}\n\n\t\tif (this._ControllerOptions.hasOwnProperty('ControllerInstance'))\n\t\t{\n\t\t\t// Passed in already instantiated controller instance\n\t\t\tthis._Controller = this._ControllerOptions.ControllerInstance;\n\t\t}\n\t\telse if (this._ControllerOptions.hasOwnProperty('ControllerClass'))\n\t\t{\n\t\t\t// Passed in controller class, ready to initialize\n\t\t\tthis._Controller = new this._ControllerOptions.ControllerClass(this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._Controller = new libMeadowEndpointsControllerBase(this);\n\t\t}\n\n\t\t// Pull version from the settings; default to 1.0\n\t\tthis.EndpointVersion = this._Controller.settings.MeadowEndpointVersion || '1.0';\n\t\t// Pull endpoint name from settings if the user to override the endpoint \"name\" eventually.\n\t\tthis.EndpointName = this.DAL.scope;\n\t\t// This allows a wily developer to change what this prefix is....\n\t\tthis.EndpointPrefix = `/${this.EndpointVersion}/${this.EndpointName}`;\n\n\t\t// The default behavior sets available.\n\t\t// Turning these off before wiring the endpoints up will result in their counterpart endpoints not being available.\n\t\tthis._EnabledBehaviorSets = (\n\t\t{\n\t\t\tCreate: true,\n\t\t\tRead: true,\n\t\t\tReads: true,\n\t\t\tUpdate: true,\n\t\t\tDelete: true,\n\t\t\tCount: true,\n\t\t\tSchema: true,\n\t\t\tValidate: true,\n\t\t\tNew: true\n\t\t});\n\n\t\t// The default endpoints\n\t\tthis._Endpoints = (\n\t\t{\n\t\t\tCreate: require('./endpoints/create/Meadow-Endpoint-Create.js'),\n\t\t\tCreates: require('./endpoints/create/Meadow-Endpoint-BulkCreate.js'),\n\n\t\t\tRead: require('./endpoints/read/Meadow-Endpoint-Read.js'),\n\t\t\tReadMax: require('./endpoints/read/Meadow-Endpoint-ReadMax.js'),\n\n\t\t\tReads: require('./endpoints/read/Meadow-Endpoint-Reads.js'),\n\t\t\tReadsBy: require('./endpoints/read/Meadow-Endpoint-ReadsBy.js'),\n\n\t\t\tReadSelectList: require('./endpoints/read/Meadow-Endpoint-ReadSelectList.js'),\n\t\t\tReadLiteList: require('./endpoints/read/Meadow-Endpoint-ReadLiteList.js'),\n\t\t\tReadDistinctList: require('./endpoints/read/Meadow-Endpoint-ReadDistinctList.js'),\n\n\t\t\tUpdate: require('./endpoints/update/Meadow-Endpoint-Update.js'),\n\t\t\tUpdates: require('./endpoints/update/Meadow-Endpoint-BulkUpdate.js'),\n\n\t\t\tUpsert: require('./endpoints/upsert/Meadow-Endpoint-Upsert.js'),\n\t\t\tUpserts: require('./endpoints/upsert/Meadow-Endpoint-BulkUpsert.js'),\n\n\t\t\tDelete: require('./endpoints/delete/Meadow-Endpoint-Delete.js'),\n\t\t\tUndelete: require('./endpoints/delete/Meadow-Endpoint-Undelete.js'),\n\n\t\t\tCount: require('./endpoints/count/Meadow-Endpoint-Count.js'),\n\t\t\tCountBy: require('./endpoints/count/Meadow-Endpoint-CountBy.js'),\n\n\t\t\t// Get the JSONSchema spec schema\n\t\t\t/* http://json-schema.org/examples.html\n\t\t\t * http://json-schema.org/latest/json-schema-core.html\n\t\t\t */\n\t\t\tSchema: require('./endpoints/schema/Meadow-Endpoint-Schema.js'),\n\t\t\t// Validate a passed-in JSON object for if it matches the schema\n\t\t\tValidate: require('./endpoints/schema/Meadow-Endpoint-Validate.js'),\n\t\t\t// Get an empty initialized JSON object for this.\n\t\t\tNew: require('./endpoints/schema/Meadow-Endpoint-New.js')\n\t\t});\n\t}\n\n\tget controller()\n\t{\n\t\treturn this._Controller;\n\t}\n\tset controller(pController)\n\t{\n\t\tthis._Controller = pController;\n\t}\n\n\t/**\n\t* Customize a default endpoint (or create more)\n\t*\n\t* @method setEndpoint\n\t*/\n\tsetBehaviorEndpoint(pEndpointHash, fEndpoint)\n\t{\n\t\tif (typeof(fEndpoint) === 'function')\n\t\t{\n\t\t\tthis._Endpoints[pEndpointHash] = fEndpoint;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tconnectRoute(pServiceServer, pRequestMethod, pRoutePartial, pEndpointProcessingFunction, pBehaviorName)\n\t{\n\t\tlet tmpRoute = `${this.EndpointPrefix}${pRoutePartial}`;\n\t\tlet tmpBehaviorName = (typeof(pBehaviorName) == 'string') ? pBehaviorName : 'an unnamed custom behavior'\n\n\t\tthis._Controller.log.trace(`...meadow-endpoints mapping a ${pRequestMethod} endpoint for scope ${this.DAL.scope} on route [${tmpRoute}] which runs ${tmpBehaviorName}.`);\n\n\t\ttry\n\t\t{\n\t\t\t(pServiceServer[pRequestMethod])(tmpRoute, pEndpointProcessingFunction.bind(this._Controller));\n\t\t}\n\t\tcatch (pServiceServerRouteConnectError)\n\t\t{\n\t\t\tthis._Controller.log.error(`...error mapping ${pBehaviorName} to method ${pRequestMethod} for scope ${this.DAL.scope} to route [${tmpRoute}]: ${pServiceServerRouteConnectError}`, pServiceServerRouteConnectError.stack);\n\t\t}\n\t\treturn true;\n\t}\n\n\tconnectRoutes(pServiceServer)\n\t{\n\t\tthis._Controller.log.trace(`Creating automatic meadow endpoints at prefix [${this.EndpointPrefix}] for scope ${this.DAL.scope}...`);\n\n\t\t// These special schema services must come in the route table before the READ because they\n\t\t// technically block out the routes for the IDRecord 'Schema' (e.g. GET[/1.0/EntityName/Schema] ==NEEDS=> GET[/1.0/EntityName/100])\n\t\tif (this._EnabledBehaviorSets.Schema)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Schema`, this._Endpoints.Schema, `the internal behavior _Endpoints.Schema`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.New)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Schema/New`, this._Endpoints.New, `the internal behavior _Endpoints.New`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Validate)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'post', `/Schema/Validate`, this._Endpoints.Validate, `the internal behavior _Endpoints.Validate`);\n\t\t}\n\n\t\t// Standard CRUD and Count endpoints\n\t\tif (this._EnabledBehaviorSets.Create)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'post', ``, this._Endpoints.Create, `the internal behavior _Endpoints.Create`);\n\t\t\tthis.connectRoute(pServiceServer, 'post', `s`, this._Endpoints.Creates, `the internal behavior _Endpoints.Creates`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Read)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Max/:ColumnName`, this._Endpoints.ReadMax, `the internal behavior _Endpoints.ReadMax`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/:IDRecord`, this._Endpoints.Read, `the internal behavior _Endpoints.Read`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Reads)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/By/:ByField/:ByValue`, this._Endpoints.ReadsBy, `the internal behavior _Endpoints.ReadsBy`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/By/:ByField/:ByValue/:Begin/:Cap`, this._Endpoints.ReadsBy, `the internal behavior _Endpoints.ReadsBy`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/FilteredTo/:Filter`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select/FilteredTo/:Filter`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select/:Begin/:Cap`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite/FilteredTo/:Filter`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns/FilteredTo/:Filter`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns/FilteredTo/:Filter`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns/:Begin/:Cap`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/:Begin/:Cap`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Update)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'put', ``, this._Endpoints.Update, `the internal behavior _Endpoints.Update`);\n\t\t\tthis.connectRoute(pServiceServer, 'put', `s`, this._Endpoints.Updates, `the internal behavior _Endpoints.Updates`);\n\t\t\tthis.connectRoute(pServiceServer, 'put', `/Upsert`, this._Endpoints.Upsert, `the internal behavior _Endpoints.Upsert`);\n\t\t\tthis.connectRoute(pServiceServer, 'put', `/Upserts`, this._Endpoints.Upserts, `the internal behavior _Endpoints.Upserts`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Delete)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'del', ``, this._Endpoints.Delete, `the internal behavior _Endpoints.Delete`);\n\t\t\tthis.connectRoute(pServiceServer, 'del', `/:IDRecord`, this._Endpoints.Delete, `the internal behavior _Endpoints.Delete`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Undelete/:IDRecord`, this._Endpoints.Undelete, `the internal behavior _Endpoints.Undelete`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Count)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Count`, this._Endpoints.Count, `the internal behavior _Endpoints.Count`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Count/By/:ByField/:ByValue`, this._Endpoints.CountBy, `the internal behavior _Endpoints.CountBy`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Count/FilteredTo/:Filter`, this._Endpoints.Count, `the internal behavior _Endpoints.Count`);\n\t\t}\n\t}\n}\n\n\n// This is for backwards compatibility\nfunction autoConstruct(pMeadow, pControllerOptions)\n{\n\treturn new MeadowEndpoints(pMeadow, pControllerOptions);\n}\n\nmodule.exports = MeadowEndpoints;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.Meadow = libMeadow;\nmodule.exports.BaseController = libMeadowEndpointsControllerBase;\n},{\"./controller/Meadow-Endpoints-Controller-Base.js\":177,\"./endpoints/count/Meadow-Endpoint-Count.js\":184,\"./endpoints/count/Meadow-Endpoint-CountBy.js\":185,\"./endpoints/create/Meadow-Endpoint-BulkCreate.js\":186,\"./endpoints/create/Meadow-Endpoint-Create.js\":187,\"./endpoints/delete/Meadow-Endpoint-Delete.js\":189,\"./endpoints/delete/Meadow-Endpoint-Undelete.js\":190,\"./endpoints/read/Meadow-Endpoint-Read.js\":191,\"./endpoints/read/Meadow-Endpoint-ReadDistinctList.js\":192,\"./endpoints/read/Meadow-Endpoint-ReadLiteList.js\":193,\"./endpoints/read/Meadow-Endpoint-ReadMax.js\":194,\"./endpoints/read/Meadow-Endpoint-ReadSelectList.js\":195,\"./endpoints/read/Meadow-Endpoint-Reads.js\":196,\"./endpoints/read/Meadow-Endpoint-ReadsBy.js\":197,\"./endpoints/schema/Meadow-Endpoint-New.js\":200,\"./endpoints/schema/Meadow-Endpoint-Schema.js\":201,\"./endpoints/schema/Meadow-Endpoint-Validate.js\":202,\"./endpoints/update/Meadow-Endpoint-BulkUpdate.js\":203,\"./endpoints/update/Meadow-Endpoint-Update.js\":204,\"./endpoints/upsert/Meadow-Endpoint-BulkUpsert.js\":206,\"./endpoints/upsert/Meadow-Endpoint-Upsert.js\":207,\"meadow\":108}],177:[function(require,module,exports){\nconst libAsyncWaterfall = require('async/waterfall');\n\nconst libBaseLogController = require('./components/Meadow-Endpoints-Controller-Log.js')\n\nconst libBaseErrorController = require('./components/Meadow-Endpoints-Controller-Error.js');\nconst libBaseBehaviorInjectionController = require('./components/Meadow-Endpoints-Controller-BehaviorInjection.js');\n\nconst libMeadowEndpointsFilterParser = require('./utility/Meadow-Endpoints-Filter-Parser.js');\nconst libMeadowEndpointsSessionMarshaler = require('./utility/Meadow-Endpoints-Session-Marshaler.js');\nconst libMeadowEndpointsStreamRecordArray = require('./utility/Meadow-Endpoints-Stream-RecordArray.js');\n\nclass MeadowEndpointControllerBase\n{\n\tconstructor(pMeadowEndpoints)\n\t{\n\t\tthis.DAL = pMeadowEndpoints.DAL;\n\t\tthis.ControllerOptions = pMeadowEndpoints._ControllerOptions\n\n\t\t// Application Services\n\t\tthis._Settings = false;\n\t\tthis._LogController = false;\n\n\t\t// Logic and Behavior\n\t\tthis._BehaviorInjectionController = false;\n\t\tthis._ErrorController = false;\n\n\t\t// Internal async utility functions\n\t\tthis.waterfall = this.DAL.fable.Utility.waterfall;\n\t\tthis.eachLimit = this.DAL.fable.Utility.eachLimit;\n\t\tthis.extend = this.DAL.fable.Utility.extend;\n\n\t\tif ((typeof(pControllerOptions) != 'object') || pControllerOptions.hasOwnProperty('ControllerClass'))\n\t\t{\n\t\t\tthis.initializeDefaultUnsetControllers(this);\n\t\t}\n\n\t\t// Behavior functions\n\t\tthis._FilterParser = new libMeadowEndpointsFilterParser(this);\n\t\tthis._SessionMarshaler = new libMeadowEndpointsSessionMarshaler(this);\n\t\tthis._StreamRecordArray = new libMeadowEndpointsStreamRecordArray(this);\n\t}\n\n\tinitializeDefaultUnsetControllers(pController)\n\t{\n\t\t// Application Services\n\t\tif (!this._Settings)\n\t\t{\n\t\t\tthis._Settings = pController.DAL.fable.settings;\n\t\t}\n\t\tif (!this._Settings.hasOwnProperty('MeadowEndpointsDefaultSessionObject'))\n\t\t{\n\t\t\tthis._Settings.MeadowEndpointsDefaultSessionObject = (\n\t\t\t\t{\n\t\t\t\t\tCustomerID: 0,\n\t\t\t\t\tSessionID: '0x0000',\n\t\t\t\t\tDeviceID: 'Unset',\n\t\t\t\t\tUserID: 0,\n\t\t\t\t\tUserRole: 'None',\n\t\t\t\t\tUserRoleIndex: 0,\n\t\t\t\t\tLoggedIn: false\n\t\t\t\t});\n\t\t}\n\t\tif (!this._LogController)\n\t\t{\n\t\t\tthis._LogController = new libBaseLogController(pController);\n\t\t}\n\t\tif (!this._BehaviorInjectionController)\n\t\t{\n\t\t\tthis._BehaviorInjectionController = new libBaseBehaviorInjectionController(pController);\n\t\t}\n\t\tif (!this._ErrorController)\n\t\t{\n\t\t\tthis._ErrorController = new libBaseErrorController(pController);\n\t\t}\n\t}\n\n\tinitializeRequestState(pRequest, pVerb)\n\t{\n\t\tlet tmpRequestState = {};\n\n\t\ttmpRequestState.Verb = (typeof(pVerb) == 'string') ? pVerb : 'Unnamed_Custom_Behavior';\n\t\ttmpRequestState.SessionData = this.getSessionData(pRequest);\n\n\t\treturn tmpRequestState;\n\t}\n\n\t// Clone the session data and verb to a new request state object\n\tcloneAsyncSafeRequestState(pRequestState, pNewVerb)\n\t{\n\t\tlet tmpSafeRequestState = (\n\t\t\t{\n\t\t\t\tParentRequestState: pRequestState,\n\t\t\t\tSessionData: pRequestState.SessionData\n\t\t\t});\n\n\t\ttmpSafeRequestState.Verb = (typeof(pNewVerb) == 'string') ? pVerb : pRequestState.Verb;\n\n\t\treturn tmpSafeRequestState;\n\t}\n\n\t// Override this to provide an alternate ending function that is run with every endpoint.\n\t_BeginDataRequestFunction(pRequest, pResponse, fNext)\n\t{\n\t\treturn fNext();\n\t}\n\n\tbeginMeadowRequest(pRequest, pResponse, fNext)\n\t{\n\t\tthis._BeginDataRequestFunction(pRequest, pResponse, fNext);\n\t}\n\n\t// Override this to provide an alternate ending function that is run with every endpoint.\n\t_EndDataRequestFunction(pRequest, pResponse, fNext)\n\t{\n\t\treturn fNext();\n\t}\n\n\tendMeadowRequest(pRequest, pResponse, fNext)\n\t{\n\t\tthis._EndDataRequestFunction(pRequest, pResponse, fNext);\n\t}\n\n\t// Application Services\n\tget settings() {return this._Settings; }\n\tset settings(pSettings) { this._Settings = pSettings; }\n\n\tget log() {return this._LogController; }\n\tset log(pLogController) { this._LogController = pLogController; }\n\n\t// Logic and Behavior\n\tget BehaviorInjection() {return this._BehaviorInjectionController; }\n\tset BehaviorInjection(pBehaviorInjectionController) { this._BehaviorInjectionController = pBehaviorInjectionController; }\n\n\tget ErrorHandler() {return this._ErrorController; }\n\tset ErrorHandler(pErrorController) { this._ErrorController = pErrorController; }\n\n\tparseFilter(pFilterString, pQuery)\n\t{\n\t\treturn this._FilterParser.parseFilter(pFilterString, pQuery);\n\t}\n\n\tdoStreamRecordArray(pResponse, pRecords, fCallback)\n\t{\n\t\treturn this._StreamRecordArray.streamRecordArray(pResponse, pRecords, fCallback);\n\t}\n\n\tgetSessionData(pRequest)\n\t{\n\t\treturn this._SessionMarshaler.getSessionData(pRequest);\n\t}\n}\n\nmodule.exports = MeadowEndpointControllerBase;\n\n// Export the base classes for the controller components, for inheritance\nmodule.exports.BaseErrorController = libBaseErrorController;\nmodule.exports.BaseBehaviorInjectionController = libBaseBehaviorInjectionController;\n\nmodule.exports.BaseFilterParser = libMeadowEndpointsFilterParser;\nmodule.exports.BaseSessionMarshaler = libMeadowEndpointsSessionMarshaler;\nmodule.exports.BaseStreamRecordArray = libMeadowEndpointsStreamRecordArray;\n},{\"./components/Meadow-Endpoints-Controller-BehaviorInjection.js\":178,\"./components/Meadow-Endpoints-Controller-Error.js\":179,\"./components/Meadow-Endpoints-Controller-Log.js\":180,\"./utility/Meadow-Endpoints-Filter-Parser.js\":181,\"./utility/Meadow-Endpoints-Session-Marshaler.js\":182,\"./utility/Meadow-Endpoints-Stream-RecordArray.js\":183,\"async/waterfall\":17}],178:[function(require,module,exports){\nclass MeadowEndpointsControllerBehaviorInjectionBase\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n\n        // The template compilation function\n\t\tthis.template = this._Controller.DAL.fable.Utility.template;\n\n\t\t// An object to hold modifications to specific behaviors.\n\t\tthis._BehaviorFunctions = {};\n\n\t\t// A set of objects to hold the specific templates and their compiled functions\n\t\tthis._Templates = {};\n\t\tthis._TemplateFunctions = {};\n    }\n\n\t/**\n\t* Set a specific behavior.\n\t*\n\t* The anatomy of a behavior function is as follows:\n\t*\n\t* var someBehavior = function(pRequest, fCallback)\n\t* {\n\t*      // Do some stuff with pRequest...\n\t*      if (pRequest.UserSession.UserRoleIndex < 5)\n\t*          tmpRequestState.Query.addFilter('Customer', pRequest.UserSession.IDCustomer);\n\t*      return fCallback(false);\n\t* }\n\t*\n\t* It is important to note that the fCallback function expects false if no error, or a string message if there is one.\n\t*/\n\tsetBehavior(pBehaviorHash, fBehavior)\n\t{\n\t\tthis._BehaviorFunctions[pBehaviorHash] = fBehavior;\n\t}\n\n\t/**\n\t* This method runs a behavior at a specific hash, and returns true.\n\t* Or it returns false if there was no behavior there.\n\t* Behaviors should expect their state to be in the pRequest object, per the example in setBehavior\n\t*/\n\trunBehavior(pBehaviorHash, pController, pRequest, pRequestState, fCallback)\n\t{\n\t\t// Run an injected behavior (if it exists)\n\t\tif (this._BehaviorFunctions.hasOwnProperty(pBehaviorHash))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Call the behavior with the scoped [this] of the Meadow behavior\n\t\t\t\t// NOTE: If you define a behavior with lambda arrow syntax, it will *not* respect the call\n\t\t\t\treturn this._BehaviorFunctions[pBehaviorHash].call(pController, pRequest, pRequestState, fCallback);\n\t\t\t}\n\t\t\tcatch (pInjectedBehaviorError)\n\t\t\t{\n\t\t\t\treturn fCallback(pInjectedBehaviorError);\n\t\t\t}\n\t\t}\n\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t* Get a template.\n\t*/\n\tgetTemplate(pTemplateHash)\n\t{\n\t\tif (this._Templates.hasOwnProperty(pTemplateHash))\n\t\t{\n\t\t\treturn this._Templates[pTemplateHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t* Set a template.\n\t*/\n\tsetTemplate(pTemplateHash, pTemplate)\n\t{\n\t\t// Store both the cached text as well as the function\n\t\tthis._Templates[pTemplateHash] = pTemplate;\n\t\tthis._TemplateFunctions[pTemplateHash] = this.template(pTemplate);\n\t}\n\n\t/**\n\t* Get a template function.\n\t*/\n\tgetTemplateFunction(pTemplateHash)\n\t{\n\t\tif (this._TemplateFunctions.hasOwnProperty(pTemplateHash))\n\t\t{\n\t\t\treturn this._TemplateFunctions[pTemplateHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t* Process a template at a hash, and return the result.\n\t*/\n\tprocessTemplate(pTemplateHash, pTemplateData, pDefaultTemplate)\n\t{\n\t\tvar tmpTemplateFunction = this.getTemplateFunction(pTemplateHash);\n\t\tvar tmpTemplateData = (typeof(pTemplateData) === 'undefined') ? {} : pTemplateData;\n\n\t\t// This makes the function fairly laziliy loading.\n\t\tif (tmpTemplateFunction === false)\n\t\t{\n\t\t\t// If the template doesn't exist, try to use the passed-in default and set that as the template.\n\t\t\t// Otherwise make it empty.\n\t\t\tthis.setTemplate(pTemplateHash, (typeof(pDefaultTemplate) === 'undefined') ? '' : pDefaultTemplate);\n\t\t\ttmpTemplateFunction = this.getTemplateFunction(pTemplateHash);\n\t\t}\n\n\t\t// Now process and return the underscore template.\n\t\treturn tmpTemplateFunction(tmpTemplateData);\n\t}\n}\n\nmodule.exports = MeadowEndpointsControllerBehaviorInjectionBase;\n},{}],179:[function(require,module,exports){\nclass MeadowEndpointsControllerErrorBase\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    // Get the error object\n    getError(pMessage, pStatusCode, pSuppressSoftwareTrace)\n    {\n\t\tlet tmpError = new Error(pMessage);\n\n    \t// Default the error status code to 400 if none is passed\n\t\ttmpError.StatusCode = (typeof(pStatusCode) == 'number') ? pStatusCode : 400;\n\t\t// This suppresses the stack trace from being sent back or logged.\n\t\t// And by default it does not send a stack trace, as we expect errors created this way to be protocol, schema or data related.\n\t\ttmpError.SuppressSoftwareTrace = (typeof(pSuppressSoftwareTrace) != 'undefined') ? pSuppressSoftwareTrace : true;\n\n        return tmpError;\n    }\n\n    // Handle an error if set -- some errors don't send the response back because they aren't fully errory errors.\n\thandleErrorIfSet(pRequest, pRequestState, pResponse, pError, fCallback)\n\t{\n\t\tif (pError)\n\t\t{\n\t\t\treturn this.sendError(pRequest, pRequestState, pResponse, pError, fCallback);\n\t\t}\n\n\t\treturn fCallback();\n\t}\n\n    // Send an error object\n\tsendError(pRequest, pRequestState, pResponse, pError, fCallback)\n\t{\n\t\tthis._Controller.log.logRequestError(pRequest, pRequestState, pError);\n\n\t\t// TODO: Detect if we've already sent headers?\n\t\tif (!this._Controller.ControllerOptions.SendErrorStatusCodes)\n\t\t{\n\t\t\tlet tmpStatusCode = (pError.hasOwnProperty('StatusCode')) ? pError.StatusCode : 500;\n\t\t\tpResponse.status(tmpStatusCode);\n\t\t}\n\n\t\tlet tmpResponseObject = (\n\t\t\t{\n\t\t\t\tError:pError.message,\n\t\t\t\tStatusCode:pError.StatusCode\n\t\t\t});\n\n\t\ttmpResponseObject = this._Controller.ErrorHandler.prepareRequestContextOutputObject(tmpResponseObject, pRequest, pRequestState, pError);\n\n\t\tpResponse.send(tmpResponseObject);\n\n\t\tfCallback(pError);\n\t}\n\n\t// This looks for some generic markers in the request state and puts them into a log or send object\n\tprepareRequestContextOutputObject(pObjectToPopulate, pRequest, pRequestState, pError)\n\t{\n\t\t// Internally created errors supress stack traces\n\t\tif (pError)\n\t\t{\n\t\t\tpObjectToPopulate.Error = pError.message;\n\t\t\tpObjectToPopulate.Code = pError.code;\n\t\t\tpObjectToPopulate.StatusCode = pError.StatusCode;\n\n\t\t\tif (!pError.SuppressSoftwareTrace)\n\t\t\t{\n\t\t\t\tpObjectToPopulate.Stack = pError.stack;\n\t\t\t}\n\n\t\t\tif (pRequestState.hasOwnProperty('Record'))\n\t\t\t{\n\t\t\t\tpObjectToPopulate.Record = pRequestState.Record;\n\t\t\t}\n\n\t\t\tif (pRequestState.hasOwnProperty('Query') && (typeof(pRequestState.Query) == 'object'))\n\t\t\t{\n\t\t\t\tif (pRequestState.Query.query)\n\t\t\t\t{\n\t\t\t\t\tif (typeof(pRequestState.Query.query.body) == 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\tpObjectToPopulate.Query = pRequestState.Query.query.body;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((typeof(pRequestState.Query.query.parameters) == 'object'))\n\t\t\t\t\t{\n\t\t\t\t\t\tpObjectToPopulate.QueryParameters = pRequestState.Query.query.parameters;\n\n\t\t\t\t\t\tpObjectToPopulate.RebuiltQueryString = (typeof(pObjectToPopulate.Query) == 'string') ? pObjectToPopulate.Query : '';\n\n\t\t\t\t\t\t// This gnarly bit of code attempts to reconstruct a non prepared string version of the query, to help.\n\t\t\t\t\t\tlet tmpQueryParameterSet = Object.keys(pObjectToPopulate.QueryParameters);\n\t\t\t\t\t\tfor (let i = 0; i < tmpQueryParameterSet.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch(typeof(tmpQueryParameterSet[i]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\t\t\tpObjectToPopulate.RebuiltQueryString  = pObjectToPopulate.RebuiltQueryString.replace(new RegExp(`:${tmpQueryParameterSet[i]}\\\\b`, 'g'), `'${pObjectToPopulate.QueryParameters[tmpQueryParameterSet[i]]}'`);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t\t\t// TODO: This may need more ... nuance...\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tpObjectToPopulate.RebuiltQueryString  = pObjectToPopulate.RebuiltQueryString.replace(new RegExp(`:${tmpQueryParameterSet[i]}\\\\b`,'g'), pObjectToPopulate.QueryParameters[tmpQueryParameterSet[i]]);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pObjectToPopulate;\n\t}\n}\n\nmodule.exports = MeadowEndpointsControllerErrorBase;\n},{}],180:[function(require,module,exports){\nclass MeadowEndpointsControllerLogBase\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    // This is called whenever an endpoint is completed successfully\n\trequestCompletedSuccessfully(pRequest, pRequestState, pActionSummary)\n\t{\n\t\tthis._Controller.log.info(pActionSummary,\n\t\t\t{\n\t\t\t\tSessionID: pRequestState.SessionData.SessionID,\n\t\t\t\tRequestID: pRequest.RequestUUID,\n\t\t\t\tRequestURL: pRequest.url,\n\t\t\t\tScope: this._Controller.DAL.scope,\n\t\t\t\tAction: `${this._Controller.DAL.scope}-${pRequestState.Verb}`,\n\t\t\t\tVerb: pRequestState.Verb\n\t\t\t});\n\t}\n\n    // This is called whenever an endpoint is completed successfully\n\tlogRequestError(pRequest, pRequestState, pError)\n\t{\n\t\tlet tmpErrorLogData = (\n\t\t\t{\n\t\t\t\tSessionID: pRequestState.SessionData.SessionID,\n\t\t\t\tRequestID: pRequest.RequestUUID,\n\t\t\t\tRequestURL: pRequest.url,\n\t\t\t\tScope: this._Controller.DAL.scope,\n\t\t\t\tAction: `${this._Controller.DAL.scope}-${pRequestState.Verb}`,\n\t\t\t\tVerb: pRequestState.Verb,\n\t\t\t});\n\n\t\ttmpErrorLogData = this._Controller.ErrorHandler.prepareRequestContextOutputObject(tmpErrorLogData, pRequest, pRequestState, pError);\n\n\t\tthis._Controller.log.error(pError.message, tmpErrorLogData);\n\t}\n\n    trace(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = MeadowEndpointsControllerLogBase;\n},{}],181:[function(require,module,exports){\n/**\n* Meadow Endpoint Utility Class - Parse a Filter String and put it into a Query.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Meadow\n*/\n/**\n* Parse GET-passed Filter Strings, turn the results into proper Meadow query stanzas\n\n Take the filter and return an array of filter instructions\n Basic instruction anatomy:\n       INSTRUCTION~FIELD~OPERATOR~VALUE\n FOP - Filter Open Paren\n       FOP~0~(~0\n FCP - Filter Close Paren\n       FCP~0~)~0\n FBV - Filter By Value (left-side AND connected)\n       FBV~Category~EQ~Books\n       Possible comparisons:\n       * EQ - Equals To (=)\n       * NE - Not Equals To (!=)\n       * GT - Greater Than (>)\n       * GE - Greater Than or Equals To (>=)\n       * LT - Less Than (<)\n       * LE - Less Than or Equals To (<=)\n       * LK - Like (Like)\n       * IN - Is NULL\n       * NN - Is NOT NULL\n       * INN - IN list\n FBVOR - Filter By Value (left-side OR connected)\n FBL - Filter By List (value list, separated by commas)\n       FBL~Category~EQ~Books,Movies\n FBD - Filter by Date (exclude time)\n       FBD~UpdateDate~EQ~2015-10-01\n FSF - Filter Sort Field\n       FSF~Category~ASC~0\n       FSF~Category~DESC~0\n FDST - Filter by Distinct (adds distinct keyword to Read and Count queries)\n       FDST~0~0~0~\n\n This means: FBV~Category~EQ~Books~FBV~PublishedYear~GT~2000~FSF~PublishedYear~DESC~0\n             Filters down to ALL BOOKS PUBLUSHED AFTER 2000 IN DESCENDING ORDER\n*/\n\nclass MeadowEndpointsFilterParser\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    // Get the comparison operator for use in a query stanza\n    getFilterComparisonOperator(pFilterOperator)\n    {\n        let tmpOperator = '=';\n        switch(pFilterOperator)\n        {\n            case 'EQ':\n                tmpOperator = '=';\n                break;\n            case 'NE':\n                tmpOperator = '!=';\n                break;\n            case 'GT':\n                tmpOperator = '>';\n                break;\n            case 'GE':\n                tmpOperator = '>=';\n                break;\n            case 'LT':\n                tmpOperator = '<';\n                break;\n            case 'LE':\n                tmpOperator = '<=';\n                break;\n            case 'LK':\n                tmpOperator = 'LIKE';\n                break;\n            case 'NLK':\n                tmpOperator = 'NOT LIKE';\n                break;\n            case 'IN':\n                tmpOperator = 'IS NULL';\n                break;\n            case 'NN':\n                tmpOperator = 'IS NOT NULL';\n                break;\n            case 'INN':\n                tmpOperator = 'IN';\n                break;\n            case 'FOP':\n                tmpOperator = '(';\n                break;\n            case 'FCP':\n                tmpOperator = ')';\n                break;\n        }\n        return tmpOperator;\n    }\n\n    addFilterStanzaToQuery(pFilterStanza, pQuery)\n    {\n        if (!pFilterStanza.Instruction)\n        {\n            return false;\n        }\n\n        switch(pFilterStanza.Instruction)\n        {\n            case 'FBV':   // Filter by Value (left-side AND)\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value, getFilterComparisonOperator(pFilterStanza.Operator), 'AND');\n                break;\n\n            case 'FBVOR': // Filter by Value (left-side OR)\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value, getFilterComparisonOperator(pFilterStanza.Operator), 'OR');\n                break;\n\n            case 'FBL':   // Filter by List (left-side AND)\n                // Just split the value by comma for now.  May want to revisit better characters or techniques later.\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'AND');\n                break;\n\n            case 'FBLOR': // Filter by List (left-side OR)\n                // Just split the value by comma for now.  May want to revisit better characters or techniques later.\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'OR');\n                break;\n\n            case 'FBD': // Filter by Date (exclude time)\n                pQuery.addFilter(`DATE(${pFilterStanza.Field})`, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'AND', pFilterStanza.Field);\n                break;\n\n            case 'FBDOR': // Filter by Date (exclude time)\n                pQuery.addFilter(`DATE(${pFilterStanza.Field})`, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'OR', pFilterStanza.Field);\n                break;\n\n            case 'FSF':   // Filter Sort Field\n                const tmpSortDirection = (pFilterStanza.Operator === 'DESC') ? 'Descending' : 'Ascending';\n                pQuery.addSort({ Column: pFilterStanza.Field, Direction: tmpSortDirection });\n                break;\n\n            case 'FOP':   // Filter Open Paren\n                pQuery.addFilter('', '', '(');\n                break;\n\n            case 'FCP':   // Filter Close Paren\n                pQuery.addFilter('', '', ')');\n                break;\n\n            case 'FDST':   // Filter Distinct\n                // ensure we don't break if using an older foxhound version\n                if (pQuery.setDistinct)\n                {\n                    pQuery.setDistinct(true);\n                }\n                break;\n\n            default:\n                //console.log('Unparsable filter stanza.');\n                return false;\n                break;\n        }\n\n        // Be paranoid about the instruction\n        pFilterStanza.Instruction = false;\n        return true;\n    };\n\n    parseFilter(pFilterString, pQuery)\n    {\n        if (typeof(pFilterString) !== 'string')\n        {\n            return false;\n        }\n\n        const tmpFilterTerms = pFilterString.split('~');\n\n        if (tmpFilterTerms.length < 4)\n        {\n            return true;\n        }\n\n        let tmpFilterStanza = { Instruction: false };\n\n        for (let i = 0; i < tmpFilterTerms.length; i++)\n        {\n            switch(i % 4)\n            {\n                case 0:  // INSTRUCTION\n                    addFilterStanzaToQuery(tmpFilterStanza, pQuery);\n                    //console.log(i+' Instruction: '+tmpFilterTerms[i]);\n                    tmpFilterStanza = (\n                    {\n                        Instruction: tmpFilterTerms[i],\n                        Field: '',\n                        Operator: '',\n                        Value: ''\n                    });\n                    break;\n\n                case 1:  // FIELD\n                    //console.log(i+' Field:       '+tmpFilterTerms[i]);\n                    tmpFilterStanza.Field = tmpFilterTerms[i];\n                    break;\n\n                case 2:  // OPERATOR\n                    //console.log(i+' Operator:    '+tmpFilterTerms[i]);\n                    tmpFilterStanza.Operator = tmpFilterTerms[i];\n                    break;\n\n                case 3:  // VALUE\n                    //console.log(i+' Value:       '+tmpFilterTerms[i]);\n                    tmpFilterStanza.Value = tmpFilterTerms[i];\n                    break;\n            }\n        }\n\n        this.addFilterStanzaToQuery(tmpFilterStanza, pQuery);\n\n        return true;\n    };\n}\n\nmodule.exports = MeadowEndpointsFilterParser;\n},{}],182:[function(require,module,exports){\nclass MeadowEndpointsSessionMarshaler\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    getSessionData(pRequest)\n    {\n        let tmpSession = Object.assign({}, this._Controller.settings.MeadowEndpointsDefaultSessionObject);\n\n        switch (this._Controller.settings.MeadowEndpointsSessionDataSource || 'Request')\n        {\n            default:\n                this._LogController.warn(`Unknown session source configured: ${_SessionDataSource} - defaulting to Request for backward compatibility`);\n            case 'Request':\n                // noop - already set by orator-session\n                tmpSession = this._Controller.extend(tmpSession, pRequest.UserSession);\n                break;\n            case 'None':\n                break;\n            case 'Header':\n                try\n                {\n                    const tmpHeaderSessionString = pRequest.headers['x-trusted-session'];\n                    if (!tmpHeaderSessionString)\n                    {\n                        break;\n                    }\n                    tmpHeaderSession = JSON.parse(tmpHeaderSessionString);\n                    tmpSession = this._Controller.extend(tmpSession, pRequest.tmpHeaderSession);\n                }\n                catch (pError)\n                {\n                    this._LogController.error(`Meadow Endpoints attempted to process a Header Session String with value [${tmpHeaderSessionString}] and failed -- likely culprit is bad JSON.`)\n                }\n                break;\n        }\n\n        // Do we keep this here for backwards compatibility?\n        // Yes this makes sense here.\n        pRequest.UserSession = tmpSession;\n\n        return tmpSession;\n    }\n}\n\nmodule.exports = MeadowEndpointsSessionMarshaler;\n},{}],183:[function(require,module,exports){\n(function (setImmediate){(function (){\n/**\n* Meadow Endpoint Streamer - Stream an array of recods as JSON to an output stream.\n*/\nconst libAsyncEachSeries = require('async/eachSeries');\nconst JSONStream = require('JSONStream');\n\nclass MeadowEndpointsStreamRecordArray\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n\tchunk(pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n\n\tstreamRecordArray(pResponse, pRecords, fCallback)\n\t{\n\t\t// for meadow invoke, writeHead isn't provided, so just call send(), which is the shim it uses...\n\t\t// also, for small arrays, don't bother with the async serialization; this threshold could use tuning\n\t\tif (!pResponse.writeHead || !Array.isArray(pRecords) || pRecords.length < 2500)\n\t\t{\n\t\t\tpResponse.send(pRecords);\n\t\t\treturn fCallback();\n\t\t}\n\n\t\tpResponse.writeHead(200,\n\t\t{\n\t\t\t'content-type': 'application/json',\n\t\t});\n\n\t\tconst recordJsonMarshaller = JSONStream.stringify();\n\t\trecordJsonMarshaller.pipe(pResponse);\n\n\t\t// we write the records in chunks; doing one per loop is very inefficient, doing all is the same as not doing this at all\n\t\tlibAsyncEachSeries(this.chunk(pRecords, 1000), (pRecordChunk, fNext) =>\n\t\t{\n\t\t\tpRecordChunk.forEach(recordJsonMarshaller.write);\n\t\t\tsetImmediate(fNext);\n\t\t},\n\t\t(error) =>\n\t\t{\n\t\t\trecordJsonMarshaller.end();\n\t\t\tfCallback(error);\n\t\t});\n\t}\n}\n\nmodule.exports = MeadowEndpointsStreamRecordArray;\n}).call(this)}).call(this,require(\"timers\").setImmediate)\n\n},{\"JSONStream\":1,\"async/eachSeries\":4,\"timers\":165}],184:[function(require,module,exports){\n/**\n* Meadow Endpoint - Count a Record\n*/\nconst doAPIEndpointCount = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Count');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t\t{\n\t\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t\t}\n\t\t\t\telse if (pRequest.params.Filter)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Count-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doCount(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Result = {Count:pCount};\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.Result);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Delivered recordset count of ${tmpRequestState.Result.Count} for ${this.DAL.scope}.`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointCount;\n\n},{}],185:[function(require,module,exports){\n/**\n* Meadow Endpoint - Count a Record filtered by a single value\n*/\nconst doAPIEndpointCountBy = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'CountBy');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\ttmpRequestState.Query.addFilter(pRequest.params.ByField, pRequest.params.ByValue, '=', 'AND', 'RequestByField');\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`CountBy-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doCount(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Result = {Count:pCount};\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Delivered recordset count of '+tmpRequestState.Result.Count+'.');\n\t\t\t\tpResponse.send(tmpRequestState.Result);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\n\nmodule.exports = doAPIEndpointCountBy;\n},{}],186:[function(require,module,exports){\n/**\n* Meadow Endpoint - Create a set of Record in Bulk\n*/\n\nconst doCreate = require('./Meadow-Operation-Create.js');\n\nconst doAPIEndpointBulkCreate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'CreateBulk');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.CreatedRecords = [];\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (!Array.isArray(pRequest.body))\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Bulk record create failure - a valid array of records to create is required.', 500));\n\t\t\t}\n\t\t\tpRequest.RecordsToBulkCreate = pRequest.body;\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`CreateBulk-PreOperation`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tlibAsync.eachSeries(pRequest.RecordsToBulkCreate,\n\t\t\t\t(pRecord, fCallback) =>\n\t\t\t\t{\n\t\t\t\t\tdoCreate.call(this, pRecord, pRequest, tmpRequestState, pResponse, fCallback);\n\t\t\t\t}, fStageComplete);\n\t\t},\n\t\tfBehaviorInjector(`CreateBulk-PostOperation`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.CreatedRecords, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Created a record with ID '+pNewRecord[this.DAL.defaultIdentifier]+'.');\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointBulkCreate;\n},{\"./Meadow-Operation-Create.js\":188}],187:[function(require,module,exports){\n/**\n* Meadow Endpoint - Create a Record\n*/\nconst doCreate = require('./Meadow-Operation-Create.js');\n\nconst doAPIEndpointCreate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Create');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (typeof(pRequest.body) !== 'object')\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record create failure - a valid record is required.', 500));\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tdoCreate.call(this, pRequest.body, pRequest, tmpRequestState, pResponse, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (tmpRequestState.RecordCreateError)\n\t\t\t{\n\t\t\t\treturn fStageComplete(tmpRequestState.RecordCreateErrorObject);\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Created a ${this.DAL.scope} record ID ${tmpRequestState.Record.IDRecord}`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointCreate;\n},{\"./Meadow-Operation-Create.js\":188}],188:[function(require,module,exports){\n/**\n* Meadow Operation - Create a record function\n*/\nconst doCreate = function(pRecord, pRequest, pRequestState, pResponse, fCallback)\n{\n\t// This is a virtual operation\n\tlet tmpRequestState = cloneAsyncSafeRequestState(pRequestState, 'doCreate');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tif (!Array.isArray(tmpRequestState.ParentRequestState.CreatedRecords))\n\t{\n\t\ttmpRequestState.ParentRequestState.CreatedRecords = [];\n\t}\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.RecordToCreate = pRecord;\n\n\t\t\t//Make sure record gets created with a customerID\n\t\t\tif (!tmpRequestState.RecordToCreate.hasOwnProperty('IDCustomer') && this.DAL.jsonSchema.properties.hasOwnProperty('IDCustomer'))\n\t\t\t{\n\t\t\t\ttmpRequestState.RecordToCreate.IDCustomer = tmpRequestState.SessionData.CustomerID || 0;\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) => { this.BehaviorInjection.runBehavior(`Create-PreOperation`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\t// Prepare create query\n\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\ttmpRequestState.Query.addRecord(tmpRequestState.RecordToCreate);\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) => { this.BehaviorInjection.runBehavior(`Create-QueryConfiguration`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\t// Do the actual create operation with the DAL\n\t\t\tthis.DAL.doCreate(tmpRequestState.Query,\n\t\t\t\t(pError, pQuery, pReadQuery, pNewRecord) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t}\n\t\t\t\t\tif (!pNewRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError(`Error in DAL Create: No record returned from persistence engine.`, 500));\n\t\t\t\t\t}\n\n\t\t\t\t\ttmpRequestState.Record = pNewRecord;\n\n\t\t\t\t\treturn fStageComplete();\n\t\t\t\t});\n\t\t},\n\t\t(fStageComplete) => { return this.BehaviorInjection.runBehavior(`Create-PostOperation`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.ParentRequestState.CreatedRecords.push(tmpRequestState.Record);\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Created a record with ${this.DAL.defaultIdentifier} = ${tmpRequestState.Record[this.DAL.defaultIdentifier]}`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\tif (pError)\n\t\t{\n\t\t\ttmpRequestState.RecordToCreate.Error = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.RecordCreateError = true;\n\t\t\ttmpRequestState.ParentRequestState.RecordCreateErrorObject = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.CreatedRecords.push(tmpRequestState.RecordToCreate);\n\t\t}\n\n\t\treturn fCallback();\n\t});\n};\n\nmodule.exports = doCreate;\n},{}],189:[function(require,module,exports){\n/**\n* Meadow Endpoint - Delete a Record\n*/\nconst doAPIEndpointDelete = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Delete');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.IDRecord = 0;\n\ttmpRequestState.RecordCount = { Count:0 };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (typeof(pRequest.params.IDRecord) === 'string')\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.IDRecord = pRequest.params.IDRecord;\n\t\t\t\t}\n\t\t\t\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.IDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t\t\t\t}\n\t\t\t\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'string')\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.IDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t\t\t\t}\n\t\t\t\t// Although the Meadow delete behavior does allow multiple deletes, we require an identifier.\n\t\t\t\t// If a developer wants bulk delete, it will require a custom endpoint.\n\t\t\t\tif (tmpRequestState.IDRecord < 1)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record delete failure - a valid record ID is required in the passed-in record.', 500));\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpRequestState.IDRecord);\n\t\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Delete-QueryConfiguration`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Load the record so we can do security checks on it\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not found.', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Delete-PreOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Do the delete\n\t\t\t\tthis.DAL.doDelete(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// MySQL returns the number of rows deleted\n\t\t\t\t\t\ttmpRequestState.RecordCount.Count = pCount;\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Delete-PostOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.RecordCount);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Deleted ${tmpRequestState.RecordCount.Count} ${this.DAL.scope} records with ID ${tmpRequestState.IDRecord}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointDelete;\n},{}],190:[function(require,module,exports){\n/**\n* Meadow Endpoint - Undelete a Record\n*/\nconst doAPIEndpointUndelete = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Undelete');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\t\tvar tmpIDRecord = 0;\n\tif (typeof(pRequest.params.IDRecord) === 'string')\n\t{\n\t\ttmpIDRecord = pRequest.params.IDRecord;\n\t}\n\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'number')\n\t{\n\t\ttmpIDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t}\n\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'string')\n\t{\n\t\ttmpIDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t}\n\t// Although the undelete request does allow multiple undeletes, we require an identifier.\n\t// TODO: Decide if we want to keep this pattern similar to Delete, or, if we want to change it to allow bulk undeletes.\n\tif (tmpIDRecord < 1)\n\t{\n\t\treturn fStageComplete(this.ErrorHandler.getError('Record undelete failure - a valid record ID is required.', 500));\n\t}\n\n\ttmpRequestState.RecordCount = {Count:0};\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Validate that the schema has a deleted bit\n\t\t\t\tvar tmpSchema = this.DAL.schema;\n\t\t\t\tvar tmpHasDeletedBit = false;\n\t\t\t\tfor (let i = 0; i < tmpSchema.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (tmpSchema[i].Type == 'Deleted')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpHasDeletedBit = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!tmpHasDeletedBit)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No undelete bit on record.', 500));\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Now see if the record, with this identifier, for this user, exists with the deleted bit set to 1\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpIDRecord);\n\t\t\t\ttmpRequestState.Query.addFilter('Deleted', 1);\n\t\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Load the record so we can do security checks on it\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not found.', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Undelete-PreOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Do the undelete\n\t\t\t\tthis.DAL.doUndelete(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// MySQL returns the number of rows deleted\n\t\t\t\t\t\ttmpRequestState.RecordCount = {Count:pCount};\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Undelete-PostOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.RecordCount);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Undeleted '+tmpRequestState.RecordCount.Count+' records with ID '+tmpIDRecord+'.');\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointUndelete;\n},{}],191:[function(require,module,exports){\n/**\n* Meadow Endpoint - Read a Record\n*/\nconst doAPIEndpointRead = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Read');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Read-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!pRequest.params.IDRecord && pRequest.params.GUIDRecord)\n\t\t\t\t{\n\t\t\t\t\t// We use a custom name for this (RequestDefaultIdentifier) in case there is a query with a dot in the default identifier.\n\t\t\t\t\ttmpRequestState.RecordSearchCriteria = `${this.DAL.defaultGUIdentifier} = ${pRequest.params.GUIDRecord}`;\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultGUIdentifier, pRequest.params.GUIDRecord, '=', 'AND', 'RequestDefaultIdentifier');\n\t\t\t\t}\n\t\t\t\telse if (pRequest.params.IDRecord)\n\t\t\t\t{\n\t\t\t\t\t// We use a custon name for this (RequestDefaultIdentifier) in case there is a query with a dot in the default identifier.\n\t\t\t\t\ttmpRequestState.RecordSearchCriteria = `${this.DAL.defaultIdentifier} = ${pRequest.params.IDRecord}`;\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, pRequest.params.IDRecord, '=', 'AND', 'RequestDefaultIdentifier');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No ID Provided', 400));\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Read-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tthis.DAL.doRead(tmpRequestState.Query, (pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not Found', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcatch (pQueryError)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(pQueryError);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfBehaviorInjector(`Read-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read Record Where ${tmpRequestState.RecordSearchCriteria}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointRead;\n},{}],192:[function(require,module,exports){\n/**\n* Meadow Endpoint - Read a list of Records with a specified set of columns, distinct by those columns.\n*/\nconst marshalDistinctList = require('./Meadow-Marshal-DistinctList.js');\n\nconst doAPIEndpointReadDistinct = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadDistinct');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.DistinctColumns;\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query = this.DAL.query.setDistinct(true);\n\n\t\t\tlet tmpCap = false;\n\t\t\tlet tmpBegin = false;\n\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t{\n\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin, 10);\n\t\t\t}\n\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t{\n\t\t\t\ttmpCap = parseInt(pRequest.params.Cap, 10);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//maximum number of records to return by default on Read queries. Override via \"MeadowDefaultMaxCap\" fable setting.\n\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t}\n\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t{\n\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t}\n\t\t\telse if (pRequest.params.Filter)\n\t\t\t{\n\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t}\n\t\t\tif (typeof(pRequest.params.Columns) === 'string')\n\t\t\t{\n\t\t\t\ttmpRequestState.DistinctColumns = pRequest.params.Columns.split(',');\n\t\t\t\tif (!tmpRequestState.DistinctColumns)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete({Code:400, Message:'Columns to distinct on must be provided.'});\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setDataElements(tmpRequestState.DistinctColumns);\n\t\t\t}\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t},\n\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t{\n\t\t\tif (pRecords.length < 1)\n\t\t\t{\n\t\t\t\tpRecords = [];\n\t\t\t}\n\t\t\ttmpRequestState.Records = pRecords;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.ResultRecords = marshalDistinctList.call(this, tmpRequestState.Records, pRequest, tmpRequestState.DistinctColumns);\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.ResultRecords, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a recordset distinct lite list with ${tmpRequestState.ResultRecords.length} results.`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointReadDistinct;\n},{\"./Meadow-Marshal-DistinctList.js\":198}],193:[function(require,module,exports){\n/**\n* Meadow Endpoint - Read a list of lite Records (for Drop-downs and such)\n*/\nconst marshalLiteList = require('./Meadow-Marshal-LiteList.js');\n\nconst doAPIEndpointReadLite = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadsLite');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t// 1a. Get the records\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\t// TODO: Limit the query to the columns we need for the templated expression\n\n\t\t\t\tvar tmpCap = false;\n\t\t\t\tvar tmpBegin = false;\n\t\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin, 10);\n\t\t\t\t}\n\t\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpCap = parseInt(pRequest.params.Cap, 10);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//maximum number of records to return by default on Read queries. Override via \"MeadowDefaultMaxCap\" fable setting.\n\t\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t\t{\n\t\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t\t}\n\t\t\t\telse if (pRequest.params.Filter)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t\t},\n\t\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (pRecords.length < 1)\n\t\t\t\t{\n\t\t\t\t\tpRecords = [];\n\t\t\t\t}\n\t\t\t\ttmpRequestState.RawRecords = pRecords;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Records = marshalLiteList.call(this, tmpRequestState.RawRecords, pRequest, (typeof(pRequest.params.ExtraColumns) === 'string') ? pRequest.params.ExtraColumns.split(',') : []);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.Records, fNext);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a recordset lite list with ${tmpRequestState.Records.length} results`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError, pResultRecords) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadLite;\n},{\"./Meadow-Marshal-LiteList.js\":199}],194:[function(require,module,exports){\n/**\n* Meadow Endpoint - Read the Max Value of a Column in a Set\n*/\nconst doAPIEndpointReadMax = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadMax');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.ColumnName =  pRequest.params.ColumnName;\n\t\t\t\ttmpRequestState.Query.setSort({Column:tmpRequestState.ColumnName, Direction:'Descending'});\n\t\t\t\ttmpRequestState.Query.setCap(1);\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`ReadMax-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query, fStageComplete);\n\t\t\t},\n\t\t\t(pQuery, pRecord, fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!pRecord)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not Found', 404));\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.BehaviorInjection.runBehavior(`ReadMax-PostOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read max record of ${this.DAL.scope} on ${tmpRequestState.ColumnName}`);\n\t\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadMax;\n},{}],195:[function(require,module,exports){\n/**\n* Meadow Endpoint - Read a select list of Records (for Drop-downs and such)\n*/\nconst doAPIEndpointReadSelectList = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadsBy');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\tvar tmpCap = false;\n\t\t\t\tvar tmpBegin = false;\n\t\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin);\n\t\t\t\t}\n\t\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpCap = parseInt(pRequest.params.Cap);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t\t},\n\t\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (pRecords.length < 1)\n\t\t\t\t{\n\t\t\t\t\tpRecords = [];\n\t\t\t\t}\n\n\t\t\t\ttmpRequestState.Records = pRecords;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.SelectList = [];\n\n\t\t\t\tfor (var i = 0; i < tmpRequestState.Records.length; i++)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.SelectList.push\n\t\t\t\t\t(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHash: tmpRequestState.Records[i][this.DAL.defaultIdentifier],\n\t\t\t\t\t\t\tValue: this.BehaviorInjection.processTemplate('SelectList', {Record:tmpRequestState.Records[i]}, this.DAL.scope+' #<%= Record.'+this.DAL.defaultIdentifier+'%>')\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.SelectList, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a recordset lite list with ${tmpRequestState.SelectList.length} results.`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError, pResultRecords) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadSelectList;\n},{}],196:[function(require,module,exports){\n/**\n* Meadow Endpoint - Read a Set of Records\n*/\nconst doAPIEndpointReads = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Reads');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\tvar tmpCap = false;\n\t\t\tvar tmpBegin = false;\n\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t{\n\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin);\n\t\t\t}\n\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t{\n\t\t\t\ttmpCap = parseInt(pRequest.params.Cap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t}\n\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t{\n\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t}\n\t\t\telse if (pRequest.params.Filter)\n\t\t\t{\n\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t},\n\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t{\n\t\t\tif (!pRecords)\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No records found.', 404));\n\t\t\t}\n\t\t\ttmpRequestState.Records = pRecords;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`Reads-PostOperation`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.doStreamRecordArray(pResponse, tmpRequestState.Records, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Read a list of records.');\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointReads;\n},{}],197:[function(require,module,exports){\n/**\n* Meadow Endpoint - Read a Record\n*/\nconst doAPIEndpointReadsBy = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadsBy');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t// 1. Construct the Query\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\tvar tmpCap = false;\n\t\t\t\tvar tmpBegin = false;\n\t\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin);\n\t\t\t\t}\n\t\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpCap = parseInt(pRequest.params.Cap);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//maximum number of records to return by default on Read queries. Override via \"MeadowDefaultMaxCap\" fable setting.\n\t\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tfunction addField(pByField, pByValue)\n\t\t\t\t{\n\t\t\t\t\tif (pByValue.constructor === Array)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Query.addFilter(pByField, pByValue, 'IN', 'AND', 'RequestByField');\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Query.addFilter(pByField, pByValue, '=', 'AND', 'RequestByField');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar tmpFilters = pRequest.params.Filters;\n\t\t\t\tif (tmpFilters &&\n\t\t\t\t\ttmpFilters.constructor === Array)\n\t\t\t\t{\n\t\t\t\t\ttmpFilters.forEach(function(filter)\n\t\t\t\t\t{\n\t\t\t\t\t\taddField(filter.ByField, filter.ByValue);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\taddField(pRequest.params.ByField, pRequest.params.ByValue);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doReads(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecords) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecords)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No records found.', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Records = pRecords;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.Records, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a list of records by ${pRequest.params.ByField} = ${pRequest.params.ByValue}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t// 7. Return the results to the user\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadsBy;\n},{}],198:[function(require,module,exports){\n/**\n* Meadow Operation - Marshal an array of records into a distinct list\n*/\nconst marshalDistinctList = function(pRecords, pRequest, pFieldList)\n{\n\tif (pRecords.length < 1)\n\t\treturn [];\n\n\tlet tmpDistinctList = [];\n\t// Allow the caller to pass in a list of fields.\n\tlet tmpFieldList = (typeof(pFieldList) !== 'undefined') ? pFieldList : [];\n\n\t// See if this record has a GUID in the schema\n\tlet tmpGUID = (this.DAL.defaultGUIdentifier && this.DAL.defaultGUIdentifier.length > 0) ? this.DAL.defaultGUIdentifier : false;\n\t// Peek at the first record to check for updatedate\n\tlet tmpHasUpdateDate = (pRecords[0].hasOwnProperty('UpdateDate')) ? true : false;\n\t//Include all GUID and ID fields on the record\n\tlet tmpRecordFields = Object.keys(pRecords[0]);\n\n\tlet h = 0;\n\twhile (h < tmpFieldList.length)\n\t{\n\t\t// Remove any fields in the list that aren't in the first record.\n\t\tif (!pRecords[0].hasOwnProperty(tmpFieldList[0]))\n\t\t\ttmpFieldList.splice(h, 1);\n\t\telse\n\t\t\th++;\n\t}\n\n\tfor (let i = 0; i < pRecords.length; i++)\n\t{\n\t\tlet tmpDistinctRecord = { };\n\n\t\ttmpFieldList.forEach(\n\t\t\t(pField) =>\n\t\t\t{\n\t\t\t\ttmpDistinctRecord[pField] = pRecords[i][pField];\n\t\t\t});\n\n\t\ttmpDistinctList.push(tmpDistinctRecord);\n\t}\n\n\treturn tmpDistinctList;\n};\n\nmodule.exports = marshalDistinctList;\n},{}],199:[function(require,module,exports){\n/**\n* Meadow Operation - Marshal an array of records into a lite list\n*/\nconst marshalLiteList = function(pRecords, pRequest, pFieldList)\n{\n\tif (pRecords.length < 1)\n\t\treturn [];\n\n\tlet tmpLiteList = [];\n\t// Allow the caller to pass in a list of fields.\n\tlet tmpFieldList = (typeof(pFieldList) !== 'undefined') ? pFieldList : [];\n\n\t// See if this record has a GUID in the schema\n\tlet tmpGUID = (this.DAL.defaultGUIdentifier && this.DAL.defaultGUIdentifier.length > 0) ? this.DAL.defaultGUIdentifier : false;\n\t// Peek at the first record to check for updatedate\n\tlet tmpHasUpdateDate = (pRecords[0].hasOwnProperty('UpdateDate')) ? true : false;\n\t//Include all GUID and ID fields on the record\n\tlet tmpRecordFields = Object.keys(pRecords[0]);\n\ttmpRecordFields.forEach(\n\t\t(pField) =>\n\t\t{\n\t\t\tif (pField.indexOf('ID') === 0 ||\n\t\t\t\tpField.indexOf('GUID') === 0 ||\n\t\t\t\tpField == 'CreatingIDUser') //we should always include owner info\n\t\t\t{\n\t\t\t\ttmpFieldList.push(pField);\n\t\t\t}\n\t\t});\n\n\tlet h = 0;\n\twhile (h < tmpFieldList.length)\n\t{\n\t\t// Remove any fields in the list that aren't in the first record.\n\t\tif (!pRecords[0].hasOwnProperty(tmpFieldList[0]))\n\t\t\ttmpFieldList.splice(h, 1);\n\t\telse\n\t\t\th++;\n\t}\n\n\tfor (let i = 0; i < pRecords.length; i++)\n\t{\n\t\tlet tmpLiteRecord = (\n\t\t\t{\n\t\t\t\tValue: this.BehaviorInjection.processTemplate('SelectList', {Record:pRecords[i]}, this.DAL.scope+' #<%= Record.'+this.DAL.defaultIdentifier+'%>')\n\t\t\t});\n\t\ttmpLiteRecord[this.DAL.defaultIdentifier] = pRecords[i][this.DAL.defaultIdentifier];\n\n\t\tif (tmpGUID)\n\t\t\ttmpLiteRecord[tmpGUID] = pRecords[i][tmpGUID];\n\t\tif (tmpHasUpdateDate)\n\t\t\ttmpLiteRecord['UpdateDate'] = pRecords[i].UpdateDate;\n\n\t\ttmpFieldList.forEach(\n\t\t\t(pField) =>\n\t\t\t{\n\t\t\t\ttmpLiteRecord[pField] = pRecords[i][pField];\n\t\t\t});\n\n\t\ttmpLiteList.push(tmpLiteRecord);\n\t}\n\n\treturn tmpLiteList;\n};\n\nmodule.exports = marshalLiteList;\n},{}],200:[function(require,module,exports){\n/**\n* Meadow Endpoint - Get a New, empty Record\n*/\nconst doAPIEndpointNew = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'New');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\tfBehaviorInjector(`New-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// If during the PreOperation this was set, we can\n\t\t\t\tif (!tmpRequestState.EmptyEntityRecord)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.EmptyEntityRecord = this.extend({}, this.DAL.schemaFull.defaultObject);\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`New-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.EmptyEntityRecord);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Delivered New ${this.DAL.scope} Record`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointNew;\n},{}],201:[function(require,module,exports){\n/**\n* Meadow Endpoint - Get the Record Schema\n*/\nconst doAPIEndpointSchema = function (pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Schema');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\tfBehaviorInjector(`Schema-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// If during the PreOperation this was set, we won't overwrite\n\t\t\t\tif (!pRequest.JSONSchema)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.JSONSchema = this.extend({}, this.DAL.jsonSchema);\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Schema-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.JSONSchema);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Delivered JSONSchema for ${this.DAL.scope}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointSchema;\n},{}],202:[function(require,module,exports){\n/**\n* Meadow Endpoint - Validate a Record\n*/\nconst doAPIEndpointValidate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Validate');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\tfBehaviorInjector(`Validate-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (typeof(pRequest.body) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record validate failure - a valid JSON object is required.', 500));\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Record = pRequest.body;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.RecordValidation = this.DAL.schemaFull.validateObject(tmpRecord);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Validate-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.RecordValidation);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Validated Record for ${this.DAL.scope} - ${tmpRequestState.RecordValidation}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointValidate;\n},{}],203:[function(require,module,exports){\n/**\n* Meadow Endpoint - Update a set of Records\n*/\nconst doUpdate = require('./Meadow-Operation-Update.js');\n\nconst doAPIEndpointUpdate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'UpdateBulk');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.UpdatedRecords = [];\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!Array.isArray(pRequest.body))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record update failure - a valid record is required.', 500));\n\t\t\t\t}\n\n\t\t\t\tpRequest.BulkRecords = pRequest.body;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tlibAsync.eachSeries(pRequest.BulkRecords,\n\t\t\t\t\t(pRecord, fCallback) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tdoUpdate(pRecord, pRequest, tmpRequestState, pResponse, fCallback);\n\t\t\t\t\t}, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, pRequest.UpdatedRecords, fStageComplete);\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\n\nmodule.exports = doAPIEndpointUpdate;\n},{\"./Meadow-Operation-Update.js\":205}],204:[function(require,module,exports){\n/**\n* Meadow Endpoint - Update a Record\n*/\nconst doUpdate = require('./Meadow-Operation-Update.js');\n\nconst doAPIEndpointUpdate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Update');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (typeof(pRequest.body) !== 'object')\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record update failure - a valid record is required.', 400));\n\t\t\t}\n\t\t\tif (pRequest.body[this.DAL.defaultIdentifier] < 1)\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record update failure - a valid record ID is required in the passed-in record.', 400));\n\t\t\t}\n\n\t\t\ttmpRequestState.Record = pRequest.body;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tdoUpdate.call(this, pRequest.body, pRequest, tmpRequestState, pResponse, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (tmpRequestState.RecordUpdateError)\n\t\t\t{\n\t\t\t\treturn fStageComplete(tmpRequestState.RecordUpdateErrorObject);\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointUpdate;\n\n},{\"./Meadow-Operation-Update.js\":205}],205:[function(require,module,exports){\n/**\n* Meadow Operation - Update a record\n*/\nconst doUpdate = function(pRecordToModify, pRequest, pRequestState, pResponse, fCallback, pOptionalCachedUpdatingRecord)\n{\n\t// This is a virtual operation\n\tlet tmpRequestState = cloneAsyncSafeRequestState(pRequestState, 'doUpdate');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\t// If there is not a default identifier or cached record, fail\n\tif ((pRecordToModify[this.DAL.defaultIdentifier] < 1) && (typeof(pOptionalCachedUpdatingRecord) === 'undefined'))\n\t{\n\t\treturn fCallback('Record update failure - a valid record ID is required in the passed-in record.');\n\t}\n\n\tif (!Array.isArray(tmpRequestState.ParentRequestState.UpdatedRecords))\n\t{\n\t\ttmpRequestState.ParentRequestState.UpdatedRecords = [];\n\t}\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.RecordToModify = pRecordToModify;\n\n\t\t\tif (typeof(pOptionalCachedUpdatingRecord) !== 'undefined')\n\t\t\t{\n\t\t\t\t// Use the cached updating record instead of reading a record.\n\t\t\t\ttmpRequestState.OriginalRecord = pOptionalCachedUpdatingRecord;\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpRequestState.RecordToModify[this.DAL.defaultIdentifier]);\n\n\t\t\t\t// Load the record so we can do security checks on it\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not Found', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.OriginalRecord = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\ttmpRequestState.Query.addRecord(tmpRequestState.RecordToModify);\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.DAL.doUpdate(tmpRequestState.Query,\n\t\t\t\t(pError, pQuery, pReadQuery, pRecord) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t}\n\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete('Error updating a record.');\n\t\t\t\t\t}\n\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\treturn fStageComplete();\n\t\t\t\t});\n\t\t},\n\t\t(fStageComplete) => { return this.BehaviorInjection.runBehavior(`Update-PostOperation`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.ParentRequestState.UpdatedRecords.push(tmpRequestState.Record);\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Updated record with ID ${tmpRequestState.Record[this.DAL.defaultIdentifier]}`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t], (pError) =>\n\t{\n\t\tif (pError)\n\t\t{\n\t\t\ttmpRequestState.UpdatingRecord.Error = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.RecordUpdateError = true;\n\t\t\ttmpRequestState.ParentRequestState.RecordUpdateErrorObject = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.UpdatedRecords.push(tmpRequestState.RecordToCreate);\n\t\t}\n\n\t\treturn fCallback();\n\t});\n};\n\nmodule.exports = doUpdate;\n},{}],206:[function(require,module,exports){\n/**\n* Meadow Endpoint - Upsert a set of Records\n*/\nconst doUpsert = require('./Meadow-Operation-Upsert.js');\n\nconst marshalLiteList = require('../read/Meadow-Marshal-LiteList.js');\n\nconst doAPIEndpointUpserts = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'UpsertBulk');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.CreatedRecords = [];\n\ttmpRequestState.UpdatedRecords = [];\n\ttmpRequestState.UpsertedRecords = [];\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!Array.isArray(pRequest.body))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record upsert failure - a valid record is required.', 500));\n\t\t\t\t}\n\n\t\t\t\ttmpRequestState.BulkRecords = pRequest.body;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tlibAsync.eachSeries(tmpRequestState.BulkRecords,\n\t\t\t\t\t(pRecord, fCallback) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tdoUpsert.call(this, pRecord, pRequest, tmpRequestState, pResponse, fCallback);\n\t\t\t\t\t}, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, marshalLiteList.call(this, pRequest.UpsertedRecords, pRequest), fStageComplete);\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\nmodule.exports = doAPIEndpointUpserts;\n},{\"../read/Meadow-Marshal-LiteList.js\":199,\"./Meadow-Operation-Upsert.js\":208}],207:[function(require,module,exports){\n/**\n* Meadow Endpoint - Upsert (Insert OR Update) a Record\n*/\nvar doUpsert = require('./Meadow-Operation-Upsert.js');\n\nvar doAPIEndpointUpsert = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Upsert');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\t// Configure the request for the generic create & update operations\n\ttmpRequestState.CreatedRecords = [];\n\ttmpRequestState.UpdatedRecords = [];\n\ttmpRequestState.UpsertedRecords = [];\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t//1. Validate request body to ensure it is a valid record\n\t\t\t\tif (typeof(tmpRequestState.body) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record upsert failure - a valid record is required.', 500));\n\t\t\t\t}\n\n\t\t\t\ttmpRequestState.RecordToUpsert = pRequest.body;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tdoUpsert.call(this, tmpRequestState.RecordToUpsert, pRequest, tmpRequestState, pResponse, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (tmpRequestState.RecordUpsertError)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(tmpRequestState.RecordUpsertErrorMessage);\n\t\t\t\t}\n\t\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\n\nmodule.exports = doAPIEndpointUpsert;\n},{\"./Meadow-Operation-Upsert.js\":208}],208:[function(require,module,exports){\n/**\n* Meadow Operation - Upsert a record\n*/\nconst doCreate = require('../create/Meadow-Operation-Create.js');\nconst doUpdate = require('../update/Meadow-Operation-Update.js');\n\nconst doUpsert = function(pRecordToUpsert, pRequest, pRequestState, pResponse, fCallback)\n{\n\tlet tmpRequestState = this.cloneAsyncSafeRequestState(pRequest, 'Upsert');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\t// Prepare to gather requirements for upserting\n\t\t\t\ttmpRequestState.Record = pRecordToUpsert;\n\n\t\t\t\t// This operation will be create only if there is no GUID or ID in the record bundle\n\t\t\t\ttmpRequestState.UpsertCreateOnly = true;\n\n\t\t\t\t// See if there is a default identifier or default GUIdentifier\n\t\t\t\tif ((typeof(tmpRequestState.Record[this.DAL.defaultGUIdentifier]) !== 'undefined') && tmpRequestState.Record[this.DAL.defaultGUIdentifier].length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultGUIdentifier, tmpRequestState.Record[this.DAL.defaultGUIdentifier]);\n\t\t\t\t\ttmpRequestState.UpsertCreateOnly = false;\n\t\t\t\t}\n\t\t\t\tif ((typeof(tmpRequestState.Record[this.DAL.defaultIdentifier]) !== 'undefined') && (tmpRequestState.Record[this.DAL.defaultIdentifier] > 0))\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpRequestState.Record[this.DAL.defaultIdentifier]);\n\t\t\t\t\ttmpRequestState.UpsertCreateOnly = false;\n\t\t\t\t}\n\n\t\t\t\tif (tmpRequestState.UpsertCreateOnly)\n\t\t\t\t{\n\t\t\t\t\tdoCreate.call(this, tmpRequestState.Record, pRequest, pResponse, fStageComplete);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Return the error, because there was an error.\n\t\t\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!pError && !pRecord)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Record not found -- do a create.\n\t\t\t\t\t\t\t\tdoCreate.call(this, tmpRequestState.Record, pRequest, pResponse, fStageComplete);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Set the default ID in the passed-in record if it doesn't exist..\n\t\t\t\t\t\t\t\tif (!tmpRequestState.Record.hasOwnProperty(this.DAL.defaultIdentifier))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmpRequestState.Record[this.DAL.defaultIdentifier] = pRecord[this.DAL.defaultIdentifier];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// If the found record does not match the passed ID --- what the heck?!\n\t\t\t\t\t\t\t\tif (tmpRequestState.Record[this.DAL.defaultIdentifier] != pRecord[this.DAL.defaultIdentifier])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record IDs do not match', 500));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Record found -- do an update.  Use the cached record, though.\n\t\t\t\t\t\t\t\tdoUpdate.call(this, tmpRequestState.Record, pRequest, pResponse, fStageComplete, pRecord);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Now stuff the record into the upserted array\n\t\t\t\tpRequest.UpsertedRecords.push(tmpRequestState.Record);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpRecordToUpsert.Error = 'Error upserting record:'+pError;\n\t\t\t\ttmpRequestState.RecordUpsertError = true;\n\t\t\t\ttmpRequestState.RecordUpsertErrorMessage = pError;\n\t\t\t\tpRequest.UpsertedRecords.push(pRecordToUpsert);\n\t\t\t\tpRequest.CommonServices.log.error('Error upserting record:'+pError, {SessionID:pRequest.UserSession.SessionID, RequestID:pRequest.RequestUUID, RequestURL:pRequest.url, Action:this.DAL.scope+'-'+pRequest.MeadowOperation, Stack: pError.stack }, pRequest);\n\t\t\t}\n\n\t\t\treturn fCallback();\n\t\t});\n};\n\nmodule.exports = doUpsert;\n},{\"../create/Meadow-Operation-Create.js\":188,\"../update/Meadow-Operation-Update.js\":205}]},{},[175])(175)\n});\n\n","'use strict'\n\nvar Parser = require('jsonparse')\n  , through = require('through')\n\nvar bufferFrom = Buffer.from && Buffer.from !== Uint8Array.from\n\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n\n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\nexports.parse = function (path, map) {\n  var header, footer\n  var parser = new Parser()\n  var stream = through(function (chunk) {\n    if('string' === typeof chunk)\n      chunk = bufferFrom ? Buffer.from(chunk) : new Buffer(chunk)\n    parser.write(chunk)\n  },\n  function (data) {\n    if(data)\n      stream.write(data)\n    if (header)\n        stream.emit('header', header)\n    if (footer)\n      stream.emit('footer', footer)\n    stream.queue(null)\n  })\n\n  if('string' === typeof path)\n    path = path.split('.').map(function (e) {\n      if (e === '$*')\n        return {emitKey: true}\n      else if (e === '*')\n        return true\n      else if (e === '') // '..'.split('.') returns an empty string\n        return {recurse: true}\n      else\n        return e\n    })\n\n\n  var count = 0, _key\n  if(!path || !path.length)\n    path = null\n\n  parser.onValue = function (value) {\n    if (!this.root)\n      stream.root = value\n\n    if(! path) return\n\n    var i = 0 // iterates on path\n    var j  = 0 // iterates on stack\n    var emitKey = false;\n    var emitPath = false;\n    while (i < path.length) {\n      var key = path[i]\n      var c\n      j++\n\n      if (key && !key.recurse) {\n        c = (j === this.stack.length) ? this : this.stack[j]\n        if (!c) return\n        if (! check(key, c.key)) {\n          setHeaderFooter(c.key, value)\n          return\n        }\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++\n      } else {\n        i++\n        var nextKey = path[i]\n        if (! nextKey) return\n        while (true) {\n          c = (j === this.stack.length) ? this : this.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(this.stack[j]))\n              this.stack[j].value = null\n            break\n          } else {\n            setHeaderFooter(c.key, value)\n          }\n          j++\n        }\n      }\n\n    }\n\n    // emit header\n    if (header) {\n      stream.emit('header', header);\n      header = false;\n    }\n    if (j !== this.stack.length) return\n\n    count ++\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])\n    var data = value\n    if(null != data)\n      if(null != (data = map ? map(data, actualPath) : data)) {\n        if (emitKey || emitPath) {\n          data = { value: data };\n          if (emitKey)\n            data[\"key\"] = this.key;\n          if (emitPath)\n            data[\"path\"] = actualPath;\n        }\n\n        stream.queue(data)\n      }\n    if (this.value) delete this.value[this.key]\n    for(var k in this.stack)\n      if (!Object.isFrozen(this.stack[k]))\n        this.stack[k].value = null\n  }\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if(!path)\n          stream.queue(stream.root)\n        count = 0;\n        stream.root = null;\n      }\n    }\n  }\n\n  parser.onError = function (err) {\n    if(err.message.indexOf(\"at position\") > -1)\n      err.message = \"Invalid JSON (\" + err.message + \")\";\n    stream.emit('error', err)\n  }\n\n  return stream\n\n  function setHeaderFooter(key, value) {\n    // header has not been emitted yet\n    if (header !== false) {\n      header = header || {}\n      header[key] = value\n    }\n\n    // footer has not been emitted yet but header has\n    if (footer !== false && header === false) {\n      footer = footer || {}\n      footer[key] = value\n    }\n  }\n}\n\nfunction check (x, y) {\n  if ('string' === typeof x)\n    return y == x\n  else if (x && 'function' === typeof x.exec)\n    return x.exec(y)\n  else if ('boolean' === typeof x || 'object' === typeof x)\n    return x\n  else if ('function' === typeof x)\n    return x(y)\n  return false\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '[\\n'\n    sep = '\\n,\\n'\n    cl = '\\n]\\n'\n\n  }\n\n  //else, what ever you like\n\n  var stream\n    , first = true\n    , anyData = false\n  stream = through(function (data) {\n    anyData = true\n    try {\n      var json = JSON.stringify(data, null, indent)\n    } catch (err) {\n      return stream.emit('error', err)\n    }\n    if(first) { first = false ; stream.queue(op + json)}\n    else stream.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData)\n      stream.queue(op)\n    stream.queue(cl)\n    stream.queue(null)\n  })\n\n  return stream\n}\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n\n    op = '{\\n'\n    sep = '\\n,\\n'\n    cl = '\\n}\\n'\n\n  }\n\n  //else, what ever you like\n\n  var first = true\n  var anyData = false\n  var stream = through(function (data) {\n    anyData = true\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)\n    if(first) { first = false ; this.queue(op + json)}\n    else this.queue(sep + json)\n  },\n  function (data) {\n    if(!anyData) this.queue(op)\n    this.queue(cl)\n\n    this.queue(null)\n  })\n\n  return stream\n}\n\n\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _isObject = require('lodash/isObject');\n\nvar _isObject2 = _interopRequireDefault(_isObject);\n\nvar _initialParams = require('./internal/initialParams');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if ((0, _isObject2.default)(result) && typeof result.then === 'function') {\n            result.then(function (value) {\n                invokeCallback(callback, null, value);\n            }, function (err) {\n                invokeCallback(callback, err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (e) {\n        (0, _setImmediate2.default)(rethrow, e);\n    }\n}\n\nfunction rethrow(error) {\n    throw error;\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = eachLimit;\n\nvar _eachOfLimit = require('./internal/eachOfLimit');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _withoutIndex = require('./internal/withoutIndex');\n\nvar _withoutIndex2 = _interopRequireDefault(_withoutIndex);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit(coll, limit, iteratee, callback) {\n  (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachLimit = require('./eachLimit');\n\nvar _eachLimit2 = _interopRequireDefault(_eachLimit);\n\nvar _doLimit = require('./internal/doLimit');\n\nvar _doLimit2 = _interopRequireDefault(_doLimit);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nexports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nexports.default = {};\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = doLimit;\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _eachOfLimit;\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _once = require('./once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _breakLoop = require('./breakLoop');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = (0, _once2.default)(callback || _noop2.default);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function () /*...args, callback*/{\n        var args = (0, _slice2.default)(arguments);\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    };\n};\n\nvar _slice = require('./slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = iterator;\n\nvar _isArrayLike = require('lodash/isArrayLike');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nvar _keys = require('lodash/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = (0, _keys2.default)(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? { value: obj[key], key: key } : null;\n    };\n}\n\nfunction iterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function () {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.hasNextTick = exports.hasSetImmediate = undefined;\nexports.fallback = fallback;\nexports.wrap = wrap;\n\nvar _slice = require('./slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return function (fn /*, ...args*/) {\n        var args = (0, _slice2.default)(arguments, 1);\n        defer(function () {\n            fn.apply(null, args);\n        });\n    };\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = slice;\nfunction slice(arrayLike, start) {\n    start = start | 0;\n    var newLen = Math.max(arrayLike.length - start, 0);\n    var newArr = Array(newLen);\n    for (var idx = 0; idx < newLen; idx++) {\n        newArr[idx] = arrayLike[start + idx];\n    }\n    return newArr;\n}\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _withoutIndex;\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (tasks, callback) {\n    callback = (0, _once2.default)(callback || _noop2.default);\n    if (!(0, _isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        args.push((0, _onlyOnce2.default)(next));\n        task.apply(null, args);\n    }\n\n    function next(err /*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask((0, _slice2.default)(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _once = require('./internal/once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _slice = require('./internal/slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nvar _onlyOnce = require('./internal/onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */","'use strict';\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","'use strict';\n\nvar isCallable = require('is-callable');\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n","/**\n* FoxHound Query Generation Library\n* @license MIT\n* @author Steven Velozo <steven@velozo.com>\n*/\n\n// Load our base parameters skeleton object\nconst baseParameters = require('./Parameters.js');\n\nvar FoxHound = function()\n{\n\tfunction createNew(pFable, pFromParameters)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pFable) !== 'object') || !('fable' in pFable))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\n\t\tvar _Fable = pFable;\n\n\t\t// The default parameters config object, used as a template for all new\n\t\t// queries created from this query.\n\t\tvar _DefaultParameters = (typeof(pFromParameters) === 'undefined') ? {} : pFromParameters;\n\n\t\t// The parameters config object for the current query.  This is the only\n\t\t// piece of internal state that is important to operation.\n\t\tvar _Parameters = false;\n\n\t\tvar _Dialects = require('./Foxhound-Dialects.js');\n\n\t\t// The unique identifier for a query\n\t\tvar _UUID = _Fable.getUUID();\n\n\t\t// The log level, for debugging chattiness.\n\t\tvar _LogLevel = 0;\n\n\t\t// The dialect to use when generating queries\n\t\tvar _Dialect = false;\n\n\t\t/**\n\t\t* Clone the current FoxHound Query into a new Query object, copying all\n\t\t* parameters as the new default.  Clone also copies the log level.\n\t\t*\n\t\t* @method clone\n\t\t* @return {Object} Returns a cloned Query.  This is still chainable.\n\t\t*/\n\t\tvar clone = function()\n\t\t{\n\t\t\tvar tmpFoxHound = createNew(_Fable, baseParameters)\n\t\t\t\t.setScope(_Parameters.scope)\n\t\t\t\t.setBegin(_Parameters.begin)\n\t\t\t\t.setCap(_Parameters.cap);\n\n\t\t\t// Schema is the only part of a query that carries forward.\n\t\t\ttmpFoxHound.query.schema = _Parameters.query.schema;\n\n\t\t\tif (_Parameters.dataElements)\n\t\t\t{\n\t\t\t\ttmpFoxHound.parameters.dataElements = _Parameters.dataElements.slice(); // Copy the array of dataElements\n\t\t\t}\n\t\t\tif (_Parameters.sort)\n\t\t\t{\n\t\t\t\ttmpFoxHound.parameters.sort = _Parameters.sort.slice(); // Copy the sort array.\n\t\t\t\t// TODO: Fix the side affect nature of these being objects in the array .. they are technically clones of the previous.\n\t\t\t}\n\t\t\tif (_Parameters.filter)\n\t\t\t{\n\t\t\t\ttmpFoxHound.parameters.filter = _Parameters.filter.slice(); // Copy the filter array.\n\t\t\t\t// TODO: Fix the side affect nature of these being objects in the array .. they are technically clones of the previous.\n\t\t\t}\n\n\t\t\treturn tmpFoxHound;\n\t\t};\n\n\n\t\t/**\n\t\t* Reset the parameters of the FoxHound Query to the Default.  Default\n\t\t* parameters were set during object construction.\n\t\t*\n\t\t* @method resetParameters\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar resetParameters = function()\n\t\t{\n\t\t\t_Parameters = _Fable.Utility.extend({}, baseParameters, _DefaultParameters);\n\t\t\t_Parameters.query = ({\n\t\t\t\tdisableAutoIdentity: false,\n\t\t\t\tdisableAutoDateStamp: false,\n\t\t\t\tdisableAutoUserStamp: false,\n\t\t\t\tdisableDeleteTracking: false,\n\t\t\t\tbody: false,\n\t\t\t\tschema: false,   // The schema to intersect with our records\n\t\t\t\tIDUser: 0,       // The user to stamp into records\n\t\t\t\tUUID: _Fable.getUUID(), // A UUID for this record\n\t\t\t\trecords: false,  // The records to be created or changed\n\t\t\t\tparameters: {}\n\t\t\t});\n\n\t\t\t_Parameters.result = ({\n\t\t\t\texecuted: false, // True once we've run a query.\n\t\t\t\tvalue: false,    // The return value of the last query run\n\t\t\t\t// Updated below due to changes in how Async.js responds to a false value here\n\t\t\t\terror: undefined // The error message of the last run query\n\t\t\t});\n\n\t\t\treturn this;\n\t\t};\n\t\tresetParameters();\n\n\t\t/**\n\t\t* Reset the parameters of the FoxHound Query to the Default.  Default\n\t\t* parameters were set during object construction.\n\t\t*\n\t\t* @method mergeParameters\n\t\t* @param {Object} pFromParameters A Parameters Object to merge from\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar mergeParameters = function(pFromParameters)\n\t\t{\n\t\t\t_Parameters = _Fable.Utility.extend({}, _Parameters, pFromParameters);\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the the Logging level.\n\t\t*\n\t\t* The log levels are:\n\t\t*    0  -  Don't log anything\n\t\t*    1  -  Log queries\n\t\t*    2  -  Log queries and non-parameterized queries\n\t\t*    3  -  Log everything\n\t\t*\n\t\t* @method setLogLevel\n\t\t* @param {Number} pLogLevel The log level for our object\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setLogLevel = function(pLogLevel)\n\t\t{\n\t\t\tvar tmpLogLevel = 0;\n\n\t\t\tif (typeof(pLogLevel) === 'number' && (pLogLevel % 1) === 0)\n\t\t\t{\n\t\t\t\ttmpLogLevel = pLogLevel;\n\t\t\t}\n\n\t\t\t_LogLevel = tmpLogLevel;\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the Scope for the Query.  *Scope* is the source for the data being\n\t\t* pulled.  In TSQL this would be the _table_, whereas in MongoDB this\n\t\t* would be the _collection_.\n\t\t*\n\t\t* A scope can be either a string, or an array (for JOINs and such).\n\t\t*\n\t\t* @method setScope\n\t\t* @param {String} pScope A Scope for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setScope = function(pScope)\n\t\t{\n\t\t\tvar tmpScope = false;\n\n\t\t\tif (typeof(pScope) === 'string')\n\t\t\t{\n\t\t\t\ttmpScope = pScope;\n\t\t\t}\n\t\t\telse if (pScope !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Scope set failed.  You must pass in a string or array.', {queryUUID:_UUID, parameters:_Parameters, invalidScope:pScope});\n\t\t\t}\n\n\t\t\t_Parameters.scope = tmpScope;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Scope set: '+tmpScope, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set whether the query returns DISTINCT results.\n\t\t* For count queries, returns the distinct for the selected fields, or all fields in the base table by default.\n\t\t*\n\t\t* @method setDistinct\n\t\t* @param {Boolean} pDistinct True if the query should be distinct.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setDistinct = function(pDistinct)\n\t\t{\n\t\t\t_Parameters.distinct = !!pDistinct;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Distinct set: '+_Parameters.distinct, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the Data Elements for the Query.  *Data Elements* are the fields\n\t\t* being pulled by the query.  In TSQL this would be the _columns_,\n\t\t* whereas in MongoDB this would be the _fields_.\n\t\t*\n\t\t* The passed values can be either a string, or an array.\n\t\t*\n\t\t* @method setDataElements\n\t\t* @param {String} pDataElements The Data Element(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setDataElements = function(pDataElements)\n\t\t{\n\t\t\tvar tmpDataElements = false;\n\n\t\t\tif (Array.isArray(pDataElements))\n\t\t\t{\n\t\t\t\t// TODO: Check each entry of the array are all strings\n\t\t\t\ttmpDataElements = pDataElements;\n\t\t\t}\n\t\t\tif (typeof(pDataElements) === 'string')\n\t\t\t{\n\t\t\t\ttmpDataElements = [pDataElements];\n\t\t\t}\n\n\t\t\t_Parameters.dataElements = tmpDataElements;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Data Elements set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the sort data element\n\t\t*\n\t\t* The passed values can be either a string, an object or an array of objects.\n\t\t*\n\t\t* The Sort object has two values:\n\t\t* {Column:'Birthday', Direction:'Ascending'}\n\t\t*\n\t\t* @method setSort\n\t\t* @param {String} pSort The sort criteria(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setSort = function(pSort)\n\t\t{\n\t\t\tvar tmpSort = false;\n\n\t\t\tif (Array.isArray(pSort))\n\t\t\t{\n\t\t\t\t// TODO: Check each entry of the array are all conformant sort objects\n\t\t\t\ttmpSort = pSort;\n\t\t\t}\n\t\t\telse if (typeof(pSort) === 'string')\n\t\t\t{\n\t\t\t\t// Default to ascending\n\t\t\t\ttmpSort = [{Column:pSort, Direction:'Ascending'}];\n\t\t\t}\n\t\t\telse if (typeof(pSort) === 'object')\n\t\t\t{\n\t\t\t\t// TODO: Check that this sort entry conforms to a sort entry\n\t\t\t\ttmpSort = [pSort];\n\t\t\t}\n\n\t\t\t_Parameters.sort = tmpSort;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Sort set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the join data element\n\t\t*\n\t\t* The passed values can be either an object or an array of objects.\n\t\t*\n\t\t* The join object has four values:\n\t\t* {Type:'INNER JOIN', Table:'Test', From:'Test.ID', To:'Scope.IDItem'}\n\t\t*\n\t\t* @method setJoin\n\t\t* @param {Object} pJoin The join criteria(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setJoin = function(pJoin)\n\t\t{\n\t\t\t_Parameters.join = [];\n\n\t\t\tif (Array.isArray(pJoin))\n\t\t\t{\n\t\t\t\tpJoin.forEach(function(join)\n\t\t\t\t{\n\t\t\t\t\taddJoin(join.Table, join.From, join.To, join.Type);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (typeof(pJoin) === 'object')\n\t\t\t{\n\t\t\t\taddJoin(pJoin.Table, pJoin.From, pJoin.To, pJoin.Type);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Add a sort data element\n\t\t*\n\t\t* The passed values can be either a string, an object or an array of objects.\n\t\t*\n\t\t* The Sort object has two values:\n\t\t* {Column:'Birthday', Direction:'Ascending'}\n\t\t*\n\t\t* @method setSort\n\t\t* @param {String} pSort The sort criteria to add to the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addSort = function(pSort)\n\t\t{\n\t\t\tvar tmpSort = false;\n\n\t\t\tif (typeof(pSort) === 'string')\n\t\t\t{\n\t\t\t\t// Default to ascending\n\t\t\t\ttmpSort = {Column:pSort, Direction:'Ascending'};\n\t\t\t}\n\t\t\tif (typeof(pSort) === 'object')\n\t\t\t{\n\t\t\t\t// TODO: Check that this sort entry conforms to a sort entry\n\t\t\t\ttmpSort = pSort;\n\t\t\t}\n\n\t\t\tif (!_Parameters.sort)\n\t\t\t{\n\t\t\t\t_Parameters.sort = [];\n\t\t\t}\n\n\t\t\t_Parameters.sort.push(tmpSort);\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Sort set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the the Begin index for the Query.  *Begin* is the index at which\n\t\t* a query should start returning rows.  In TSQL this would be the n\n\t\t* parameter of ```LIMIT 1,n```, whereas in MongoDB this would be the\n\t\t* n in ```skip(n)```.\n\t\t*\n\t\t* The passed value must be an Integer >= 0.\n\t\t*\n\t\t* @method setBegin\n\t\t* @param {Number} pBeginAmount The index to begin returning Query data.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setBegin = function(pBeginAmount)\n\t\t{\n\t\t\tvar tmpBegin = false;\n\n\t\t\t// Test if it is an integer > -1\n\t\t\t// http://jsperf.com/numbers-and-integers\n\t\t\tif (typeof(pBeginAmount) === 'number' && (pBeginAmount % 1) === 0 && pBeginAmount >= 0)\n\t\t\t{\n\t\t\t\ttmpBegin = pBeginAmount;\n\t\t\t}\n\t\t\telse if (pBeginAmount !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Begin set failed; non-positive or non-numeric argument.', {queryUUID:_UUID, parameters:_Parameters, invalidBeginAmount:pBeginAmount});\n\t\t\t}\n\n\t\t\t_Parameters.begin = tmpBegin;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Begin set: '+pBeginAmount, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the the Cap for the Query.  *Cap* is the maximum number of records\n\t\t* a Query should return in a set.  In TSQL this would be the n\n\t\t* parameter of ```LIMIT n```, whereas in MongoDB this would be the\n\t\t* n in ```limit(n)```.\n\t\t*\n\t\t* The passed value must be an Integer >= 0.\n\t\t*\n\t\t* @method setCap\n\t\t* @param {Number} pCapAmount The maximum records for the Query set.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setCap = function(pCapAmount)\n\t\t{\n\t\t\tvar tmpCapAmount = false;\n\n\t\t\tif (typeof(pCapAmount) === 'number' && (pCapAmount % 1) === 0 && pCapAmount >= 0)\n\t\t\t{\n\t\t\t\ttmpCapAmount = pCapAmount;\n\t\t\t}\n\t\t\telse if (pCapAmount !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Cap set failed; non-positive or non-numeric argument.', {queryUUID:_UUID, parameters:_Parameters, invalidCapAmount:pCapAmount});\n\t\t\t}\n\n\n\t\t\t_Parameters.cap = tmpCapAmount;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Cap set to: '+tmpCapAmount, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the filter expression\n\t\t*\n\t\t* The passed values can be either an object or an array of objects.\n\t\t*\n\t\t* The Filter object has a minimum of two values (which expands to the following):\n\t\t* {Column:'Name', Value:'John'}\n\t\t* {Column:'Name', Operator:'EQ', Value:'John', Connector:'And', Parameter:'Name'}\n\t\t*\n\t\t* @method setFilter\n\t\t* @param {String} pFilter The filter(s) for the Query.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setFilter = function(pFilter)\n\t\t{\n\t\t\tvar tmpFilter = false;\n\n\t\t\tif (Array.isArray(pFilter))\n\t\t\t{\n\t\t\t\t// TODO: Check each entry of the array are all conformant Filter objects\n\t\t\t\ttmpFilter = pFilter;\n\t\t\t}\n\t\t\telse if (typeof(pFilter) === 'object')\n\t\t\t{\n\t\t\t\t// TODO: Check that this Filter entry conforms to a Filter entry\n\t\t\t\ttmpFilter = [pFilter];\n\t\t\t}\n\n\t\t\t_Parameters.filter = tmpFilter;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Filter set', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\n\t\t/**\n\t\t* Add a filter expression\n\t\t*\n\t\t* {Column:'Name', Operator:'EQ', Value:'John', Connector:'And', Parameter:'Name'}\n\t\t*\n\t\t* @method addFilter\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addFilter = function(pColumn, pValue, pOperator, pConnector, pParameter)\n\t\t{\n\t\t\tif (typeof(pColumn) !== 'string')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query filter column', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (typeof(pValue) === 'undefined')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query filter value', {queryUUID:_UUID, parameters:_Parameters, invalidColumn:pColumn});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tvar tmpOperator = (typeof(pOperator) === 'undefined') ? '=' : pOperator;\n\t\t\tvar tmpConnector = (typeof(pConnector) === 'undefined') ? 'AND' : pConnector;\n\t\t\tvar tmpParameter = (typeof(pParameter) === 'undefined') ? pColumn : pParameter;\n\n\t\t\t//support table.field notation (mysql2 requires this)\n\t\t\ttmpParameter = tmpParameter.replace('.', '_');\n\n\t\t\tvar tmpFilter = (\n\t\t\t\t{\n\t\t\t\t\tColumn: pColumn,\n\t\t\t\t\tOperator: tmpOperator,\n\t\t\t\t\tValue: pValue,\n\t\t\t\t\tConnector: tmpConnector,\n\t\t\t\t\tParameter: tmpParameter\n\t\t\t\t});\n\n\t\t\tif (!Array.isArray(_Parameters.filter))\n\t\t\t{\n\t\t\t\t_Parameters.filter = [tmpFilter];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Parameters.filter.push(tmpFilter);\n\t\t\t}\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Added a filter', {queryUUID:_UUID, parameters:_Parameters, newFilter:tmpFilter});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Add a join expression\n\t\t*\n\t\t* {Type:'INNER JOIN', Table:'Test', From:'Test.ID', To:'Scope.IDItem'}\n\t\t*\n\t\t* @method addJoin\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addJoin = function(pTable, pFrom, pTo, pType)\n\t\t{\n\t\t\tif (typeof(pTable) !== 'string')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join table', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (typeof(pFrom) === 'undefined' || typeof(pTo) === 'undefined')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join field', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t//sanity check the join fields\n\t\t\tif (pFrom.indexOf(pTable)!=0)\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join field, join must come FROM the join table!', {queryUUID:_UUID, parameters:_Parameters, invalidField:pFrom});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (pTo.indexOf('.')<=0)\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid query join field, join must go TO a field on another table ([table].[field])!', {queryUUID:_UUID, parameters:_Parameters, invalidField:pTo});\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar tmpType = (typeof(pType) === 'undefined') ?  'INNER JOIN' : pType;\n\n\t\t\tvar tmpJoin = (\n\t\t\t\t{\n\t\t\t\t\tType: tmpType,\n\t\t\t\t\tTable: pTable,\n\t\t\t\t\tFrom: pFrom,\n\t\t\t\t\tTo: pTo\n\t\t\t\t});\n\n\t\t\tif (!Array.isArray(_Parameters.join))\n\t\t\t{\n\t\t\t\t_Parameters.join = [tmpJoin];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Parameters.join.push(tmpJoin);\n\t\t\t}\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Added a join', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\n\t\t/**\n\t\t* Add a record (for UPDATE and INSERT)\n\t\t*\n\t\t*\n\t\t* @method addRecord\n\t\t* @param {Object} pRecord The record to add.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar addRecord = function(pRecord)\n\t\t{\n\t\t\tif (typeof(pRecord) !== 'object')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Tried to add an invalid record to the query -- records must be an object', {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!Array.isArray(_Parameters.query.records))\n\t\t\t{\n\t\t\t\t_Parameters.query.records = [pRecord];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Parameters.query.records.push(pRecord);\n\t\t\t}\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('Added a record to the query', {queryUUID:_UUID, parameters:_Parameters, newRecord:pRecord});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\n\n\t\t/**\n\t\t* Set the Dialect for Query generation.\n\t\t*\n\t\t* This function expects a string, case sensitive, which matches both the\n\t\t* folder and filename\n\t\t*\n\t\t* @method setDialect\n\t\t* @param {String} pDialectName The dialect for query generation.\n\t\t* @return {Object} Returns the current Query for chaining.\n\t\t*/\n\t\tvar setDialect = function(pDialectName)\n\t\t{\n\n\t\t\tif (typeof(pDialectName) !== 'string')\n\t\t\t{\n\t\t\t\t_Fable.log.warn('Dialect set to English - invalid name', {queryUUID:_UUID, parameters:_Parameters, invalidDialect:pDialectName});\n\t\t\t\treturn setDialect('English');\n\t\t\t}\n\n\t\t\tif (_Dialects.hasOwnProperty(pDialectName))\n\t\t\t{\n\t\t\t\t_Dialect = _Dialects[pDialectName](_Fable);\n\t\t\t\tif (_LogLevel > 2)\n\t\t\t\t{\n\t\t\t\t\t_Fable.log.info('Dialog set to: '+pDialectName, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_Fable.log.error('Dialect not set - unknown dialect \"'+pDialectName+\"'\", {queryUUID:_UUID, parameters:_Parameters, invalidDialect:pDialectName});\n\t\t\t\tsetDialect('English');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* User to use for this query\n\t\t*\n\t\t* @method setIDUser\n\t\t*/\n\t\tvar setIDUser = function(pIDUser)\n\t\t{\n\n\t\t\tvar tmpUserID = 0;\n\n\t\t\tif (typeof(pIDUser) === 'number' && (pIDUser % 1) === 0 && pIDUser >= 0)\n\t\t\t{\n\t\t\t\ttmpUserID = pIDUser;\n\t\t\t}\n\t\t\telse if (pIDUser !== false)\n\t\t\t{\n\t\t\t\t_Fable.log.error('User set failed; non-positive or non-numeric argument.', {queryUUID:_UUID, parameters:_Parameters, invalidIDUser:pIDUser});\n\t\t\t}\n\n\n\t\t\t_Parameters.userID = tmpUserID;\n\t\t\t_Parameters.query.IDUser = tmpUserID;\n\n\t\t\tif (_LogLevel > 2)\n\t\t\t{\n\t\t\t\t_Fable.log.info('IDUser set to: '+tmpUserID, {queryUUID:_UUID, parameters:_Parameters});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable auto identity\n\t\t*\n\t\t* @method setDisableAutoIdentity\n\t\t*/\n\t\tvar setDisableAutoIdentity = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableAutoIdentity = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable auto datestamp\n\t\t*\n\t\t* @method setDisableAutoDateStamp\n\t\t*/\n\t\tvar setDisableAutoDateStamp = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableAutoDateStamp = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable auto userstamp\n\t\t*\n\t\t* @method setDisableAutoUserStamp\n\t\t*/\n\t\tvar setDisableAutoUserStamp = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableAutoUserStamp = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Flag to disable delete tracking\n\t\t*\n\t\t* @method setDisableDeleteTracking\n\t\t*/\n\t\tvar setDisableDeleteTracking = function(pFlag)\n\t\t{\n\t\t\t_Parameters.query.disableDeleteTracking = pFlag;\n\n\t\t\treturn this; //chainable\n\t\t};\n\n\t\t/**\n\t\t* Check that a valid Dialect has been set\n\t\t*\n\t\t* If there has not been a dialect set, it defaults to English.\n\t\t* TODO: Have the json configuration define a \"default\" dialect.\n\t\t*\n\t\t* @method checkDialect\n\t\t*/\n\t\tvar checkDialect = function()\n\t\t{\n\t\t\tif (_Dialect === false)\n\t\t\t{\n\t\t\t\tsetDialect('English');\n\t\t\t}\n\t\t};\n\n\n\t\tvar buildCreateQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Create(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildReadQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Read(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildUpdateQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Update(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildDeleteQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Delete(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildUndeleteQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Undelete(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\tvar buildCountQuery = function()\n\t\t{\n\t\t\tcheckDialect();\n\t\t\t_Parameters.query.body = _Dialect.Count(_Parameters);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Container Object for our Factory Pattern\n\t\t*/\n\t\tvar tmpNewFoxHoundObject = (\n\t\t{\n\t\t\tresetParameters: resetParameters,\n\t\t\tmergeParameters: mergeParameters,\n\n\t\t\tsetLogLevel: setLogLevel,\n\n\t\t\tsetScope: setScope,\n\t\t\tsetDistinct: setDistinct,\n\t\t\tsetIDUser: setIDUser,\n\t\t\tsetDataElements: setDataElements,\n\t\t\tsetBegin: setBegin,\n\t\t\tsetCap: setCap,\n\t\t\tsetFilter: setFilter,\n\t\t\taddFilter: addFilter,\n\t\t\tsetSort: setSort,\n\t\t\taddSort: addSort,\n\t\t\tsetJoin: setJoin,\n\t\t\taddJoin: addJoin,\n\n\t\t\taddRecord: addRecord,\n\t\t\tsetDisableAutoIdentity: setDisableAutoIdentity,\n\t\t\tsetDisableAutoDateStamp: setDisableAutoDateStamp,\n\t\t\tsetDisableAutoUserStamp: setDisableAutoUserStamp,\n\t\t\tsetDisableDeleteTracking: setDisableDeleteTracking,\n\n\t\t\tsetDialect: setDialect,\n\n\t\t\tbuildCreateQuery: buildCreateQuery,\n\t\t\tbuildReadQuery: buildReadQuery,\n\t\t\tbuildUpdateQuery: buildUpdateQuery,\n\t\t\tbuildDeleteQuery: buildDeleteQuery,\n\t\t\tbuildUndeleteQuery: buildUndeleteQuery,\n\t\t\tbuildCountQuery: buildCountQuery,\n\n\t\t\tclone: clone,\n\t\t\tnew: createNew\n\t\t});\n\n\t\t/**\n\t\t * Query\n\t\t *\n\t\t * @property query\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'query',\n\t\t\t{\n\t\t\t\tget: function() { return _Parameters.query; },\n\t\t\t\tset: function(pQuery) { _Parameters.query = pQuery; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Result\n\t\t *\n\t\t * @property result\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'result',\n\t\t\t{\n\t\t\t\tget: function() { return _Parameters.result; },\n\t\t\t\tset: function(pResult) { _Parameters.result = pResult; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Query Parameters\n\t\t *\n\t\t * @property parameters\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'parameters',\n\t\t\t{\n\t\t\t\tget: function() { return _Parameters; },\n\t\t\t\tset: function(pParameters) { _Parameters = pParameters; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Dialect\n\t\t *\n\t\t * @property dialect\n\t\t * @type Object\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'dialect',\n\t\t\t{\n\t\t\t\tget: function() { return _Dialect; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Universally Unique Identifier\n\t\t *\n\t\t * @property uuid\n\t\t * @type String\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'uuid',\n\t\t\t{\n\t\t\t\tget: function() { return _UUID; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Log Level\n\t\t *\n\t\t * @property logLevel\n\t\t * @type Integer\n\t\t */\n\t\tObject.defineProperty(tmpNewFoxHoundObject, 'logLevel',\n\t\t\t{\n\t\t\t\tget: function() { return _LogLevel; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\treturn tmpNewFoxHoundObject;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = FoxHound();\n","getDialects = () =>\n{\n\tlet tmpDialects = {};\n\n\ttmpDialects.ALASQL = require('./dialects/ALASQL/FoxHound-Dialect-ALASQL.js');\n\ttmpDialects.English = require('./dialects/English/FoxHound-Dialect-English.js');\n\ttmpDialects.MeadowEndpoints = require('./dialects/MeadowEndpoints/FoxHound-Dialect-MeadowEndpoints.js');\n\ttmpDialects.MySQL = require('./dialects/MySQL/FoxHound-Dialect-MySQL.js');\n\n\ttmpDialects.default = tmpDialects.English;\n\n\treturn tmpDialects;\n}\n\nmodule.exports = getDialects();","/**\n* Query Parameters Object\n*\n* @class FoxHoundQueryParameters\n* @constructor\n*/\nvar FoxHoundQueryParameters = (\n{\n\t\tscope: false,        // STR: The scope of the data\n\t\t\t\t\t\t\t\t// TSQL: the \"Table\" or \"View\"\n\t\t\t\t\t\t\t\t// MongoDB: the \"Collection\"\n\n\t\tdataElements: false, // ARR of STR: The data elements to return\n\t\t\t\t\t\t\t\t// TSQL: the \"Columns\"\n\t\t\t\t\t\t\t\t// MongoDB: the \"Fields\"\n\n\t\tbegin: false,        // INT: Record index to start at\n\t\t\t\t\t\t\t\t// TSQL: n in LIMIT 1,n\n\t\t\t\t\t\t\t\t// MongoDB: n in Skip(n)\n\n\t\tcap: false,          // INT: Maximum number of records to return\n\t\t\t\t\t\t\t\t// TSQL: n in LIMIT n\n\t\t\t\t\t\t\t\t// MongoDB: n in limit(n)\n\n\t\t// Serialization example for a query:\n\t\t// Take the filter and return an array of filter instructions\n\t\t// Basic instruction anatomy:\n\t\t//       INSTRUCTION~FIELD~OPERATOR~VALUE\n\t\t// FOP - Filter Open Paren\n\t\t//       FOP~~(~\n\t\t// FCP - Filter Close Paren\n\t\t//       FCP~~)~\n\t\t// FBV - Filter By Value\n\t\t//       FBV~Category~EQ~Books\n\t\t//       Possible comparisons:\n\t\t//       * EQ - Equals To (=)\n\t\t//       * NE - Not Equals To (!=)\n\t\t//       * GT - Greater Than (>)\n\t\t//       * GE - Greater Than or Equals To (>=)\n\t\t//       * LT - Less Than (<)\n\t\t//       * LE - Less Than or Equals To (<=)\n\t\t//       * LK - Like (Like)\n\t\t// FBL - Filter By List (value list, separated by commas)\n\t\t//       FBL~Category~EQ~Books,Movies\n\t\t// FSF - Filter Sort Field\n\t\t//       FSF~Category~ASC~0\n\t\t//       FSF~Category~DESC~0\n\t\t// FCC - Filter Constraint Cap (the limit of what is returned)\n\t\t//       FCC~~10~\n\t\t// FCB - Filter Constraint Begin (the zero-based start index of what is returned)\n\t\t//       FCB~~10~\n\t\t//\n\t\t// This means: FBV~Category~EQ~Books~FBV~PublishedYear~GT~2000~FSF~PublishedYear~DESC~0\n\t\t//             Filters down to ALL BOOKS PUBLISHED AFTER 2000 IN DESCENDING ORDER\n\t\tfilter: false,       // ARR of OBJ: Data filter expression list {Column:'Name', Operator:'EQ', Value:'John', Connector:'And', Parameter:'Name'}\n\t\t\t\t\t\t\t\t// TSQL: the WHERE clause\n\t\t\t\t\t\t\t\t// MongoDB: a find() expression\n\n\t\tsort: false,         // ARR of OBJ: The sort order    {Column:'Birthday', Direction:'Ascending'}\n\t\t\t\t\t\t\t\t// TSQL: ORDER BY\n\t\t\t\t\t\t\t\t// MongoDB: sort()\n\n\t\tjoin: false,         // ARR of OBJ: The join tables    {Type:'INNER JOIN', Table:'test', From: 'Test.ID', To: 'Scope.IDItem' }\n\t\t\t\t\t\t\t\t// TSQL: JOIN\n\n\t\t// Force a specific query to run regardless of above ... this is used to override the query generator.\n\t\tqueryOverride: false,\n\n\t\t// Where the generated query goes\n\t\tquery: false,\n\t\t/*\n\t\t\t{\n\t\t\t\tbody: false,\n\t\t\t\tschema: false,   // The schema to intersect with our records\n\t\t\t\tIDUser: 0,       // The User ID to stamp into records\n\t\t\t\tUUID: A_UUID,    // Some globally unique record id, different per cloned query.\n\t\t\t\trecords: false,  // The records to be created or changed\n\t\t\t\tparameters: {}\n\t\t\t}\n\t\t*/\n\t\t\n\t\t// Who is making the query\n\t\tuserID: 0,\n\n\t\t// Where the query results are stuck\n\t\tresult: false\n\t\t/*\n\t\t\t{\n\t\t\t\texecuted: false, // True once we've run a query.\n\t\t\t\tvalue: false,    // The return value of the last query run\n\t\t\t\terror: false     // The error message of the last run query\n\t\t\t}\n\t\t*/\n});\n\nmodule.exports = FoxHoundQueryParameters;","/**\n* FoxHound ALASQL Dialect\n*\n* @license MIT\n*\n* For an ALASQL query override:\n// An underscore template with the following values:\n//      <%= DataElements %> = Field1, Field2, Field3, Field4\n//      <%= Begin %>        = 0\n//      <%= Cap %>          = 10\n//      <%= Filter %>       = WHERE StartDate > :MyStartDate\n//      <%= Sort %>         = ORDER BY Field1\n// The values are empty strings if they aren't set.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectALASQL\n*/\n\nvar FoxHoundDialectALASQL = function(pFable)\n{\n\t//Request time from SQL server with microseconds resolution\n\tconst SQL_NOW = \"NOW(3)\";\n\n\t_Fable = pFable;\n\n\t/**\n\t* Generate a table name from the scope.\n\t*\n\t* Because ALASQL is all in-memory, and can be run in two modes (anonymous\n\t* working on arrays or table-based) we are going to make this a programmable\n\t* value.  Then we can share the code across both providers.\n\t*\n\t* @method: generateTableName\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateTableName = function(pParameters)\n\t{\n\t\treturn ' '+pParameters.scope;\n\t};\n\n\t/**\n\t* Escape columns, because ALASQL has more reserved KWs than most SQL dialects\n\t*/\n\tvar escapeColumn = (pColumn, pParameters) =>\n\t{\n\t\tif (pColumn.indexOf('.') < 0)\n\t\t{\n\t\t\treturn '`'+pColumn+'`';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This could suck if the scope is not the same\n\t\t\tvar tmpTableName = pParameters.scope;\n\t\t\tif (pColumn.indexOf(tmpTableName+'.') > -1)\n\t\t\t{\n\t\t\t\treturn '`'+pColumn.replace(tmpTableName+'.', '')+'`';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This doesn't work well but we'll try it.\n\t\t\t\treturn '`'+pColumn+'`';\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* Generate a field list from the array of dataElements\n\t*\n\t* Each entry in the dataElements is a simple string\n\t*\n\t* @method: generateFieldList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @param {Boolean} pIsForCountClause (optional) If true, generate fields for use within a count clause.\n\t* @return: {String} Returns the field list clause, or empty string if explicit fields are requested but cannot be fulfilled\n\t*          due to missing schema.\n\t*/\n\tvar generateFieldList = function(pParameters, pIsForCountClause)\n\t{\n\t\tvar tmpDataElements = pParameters.dataElements;\n\t\tif (!Array.isArray(tmpDataElements) || tmpDataElements.length < 1)\n\t\t{\n\t\t\tif (!pIsForCountClause)\n\t\t\t{\n\t\t\t\treturn ' *';\n\t\t\t}\n\t\t\t// we need to list all of the table fields explicitly; get them from the schema\n\t\t\tconst tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tif (tmpSchema.length < 1)\n\t\t\t{\n\t\t\t\t// this means we have no schema; returning an empty string here signals the calling code to handle this case\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tconst idColumn = tmpSchema.find((entry) => entry.Type === 'AutoIdentity');\n\t\t\tif (!idColumn)\n\t\t\t{\n\t\t\t\t// this means there is no autoincrementing unique ID column; treat as above\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\treturn ` ${idColumn.Column}`;\n\t\t}\n\n\t\tvar tmpFieldList = ' ';\n\t\tfor (var i = 0; i < tmpDataElements.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpFieldList += ', ';\n\t\t\t}\n\t\t\ttmpFieldList += escapeColumn(tmpDataElements[i], pParameters);\n\t\t}\n\t\treturn tmpFieldList;\n\t};\n\n\t/**\n\t* Generate a query from the array of where clauses\n\t*\n\t* Each clause is an object like:\n\t\t{\n\t\t\tColumn:'Name',\n\t\t\tOperator:'EQ',\n\t\t\tValue:'John',\n\t\t\tConnector:'And',\n\t\t\tParameter:'Name'\n\t\t}\n\t*\n\t* @method: generateWhere\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the WHERE clause prefixed with WHERE, or an empty string if unnecessary\n\t*/\n\tvar generateWhere = function(pParameters)\n\t{\n\t\tvar tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\t\tvar tmpTableName = generateTableName(pParameters).trim();\n\n\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t// Check if there is a Deleted column on the Schema. If so, we add this to the filters automatically (if not already present)\n\t\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\tvar tmpSchemaEntry = tmpSchema[i];\n\n\t\t\t\tif (tmpSchemaEntry.Type === 'Deleted')\n\t\t\t\t{\n\t\t\t\t\tvar tmpHasDeletedParameter = false;\n\n\t\t\t\t\t//first, check to see if filters are already looking for Deleted column\n\t\t\t\t\tif (tmpFilter.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var x = 0; x < tmpFilter.length; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpFilter[x].Column === tmpSchemaEntry.Column)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpHasDeletedParameter = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmpHasDeletedParameter)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if not, we need to add it\n\t\t\t\t\t\ttmpFilter.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tColumn: tmpTableName + '.' + tmpSchemaEntry.Column,\n\t\t\t\t\t\t\tOperator: '=',\n\t\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\t\tConnector: 'AND',\n\t\t\t\t\t\t\tParameter: 'Deleted'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpFilter.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpWhere = ' WHERE';\n\n\t\t// This is used to disable the connectors for subsequent queries.\n\t\t// Only the open parenthesis operator uses this, currently.\n\t\tvar tmpLastOperatorNoConnector = false;\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n\t\t\tif ((tmpFilter[i].Connector != 'NONE') && (tmpFilter[i].Operator != ')') && (tmpWhere != ' WHERE') && (tmpLastOperatorNoConnector == false))\n\t\t\t{\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Connector;\n\t\t\t}\n\n\t\t\ttmpLastOperatorNoConnector = false;\n\n\t\t\tvar tmpColumnParameter;\n\n\t\t\tif (tmpFilter[i].Operator === '(')\n\t\t\t{\n\t\t\t\t// Open a logical grouping\n\t\t\t\ttmpWhere += ' (';\n\t\t\t\ttmpLastOperatorNoConnector = true;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === ')')\n\t\t\t{\n\t\t\t\t// Close a logical grouping\n\t\t\t\ttmpWhere += ' )';\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IN')\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+escapeColumn(tmpFilter[i].Column, pParameters)+' '+tmpFilter[i].Operator+' ( :'+tmpColumnParameter+' )';\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NOT NULL')\n\t\t\t{\n\t\t\t\t// IS NOT NULL is a special operator which doesn't require a value, or parameter\n\t\t\t\ttmpWhere += ' '+escapeColumn(tmpFilter[i].Column, pParameters)+' '+tmpFilter[i].Operator;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+escapeColumn(tmpFilter[i].Column, pParameters)+' '+tmpFilter[i].Operator+' :'+tmpColumnParameter;\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpWhere;\n\t};\n\n\t/**\n\t* Generate an ORDER BY clause from the sort array\n\t*\n\t* Each entry in the sort is an object like:\n\t* {Column:'Color',Direction:'Descending'}\n\t*\n\t* @method: generateOrderBy\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the field list clause\n\t*/\n\tvar generateOrderBy = function(pParameters)\n\t{\n\t\tvar tmpOrderBy = pParameters.sort;\n\t\tif (!Array.isArray(tmpOrderBy) || tmpOrderBy.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpOrderClause = ' ORDER BY';\n\t\tfor (var i = 0; i < tmpOrderBy.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpOrderClause += ',';\n\t\t\t}\n\t\t\ttmpOrderClause += ' '+escapeColumn(tmpOrderBy[i].Column, pParameters);\n\n\t\t\tif (tmpOrderBy[i].Direction == 'Descending')\n\t\t\t{\n\t\t\t\ttmpOrderClause += ' DESC';\n\t\t\t}\n\t\t}\n\t\treturn tmpOrderClause;\n\t};\n\n\t/**\n\t* Generate the limit clause\n\t*\n\t* @method: generateLimit\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateLimit = function(pParameters)\n\t{\n\t\tif (!pParameters.cap)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpLimit = ' LIMIT';\n\t\t// Cap is required for a limit clause.\n\t\ttmpLimit += ' ' + pParameters.cap;\n\n\t\t// If there is a begin record, we'll pass that in as well.\n\t\tif (pParameters.begin !== false)\n\t\t{\n\t\t\ttmpLimit += ' FETCH ' + pParameters.begin;\n\t\t}\n\n\t\treturn tmpLimit;\n\t};\n\n\t/**\n\t* Generate the update SET clause\n\t*\n\t* @method: generateUpdateSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateSetters = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpUpdate = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pParameters.query.disableAutoDateStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateDate')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pParameters.query.disableAutoUserStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateIDUser')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// These are all ignored on update\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\ttmpUpdate += ' '+escapeColumn(tmpColumn, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+escapeColumn(tmpColumn, pParameters)+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvar tmpColumnDefaultParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+escapeColumn(tmpColumn, pParameters)+' = :'+tmpColumnDefaultParameter;\n\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnDefaultParameter] = tmpRecords[0][tmpColumn];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-delete SET clause\n\t*\n\t* @method: generateUpdateDeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateDeleteSetters = function(pParameters)\n\t{\n\t\tif (pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t//Don't generate an UPDATE query if Delete tracking is disabled\n\t\t\treturn false;\n\t\t}\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = 1';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// Delete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-delete SET clause\n\t*\n\t* @method: generateUpdateDeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateUndeleteSetters = function(pParameters)\n\t{\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = 0';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// Delete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = NOW()';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+escapeColumn(tmpSchemaEntry.Column, pParameters)+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetValues = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpCreateSet += ',';\n\t\t\t}\n\n\t\t\t//define a re-usable method for setting up field definitions in a default pattern\n\t\t\tvar buildDefaultDefinition = function()\n\t\t\t{\n\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t// Set the query parameter\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpRecords[0][tmpColumn];\n\t\t\t};\n\n\t\t\tvar tmpColumnParameter;\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' NULL';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AutoGUID':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpRecords[0][tmpColumn] &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn].length >= 5 &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn] !== '0x0000000000000000') //stricture default\n\t\t\t\t\t{\n\t\t\t\t\t\t// Allow consumer to override AutoGUID\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.UUID;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\tif (pParameters.query.disableAutoDateStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' NOW()';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\tif (pParameters.query.disableAutoUserStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use an appended number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpCreateSet === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetList = function(pParameters)\n\t{\n\t\t// The records were already validated by generateCreateSetValues\n\t\tvar tmpRecords = pParameters.query.records;\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tdefault:\n\t\t\t\t\tif (tmpCreateSet != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpCreateSet += ',';\n\t\t\t\t\t}\n\t\t\t\t\ttmpCreateSet += ' '+escapeColumn(tmpColumn, pParameters);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpCreateSetList = generateCreateSetList(pParameters);\n\t\tvar tmpCreateSetValues = generateCreateSetValues(pParameters);\n\n\t\tif (!tmpCreateSetValues)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'INSERT INTO'+tmpTableName+' ('+tmpCreateSetList+') VALUES ('+tmpCreateSetValues+');';\n\t};\n\n\n\t/**\n\t* Read one or many records\n\t*\n\t* Some examples:\n\t* SELECT * FROM WIDGETS;\n\t* SELECT * FROM WIDGETS LIMIT 0, 20;\n\t* SELECT * FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20 WHERE LastName = 'Smith';\n\t*\n\t* @method Read\n\t* @param {Object} pParameters SQL Query parameters\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpFieldList = generateFieldList(pParameters);\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpOrderBy = generateOrderBy(pParameters);\n\t\tvar tmpLimit = generateLimit(pParameters);\n\t\tconst tmpOptDistinct = pParameters.distinct ? ' DISTINCT' : '';\n\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:tmpFieldList, TableName:tmpTableName, Where:tmpWhere, OrderBy:tmpOrderBy, Limit:tmpLimit, Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Read Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT${tmpOptDistinct}${tmpFieldList} FROM${tmpTableName}${tmpWhere}${tmpOrderBy}${tmpLimit};`;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateSetters = generateUpdateSetters(pParameters);\n\n\t\tif (!tmpUpdateSetters)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateSetters+tmpWhere+';';\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateDeleteSetters = generateUpdateDeleteSetters(pParameters);\n\n\t\tif (tmpUpdateDeleteSetters)\n\t\t{\n\t\t\t//If it has a deleted bit, update it instead of actually deleting the record\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateDeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'DELETE FROM'+tmpTableName+tmpWhere+';';\n\t\t}\n\t};\n\n\tvar Undelete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tlet tmpDeleteTrackingState = pParameters.query.disableDeleteTracking;\n\t\tpParameters.query.disableDeleteTracking = true;\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateUndeleteSetters = generateUpdateUndeleteSetters(pParameters);\n\t\tpParameters.query.disableDeleteTracking = tmpDeleteTrackingState;\n\n\t\tif (tmpUpdateUndeleteSetters)\n\t\t{\n\t\t\t//If it has a deleted bit, update it instead of actually deleting the record\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateUndeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'SELECT NULL;';\n\t\t}\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tconst tmpFieldList = pParameters.distinct ? generateFieldList(pParameters, true) : '*';\n\n\t\t// here, we ignore the distinct keyword if no fields have been specified and\n\t\tif (pParameters.distinct && tmpFieldList.length < 1)\n\t\t{\n\t\t\tconsole.warn('Distinct requested but no field list or schema are available, so not honoring distinct for count query.');\n\t\t}\n\t\tconst tmpOptDistinct = pParameters.distinct && tmpFieldList.length > 0 ? 'DISTINCT' : '';\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:[], TableName:tmpTableName, Where:tmpWhere, OrderBy:'', Limit:'', Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Count Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT COUNT(${tmpOptDistinct}${tmpFieldList || '*'}) AS RowCount FROM${tmpTableName}${tmpWhere};`;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tUndelete: Undelete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t* Dialect Name\n\t*\n\t* @property name\n\t* @type string\n\t*/\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'ALASQL'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectALASQL;\n","/**\n* FoxHound English Dialect\n*\n* Because if I can't ask for it in my native tongue, how am I going to ask a\n* complicated server for it?\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectEnglish\n*/\nvar FoxHoundDialectEnglish = function()\n{\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'Here is a '+tmpScope+'.';\n\t};\n\n\t/**\n\t* Read one or many records\n\t*\n\t* Some examples:\n\t* Please give me all your Widget records.  Thanks.\n\t* Please give me 20 Widget records.  Thanks.\n\t* Please give me 20 Widget records starting with record 5.  Thanks.\n\t* Please give me the ID, Name and Cost of 20 Widget records starting with record 5.  Thanks.\n\t* Please give me the ID and Name of 20 Widget records starting with record 5, when LastName equals \"Smith\".  Thanks.\n\t*\n\t* @method Read\n\t* @param {Number} pLogLevel The log level for our object\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\t\tconst tmpDistinct = pParameters.distinct ? 'unique ' : '';\n\n\t\treturn `Please give me all your ${tmpDistinct}${tmpScope} records.  Thanks.`;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'I am changing your '+tmpScope+'.';\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'I am deleting your '+tmpScope+'.';\n\t};\n\n\tvar Undelete = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\n\t\treturn 'I am undeleting your '+tmpScope+'.';\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpScope = pParameters.scope;\n\t\tconst tmpDistinct = pParameters.distinct ? 'unique ' : '';\n\n\t\treturn `Count your ${tmpDistinct}${tmpScope}.`;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tUndelete: Undelete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t * Dialect Name\n\t *\n\t * @property name\n\t * @type string\n\t */\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'English'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectEnglish;\n","/**\n* FoxHound Meadow Endpoints Dialect\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectMeadowEndpoints\n*/\n\nvar FoxHoundDialectMeadowEndpoints = function()\n{\n\t/**\n\t * Generate a table name from the scope\n\t *\n\t * @method: generateTableName\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the table name clause\n\t */\n\tvar generateTableName = function(pParameters)\n\t{\n\t\treturn pParameters.scope;\n\t};\n\n\t/**\n\t * Generate the Identity column from the schema or scope\n\t * \n\t * @method: generateIdentityColumnName\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the table name clause\n\t */\n\tvar generateIdentityColumnName = function(pParameters)\n\t{\n\t\t// TODO: See about using the Schema or the Schemata for this\n\t\treturn `ID${pParameters.scope}`;\n\t};\n\n\t/**\n\t * Generate a field list from the array of dataElements\n\t *\n\t * Each entry in the dataElements is a simple string\n\t *\n\t * @method: generateFieldList\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the field list clause\n\t */\n\tvar generateFieldList = function(pParameters)\n\t{\n\t\tvar tmpDataElements = pParameters.dataElements;\n\t\tif (!Array.isArray(tmpDataElements) || tmpDataElements.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpFieldList = '';\n\t\tfor (var i = 0; i < tmpDataElements.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpFieldList += ',';\n\t\t\t}\n\n            tmpFieldList += tmpDataElements[i];\n\t\t}\n\t\treturn tmpFieldList;\n\t};\n\n\t/**\n\t * Generate a query from the array of where clauses\n\t *\n\t * Each clause is an object like:\n\t\t{\n\t\t\tColumn:'Name', \n\t\t\tOperator:'EQ', \n\t\t\tValue:'John', \n\t\t\tConnector:'And', \n\t\t\tParameter:'Name'\n\t\t}\n\t *\n\t * @method: generateWhere\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the WHERE clause prefixed with WHERE, or an empty string if unnecessary\n\t */\n\tvar generateWhere = function(pParameters)\n\t{\n\t\tvar tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\t\tvar tmpTableName = generateTableName(pParameters);\n        \n        var tmpURL = '';\n\n        let tmpfAddFilter = (pFilterCommand, pFilterParameters) =>\n        {\n            if (tmpURL.length > 0)\n            {\n                tmpURL += '~';\n            }\n            \n            tmpURL += `${pFilterCommand}~${pFilterParameters[0]}~${pFilterParameters[1]}~${pFilterParameters[2]}`;\n        };\n\n        let tmpfTranslateOperator = (pOperator) =>\n        {\n            tmpNewOperator = 'EQ';\n            switch(pOperator.toUpperCase())\n            {\n                case '!=':\n                    tmpNewOperator = 'NE';\n                    break;\n                case '>':\n                    tmpNewOperator = 'GT';\n                    break;\n                case '>=':\n                    tmpNewOperator = 'GE';\n                    break;\n                case '<=':\n                    tmpNewOperator = 'LE';\n                    break;\n                case '<':\n                    tmpNewOperator = 'LT';\n                    break;\n                case 'LIKE':\n                    tmpNewOperator = 'LK';\n                    break;\n                case 'IN':\n                    tmpNewOperator = 'INN';\n                    break;\n                case 'NOT IN':\n                    tmpNewOperator = 'NI';\n                    break;\n            }\n            return tmpNewOperator;\n        }\n\n        // Translating Delete Tracking bit on query to a query with automagic\n        // This will eventually deprecate this as part of the necessary query\n        if (pParameters.query.disableDeleteTracking)\n        {\n            tmpfAddFilter('FBV',['Deleted','GE','0'])\n        }\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n\t\t\tif (tmpFilter[i].Operator === '(')\n\t\t\t{\n                tmpfAddFilter('FOP',['0','(','0']);\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === ')')\n\t\t\t{\n\t\t\t\t// Close a logical grouping\n                tmpfAddFilter('FCP',['0',')','0']);\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IN' || tmpFilter[i].Operator === \"NOT IN\")\n\t\t\t{\n                let tmpFilterCommand = 'FBV';\n                if (tmpFilter[i].Connector == 'OR')\n                {\n                    tmpFilterCommand = 'FBVOR';\n                }\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n                tmpfAddFilter(tmpFilterCommand, [tmpFilter[i].Column, tmpfTranslateOperator(tmpFilter[i].Operator), tmpFilter[i].Value.map(encodeURIComponent).join(',')])\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NULL')\n\t\t\t{\n\t\t\t\t// IS NULL is a special operator which doesn't require a value, or parameter\n                tmpfAddFilter('FBV', [tmpFilter[i].Column, 'IN', '0']);\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NOT NULL')\n\t\t\t{\n\t\t\t\t// IS NOT NULL is a special operator which doesn't require a value, or parameter\n                tmpfAddFilter('FBV', [tmpFilter[i].Column, 'NN', '0']);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n                let tmpFilterCommand = 'FBV';\n                if (tmpFilter[i].Connector == 'OR')\n                {\n                    tmpFilterCommand = 'FBVOR';\n                }\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n                tmpfAddFilter(tmpFilterCommand, [tmpFilter[i].Column, tmpfTranslateOperator(tmpFilter[i].Operator), encodeURIComponent(tmpFilter[i].Value)]);\n\t\t\t}\n\t\t}\n\n        let tmpOrderBy = generateOrderBy(pParameters);\n        if (tmpOrderBy)\n        {\n            if (tmpURL)\n            {\n                tmpURL += '~';\n            }\n            tmpURL += tmpOrderBy;\n        }\n\n\t\treturn tmpURL;\n\t};\n\n    /**\n\t * Get the flags for the request\n     * \n     * These are usually passed in for Update and Create when extra tracking is disabled.\n\t *\n\t * @method: generateFlags\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Flags to be sent, if any.\n\t */\n    function generateFlags(pParameters)\n    {\n        let tmpDisableAutoDateStamp = pParameters.query.disableAutoDateStamp;\n        let tmpDisableDeleteTracking = pParameters.query.disableDeleteTracking;\n        let tmpDisableAutoIdentity = pParameters.query.disableAutoIdentity;\n        let tmpDisableAutoUserStamp = pParameters.query.disableAutoUserStamp;\n\n        let tmpFlags = '';\n\n        let fAddFlag = (pFlagSet, pFlag) =>\n            {\n                if (pFlagSet)\n                {\n                    if (tmpFlags.length > 0)\n                    {\n                        tmpFlags += ',';\n                    }\n                    tmpFlags += pFlag;\n                }\n            };\n\n        fAddFlag(tmpDisableAutoDateStamp, 'DisableAutoDateStamp');\n        fAddFlag(tmpDisableDeleteTracking, 'DisableDeleteTracking');\n        fAddFlag(tmpDisableAutoIdentity, 'DisableAutoIdentity');\n        fAddFlag(tmpDisableAutoUserStamp, 'DisableAutoUserStamp');\n\n        return tmpFlags;\n    };\n\n    /**\n\t * Get the ID for the record, to be used in URIs\n\t *\n\t * @method: getIDRecord\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} ID of the record in string form for the URI\n\t */\n\tvar getIDRecord = function(pParameters)\n\t{\n        var tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\n\t\tvar tmpIDRecord = false;\n\n        if (tmpFilter.length < 1)\n\t\t{\n\t\t\treturn tmpIDRecord;\n\t\t}\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n            // Check Schema Entry Type\n            var tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tvar tmpSchemaEntry = {Column:tmpFilter[i].Column, Type:'Default'};\n\t\t\tfor (var j = 0; j < tmpSchema.length; j++)\n\t\t\t{\n                // If this column is the AutoIdentity, set it.\n\t\t\t\tif ((tmpFilter[i].Column == tmpSchema[j].Column) &&\n                    (tmpSchema[j].Type == 'AutoIdentity'))\n\t\t\t\t{\n                    tmpIDRecord = tmpFilter[i].Value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpIDRecord;\n    }\n\t\n    /**\n\t * Generate an ORDER BY clause from the sort array\n\t *\n\t * Each entry in the sort is an object like:\n\t * {Column:'Color',Direction:'Descending'}\n\t *\n\t * @method: generateOrderBy\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the field list clause\n\t */\n\tvar generateOrderBy = function(pParameters)\n\t{\n\t\tvar tmpOrderBy = pParameters.sort;\n\t\tvar tmpOrderClause = false;\n\n        if (!Array.isArray(tmpOrderBy) || tmpOrderBy.length < 1)\n\t\t{\n\t\t\treturn tmpOrderClause;\n\t\t}\n\n        tmpOrderClause = '';\n\n        for (var i = 0; i < tmpOrderBy.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpOrderClause += '~';\n\t\t\t}\n\t\t\ttmpOrderClause += `FSF~${tmpOrderBy[i].Column}~`;\n\n\t\t\tif (tmpOrderBy[i].Direction == 'Descending')\n\t\t\t{\n\t\t\t\ttmpOrderClause += 'DESC~0';\n\t\t\t}\n            else\n            {\n                tmpOrderClause += 'ASC~0'\n            }\n\t\t}\n\t\treturn tmpOrderClause;\n\t};\n\n\t/**\n\t * Generate the limit clause\n\t *\n\t * @method: generateLimit\n\t * @param: {Object} pParameters SQL Query Parameters\n\t * @return: {String} Returns the table name clause\n\t */\n\tvar generateLimit = function(pParameters)\n\t{\n\t\tif (!pParameters.cap)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n        let tmpBegin = (pParameters.begin !== false) ? pParameters.begin : 0;\n\n        return `${tmpBegin}/${pParameters.cap}`;\n\t};\n\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n        var tmpFlags = generateFlags(pParameters);\n\n        if (tmpTableName)\n        {\n            let tmpURL = tmpTableName;\n            if (tmpFlags)\n            {\n                tmpURL = `${tmpURL}/WithFlags/${tmpFlags}`\n            }\n            return tmpURL;\n        }\n        else\n        {\n            return false;\n        }\n\t};\n\n\n\t/**\n\t* Read one or many records\n\t*\n\t* @method Read\n\t* @param {Object} pParameters SQL Query parameters\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpFieldList = generateFieldList(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpLimit = generateLimit(pParameters);\n\n\t\tvar tmpURL = `${tmpTableName}`;\n\t\t// In the case that there is only a single query parameter, and the parameter is a single identity, \n\t\t// we will cast it to the READ endpoint rather than READS.\n\t\tif ((pParameters.filter)\n\t\t\t && (pParameters.filter.length == 1)\n             // If there is exactly one query filter parameter\n\t\t\t && (pParameters.filter[0].Column === generateIdentityColumnName(pParameters))\n\t\t\t // AND It is the Identity column\n\t\t\t && (pParameters.filter[0].Operator === '=')\n\t\t\t // AND The comparators is a simple equals \n\t\t\t && (tmpLimit == '') && (tmpFieldList == '')\n\t\t\t // AND There is no limit or field list set\n\t\t\t && (!pParameters.sort))\n\t\t\t // AND There is no sort clause\n\t\t{\n\t\t\t// THEN This is a SINGLE READ by presumption.\n\t\t\t// There are some bad side affects this could cause with chaining and overridden behaviors, if \n\t\t\t// we are requesting a filtered list of 1 record.\n\t\t\ttmpURL = `${tmpURL}/${pParameters.filter[0].Value}`;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpURL = `${tmpURL}s`;\n\t\t\tif (tmpFieldList)\n\t\t\t{\n\t\t\t\ttmpURL = `${tmpURL}/LiteExtended/${tmpFieldList}`\n\t\t\t}\n\t\t\tif (tmpWhere)\n\t\t\t{\n\t\t\t\ttmpURL = `${tmpURL}/FilteredTo/${tmpWhere}`;\n\t\t\t}\n\t\t\tif (tmpLimit)\n\t\t\t{\n\t\t\t\ttmpURL = `${tmpURL}/${tmpLimit}`;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpURL;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n        var tmpFlags = generateFlags(pParameters);\n\n        if (tmpTableName)\n        {\n            let tmpURL = tmpTableName;\n            if (tmpFlags)\n            {\n                tmpURL = `${tmpURL}/WithFlags/${tmpFlags}`\n            }\n            return tmpURL;\n        }\n        else\n        {\n            return false;\n        }\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpIDRecord = getIDRecord(pParameters);\n\n        if (!tmpIDRecord)\n        {\n            return false;\n        }\n\n\t\treturn `${tmpTableName}/${tmpIDRecord}`;\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\n        let tmpCountQuery = `${tmpTableName}s/Count`;\n\n        if (tmpWhere)\n        {\n            return `${tmpTableName}s/Count/FilteredTo/${tmpWhere}`;\n        }\n\n        return tmpCountQuery;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t * Dialect Name\n\t *\n\t * @property name\n\t * @type string\n\t */\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'MeadowEndpoints'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectMeadowEndpoints;\n","/**\n* FoxHound MySQL Dialect\n*\n* @license MIT\n*\n* For a MySQL query override:\n// An underscore template with the following values:\n//      <%= DataElements %> = Field1, Field2, Field3, Field4\n//      <%= Begin %>        = 0\n//      <%= Cap %>          = 10\n//      <%= Filter %>       = WHERE StartDate > :MyStartDate\n//      <%= Sort %>         = ORDER BY Field1\n// The values are empty strings if they aren't set.\n*\n* @author Steven Velozo <steven@velozo.com>\n* @class FoxHoundDialectMySQL\n*/\n\nvar FoxHoundDialectMySQL = function(pFable)\n{\n\t//Request time from SQL server with microseconds resolution\n\tconst SQL_NOW = \"NOW(3)\";\n\n\t_Fable = pFable;\n\n\t/**\n\t* Generate a table name from the scope\n\t*\n\t* @method: generateTableName\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateTableName = function(pParameters)\n\t{\n\t\tif (pParameters.scope && pParameters.scope.indexOf('`') >= 0)\n\t\t\treturn ' '+pParameters.scope+'';\n\t\telse\n\t\t\treturn ' `'+pParameters.scope+'`';\n\t};\n\n\t/**\n\t* Generate a field list from the array of dataElements\n\t*\n\t* Each entry in the dataElements is a simple string\n\t*\n\t* @method: generateFieldList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @param {Boolean} pIsForCountClause (optional) If true, generate fields for use within a count clause.\n\t* @return: {String} Returns the field list clause, or empty string if explicit fields are requested but cannot be fulfilled\n\t*          due to missing schema.\n\t*/\n\tvar generateFieldList = function(pParameters, pIsForCountClause)\n\t{\n\t\tvar tmpDataElements = pParameters.dataElements;\n\t\tif (!Array.isArray(tmpDataElements) || tmpDataElements.length < 1)\n\t\t{\n\t\t\tconst tmpTableName = generateTableName(pParameters);\n\t\t\tif (!pIsForCountClause)\n\t\t\t{\n\t\t\t\treturn tmpTableName + '.*';\n\t\t\t}\n\t\t\t// we need to list all of the table fields explicitly; get them from the schema\n\t\t\tconst tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tif (tmpSchema.length < 1)\n\t\t\t{\n\t\t\t\t// this means we have no schema; returning an empty string here signals the calling code to handle this case\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tconst idColumn = tmpSchema.find((entry) => entry.Type === 'AutoIdentity');\n\t\t\tif (!idColumn)\n\t\t\t{\n\t\t\t\t// this means there is no autoincrementing unique ID column; treat as above\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tconst qualifiedIDColumn = `${tmpTableName}.${idColumn.Column}`;\n\t\t\treturn ` ${generateSafeFieldName(qualifiedIDColumn)}`;\n\t\t}\n\n\t\tvar tmpFieldList = ' ';\n\t\tfor (var i = 0; i < tmpDataElements.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpFieldList += ', ';\n\t\t\t}\n\t\t\tif (Array.isArray(tmpDataElements[i]))\n\t\t\t{\n\t\t\t\ttmpFieldList += generateSafeFieldName(tmpDataElements[i][0]);\n\t\t\t\tif (tmpDataElements[i].length > 1 && tmpDataElements[i][1])\n\t\t\t\t{\n\t\t\t\t\ttmpFieldList += \" AS \" + generateSafeFieldName(tmpDataElements[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpFieldList += generateSafeFieldName(tmpDataElements[i]);\n\t\t\t}\n\t\t}\n\t\treturn tmpFieldList;\n\t};\n\n\tconst SURROUNDING_QUOTES_AND_WHITESPACE_REGEX = /^[` ]+|[` ]+$/g;\n\n\tconst cleanseQuoting = (str) =>\n\t{\n\t\treturn str.replace(SURROUNDING_QUOTES_AND_WHITESPACE_REGEX, '');\n\t};\n\n\t/**\n\t* Ensure a field name is properly escaped.\n\t*/\n\tvar generateSafeFieldName = function(pFieldName)\n\t{\n\t\tlet pFieldNames = pFieldName.split('.');\n\t\tif (pFieldNames.length > 1)\n\t\t{\n\t\t\tconst cleansedFieldName = cleanseQuoting(pFieldNames[1]);\n\t\t\tif (cleansedFieldName === '*')\n\t\t\t{\n\t\t\t\t// do not put * as `*`\n\t\t\t\treturn \"`\" + cleanseQuoting(pFieldNames[0]) + \"`.*\";\n\t\t\t}\n\t\t\treturn \"`\" + cleanseQuoting(pFieldNames[0]) + \"`.`\" + cleansedFieldName + \"`\";\n\t\t}\n\t\tconst cleansedFieldName = cleanseQuoting(pFieldNames[0]);\n\t\tif (cleansedFieldName === '*')\n\t\t{\n\t\t\t// do not put * as `*`\n\t\t\treturn '*';\n\t\t}\n\t\treturn \"`\" + cleanseQuoting(pFieldNames[0]) + \"`\";\n\t}\n\n\t/**\n\t* Generate a query from the array of where clauses\n\t*\n\t* Each clause is an object like:\n\t\t{\n\t\t\tColumn:'Name',\n\t\t\tOperator:'EQ',\n\t\t\tValue:'John',\n\t\t\tConnector:'And',\n\t\t\tParameter:'Name'\n\t\t}\n\t*\n\t* @method: generateWhere\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the WHERE clause prefixed with WHERE, or an empty string if unnecessary\n\t*/\n\tvar generateWhere = function(pParameters)\n\t{\n\t\tvar tmpFilter = Array.isArray(pParameters.filter) ? pParameters.filter : [];\n\t\tvar tmpTableName = generateTableName(pParameters);\n\n\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t// Check if there is a Deleted column on the Schema. If so, we add this to the filters automatically (if not already present)\n\t\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\tvar tmpSchemaEntry = tmpSchema[i];\n\n\t\t\t\tif (tmpSchemaEntry.Type === 'Deleted')\n\t\t\t\t{\n\t\t\t\t\tvar tmpHasDeletedParameter = false;\n\n\t\t\t\t\t//first, check to see if filters are already looking for Deleted column\n\t\t\t\t\tif (tmpFilter.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var x = 0; x < tmpFilter.length; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpFilter[x].Column === tmpSchemaEntry.Column)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpHasDeletedParameter = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmpHasDeletedParameter)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if not, we need to add it\n\t\t\t\t\t\ttmpFilter.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tColumn: tmpTableName + '.' + tmpSchemaEntry.Column,\n\t\t\t\t\t\t\tOperator: '=',\n\t\t\t\t\t\t\tValue: 0,\n\t\t\t\t\t\t\tConnector: 'AND',\n\t\t\t\t\t\t\tParameter: 'Deleted'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpFilter.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpWhere = ' WHERE';\n\n\t\t// This is used to disable the connectors for subsequent queries.\n\t\t// Only the open parenthesis operator uses this, currently.\n\t\tvar tmpLastOperatorNoConnector = false;\n\n\t\tfor (var i = 0; i < tmpFilter.length; i++)\n\t\t{\n\t\t\tif ((tmpFilter[i].Connector != 'NONE') && (tmpFilter[i].Operator != ')') && (tmpWhere != ' WHERE') && (tmpLastOperatorNoConnector == false))\n\t\t\t{\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Connector;\n\t\t\t}\n\n\t\t\ttmpLastOperatorNoConnector = false;\n\n\t\t\tvar tmpColumnParameter;\n\n\t\t\tif (tmpFilter[i].Operator === '(')\n\t\t\t{\n\t\t\t\t// Open a logical grouping\n\t\t\t\ttmpWhere += ' (';\n\t\t\t\ttmpLastOperatorNoConnector = true;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === ')')\n\t\t\t{\n\t\t\t\t// Close a logical grouping\n\t\t\t\ttmpWhere += ' )';\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IN' || tmpFilter[i].Operator === \"NOT IN\")\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator+' ( :'+tmpColumnParameter+' )';\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NULL')\n\t\t\t{\n\t\t\t\t// IS NULL is a special operator which doesn't require a value, or parameter\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator;\n\t\t\t}\n\t\t\telse if (tmpFilter[i].Operator === 'IS NOT NULL')\n\t\t\t{\n\t\t\t\t// IS NOT NULL is a special operator which doesn't require a value, or parameter\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpColumnParameter = tmpFilter[i].Parameter+'_w'+i;\n\t\t\t\t// Add the column name, operator and parameter name to the list of where value parenthetical\n\t\t\t\ttmpWhere += ' '+tmpFilter[i].Column+' '+tmpFilter[i].Operator+' :'+tmpColumnParameter;\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpFilter[i].Value;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpWhere;\n\t};\n\n\t/**\n\t* Generate an ORDER BY clause from the sort array\n\t*\n\t* Each entry in the sort is an object like:\n\t* {Column:'Color',Direction:'Descending'}\n\t*\n\t* @method: generateOrderBy\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the field list clause\n\t*/\n\tvar generateOrderBy = function(pParameters)\n\t{\n\t\tvar tmpOrderBy = pParameters.sort;\n\t\tif (!Array.isArray(tmpOrderBy) || tmpOrderBy.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpOrderClause = ' ORDER BY';\n\t\tfor (var i = 0; i < tmpOrderBy.length; i++)\n\t\t{\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\ttmpOrderClause += ',';\n\t\t\t}\n\t\t\ttmpOrderClause += ' '+tmpOrderBy[i].Column;\n\n\t\t\tif (tmpOrderBy[i].Direction == 'Descending')\n\t\t\t{\n\t\t\t\ttmpOrderClause += ' DESC';\n\t\t\t}\n\t\t}\n\t\treturn tmpOrderClause;\n\t};\n\n\t/**\n\t* Generate the limit clause\n\t*\n\t* @method: generateLimit\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateLimit = function(pParameters)\n\t{\n\t\tif (!pParameters.cap)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpLimit = ' LIMIT';\n\t\t// If there is a begin record, we'll pass that in as well.\n\t\tif (pParameters.begin !== false)\n\t\t{\n\t\t\ttmpLimit += ' ' + pParameters.begin + ',';\n\t\t}\n\t\t// Cap is required for a limit clause.\n\t\ttmpLimit += ' ' + pParameters.cap;\n\n\t\treturn tmpLimit;\n\t};\n\n\t/**\n\t* Generate the join clause\n\t*\n\t* @method: generateJoins\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the join clause\n\t*/\n\tvar generateJoins = function(pParameters)\n\t{\n\t\tvar tmpJoins = pParameters.join;\n\t\tif (!Array.isArray(tmpJoins) || tmpJoins.length < 1)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tvar tmpJoinClause = ''; //ex. ' INNER JOIN';\n\t\tfor (var i = 0; i < tmpJoins.length; i++)\n\t\t{\n\t\t\tvar join = tmpJoins[i];\n\t\t\t//verify that all required fields are valid\n\t\t\tif (join.Type && join.Table && join.From && join.To)\n\t\t\t{\n\t\t\t\ttmpJoinClause += ` ${join.Type} ${join.Table} ON ${join.From} = ${join.To}`;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpJoinClause;\n\t}\n\n\t/**\n\t* Generate the update SET clause\n\t*\n\t* @method: generateUpdateSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateSetters = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpUpdate = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pParameters.query.disableAutoDateStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateDate')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pParameters.query.disableAutoUserStamp &&\n\t\t\t\ttmpSchemaEntry.Type === 'UpdateIDUser')\n\t\t\t{\n\t\t\t\t// This is ignored if flag is set\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// These are all ignored on update\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\ttmpUpdate += ' '+tmpColumn+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+tmpColumn+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvar tmpColumnDefaultParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdate += ' '+tmpColumn+' = :'+tmpColumnDefaultParameter;\n\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnDefaultParameter] = tmpRecords[0][tmpColumn];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-delete SET clause\n\t*\n\t* @method: generateUpdateDeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateDeleteSetters = function(pParameters)\n\t{\n\t\tif (pParameters.query.disableDeleteTracking)\n\t\t{\n\t\t\t//Don't generate an UPDATE query if Delete tracking is disabled\n\t\t\treturn false;\n\t\t}\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = 1';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// Delete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = :'+tmpColumnParameter;\n\t\t\t\t\t// Set the query parameter\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the update-undelete SET clause\n\t*\n\t* @method: generateUpdateUndeleteSetters\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateUpdateUndeleteSetters = function(pParameters)\n\t{\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCurrentColumn = 0;\n\t\tvar tmpHasDeletedField = false;\n\t\tvar tmpUpdate = '';\n\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\tvar tmpSchemaEntry = {Type:'Default'};\n\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t{\n\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\ttmpSchemaEntry = tmpSchema[i];\n\n\t\t\tvar tmpUpdateSql = null;\n\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'Deleted':\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = 0';\n\t\t\t\t\ttmpHasDeletedField = true; //this field is required in order for query to be built\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t// The undelete operation is an Update, so we should stamp the update time\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = ' + SQL_NOW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\tvar tmpColumnParameter = tmpSchemaEntry.Column+'_'+tmpCurrentColumn;\n\t\t\t\t\ttmpUpdateSql = ' '+tmpSchemaEntry.Column+' = :'+tmpColumnParameter;\n\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//DON'T allow update of other fields in this query\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpUpdate += ',';\n\t\t\t}\n\n\t\t\ttmpUpdate += tmpUpdateSql;\n\n\t\t\t// We use a number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (!tmpHasDeletedField ||\n\t\t\ttmpUpdate === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpUpdate;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetValues = function(pParameters)\n\t{\n\t\tvar tmpRecords = pParameters.query.records;\n\t\t// We need to tell the query not to generate improperly if there are no values to set.\n\t\tif (!Array.isArray(tmpRecords) || tmpRecords.length < 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tvar tmpCurrentColumn = 0;\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmpCurrentColumn > 0)\n\t\t\t{\n\t\t\t\ttmpCreateSet += ',';\n\t\t\t}\n\n\t\t\t//define a re-usable method for setting up field definitions in a default pattern\n\t\t\tvar buildDefaultDefinition = function()\n\t\t\t{\n\t\t\t\tvar tmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t// Set the query parameter\n\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = tmpRecords[0][tmpColumn];\n\t\t\t};\n\n\t\t\tvar tmpColumnParameter;\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tcase 'AutoIdentity':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' NULL';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AutoGUID':\n\t\t\t\t\tif (pParameters.query.disableAutoIdentity)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse if (tmpRecords[0][tmpColumn] &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn].length >= 5 &&\n\t\t\t\t\t\t\ttmpRecords[0][tmpColumn] !== '0x0000000000000000') //stricture default\n\t\t\t\t\t{\n\t\t\t\t\t\t// Allow consumer to override AutoGUID\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.UUID;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UpdateDate':\n\t\t\t\tcase 'CreateDate':\n\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\tif (pParameters.query.disableAutoDateStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is an autoidentity, so we don't parameterize it and just pass in NULL\n\t\t\t\t\t\ttmpCreateSet += ' ' + SQL_NOW;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\tcase 'CreateIDUser':\n\t\t\t\t\tif (pParameters.query.disableAutoUserStamp)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// This is the user ID, which we hope is in the query.\n\t\t\t\t\t\t// This is how to deal with a normal column\n\t\t\t\t\t\ttmpColumnParameter = tmpColumn+'_'+tmpCurrentColumn;\n\t\t\t\t\t\ttmpCreateSet += ' :'+tmpColumnParameter;\n\t\t\t\t\t\t// Set the query parameter\n\t\t\t\t\t\tpParameters.query.parameters[tmpColumnParameter] = pParameters.query.IDUser;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbuildDefaultDefinition();\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// We use an appended number to make sure parameters are unique.\n\t\t\ttmpCurrentColumn++;\n\t\t}\n\n\t\t// We need to tell the query not to generate improperly if there are no values set.\n\t\tif (tmpCreateSet === '')\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\t/**\n\t* Generate the create SET clause\n\t*\n\t* @method: generateCreateSetList\n\t* @param: {Object} pParameters SQL Query Parameters\n\t* @return: {String} Returns the table name clause\n\t*/\n\tvar generateCreateSetList = function(pParameters)\n\t{\n\t\t// The records were already validated by generateCreateSetValues\n\t\tvar tmpRecords = pParameters.query.records;\n\n\t\t// Check if there is a schema.  If so, we will use it to decide if these are parameterized or not.\n\t\tvar tmpSchema = Array.isArray(pParameters.query.schema) ? pParameters.query.schema : [];\n\n\t\tvar tmpCreateSet = '';\n\t\t// If there is more than one record in records, we are going to ignore them for now.\n\t\tfor(var tmpColumn in tmpRecords[0])\n\t\t{\n\t\t\t// No hash table yet, so, we will just linear search it for now.\n\t\t\t// This uses the schema to decide if we want to treat a column differently on insert\n\t\t\tvar tmpSchemaEntry = {Column:tmpColumn, Type:'Default'};\n\t\t\tfor (var i = 0; i < tmpSchema.length; i++)\n\t\t\t{\n\t\t\t\tif (tmpColumn == tmpSchema[i].Column)\n\t\t\t\t{\n\t\t\t\t\t// There is a schema entry for it.  Process it accordingly.\n\t\t\t\t\ttmpSchemaEntry = tmpSchema[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!pParameters.query.disableDeleteTracking)\n\t\t\t{\n\t\t\t\tif (tmpSchemaEntry.Type === 'DeleteDate' ||\n\t\t\t\t\ttmpSchemaEntry.Type === 'DeleteIDUser')\n\t\t\t\t{\n\t\t\t\t\t// These are all ignored on insert (if delete tracking is enabled as normal)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (tmpSchemaEntry.Type)\n\t\t\t{\n\t\t\t\tdefault:\n\t\t\t\t\tif (tmpCreateSet != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpCreateSet += ',';\n\t\t\t\t\t}\n\t\t\t\t\ttmpCreateSet += ' '+tmpColumn;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn tmpCreateSet;\n\t};\n\n\n\tvar Create = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpCreateSetList = generateCreateSetList(pParameters);\n\t\tvar tmpCreateSetValues = generateCreateSetValues(pParameters);\n\n\t\tif (!tmpCreateSetValues)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'INSERT INTO'+tmpTableName+' ('+tmpCreateSetList+') VALUES ('+tmpCreateSetValues+');';\n\t};\n\n\n\t/**\n\t* Read one or many records\n\t*\n\t* Some examples:\n\t* SELECT * FROM WIDGETS;\n\t* SELECT * FROM WIDGETS LIMIT 0, 20;\n\t* SELECT * FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20;\n\t* SELECT ID, Name, Cost FROM WIDGETS LIMIT 5, 20 WHERE LastName = 'Smith';\n\t*\n\t* @method Read\n\t* @param {Object} pParameters SQL Query parameters\n\t* @return {String} Returns the current Query for chaining.\n\t*/\n\tvar Read = function(pParameters)\n\t{\n\t\tvar tmpFieldList = generateFieldList(pParameters);\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpJoin = generateJoins(pParameters);\n\t\tvar tmpOrderBy = generateOrderBy(pParameters);\n\t\tvar tmpLimit = generateLimit(pParameters);\n\t\tconst tmpOptDistinct = pParameters.distinct ? ' DISTINCT' : '';\n\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:tmpFieldList, TableName:tmpTableName, Where:tmpWhere, Join:tmpJoin, OrderBy:tmpOrderBy, Limit:tmpLimit, Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Read Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT${tmpOptDistinct}${tmpFieldList} FROM${tmpTableName}${tmpJoin}${tmpWhere}${tmpOrderBy}${tmpLimit};`;\n\t};\n\n\tvar Update = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateSetters = generateUpdateSetters(pParameters);\n\n\t\tif (!tmpUpdateSetters)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateSetters+tmpWhere+';';\n\t};\n\n\tvar Delete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateDeleteSetters = generateUpdateDeleteSetters(pParameters);\n\n\t\tif (tmpUpdateDeleteSetters)\n\t\t{\n\t\t\t//If it has a deleted bit, update it instead of actually deleting the record\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateDeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 'DELETE FROM'+tmpTableName+tmpWhere+';';\n\t\t}\n\t};\n\n\tvar Undelete = function(pParameters)\n\t{\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\t// TODO: Fix these\n\t\tlet tmpDeleteTrackingState = pParameters.query.disableDeleteTracking;\n\t\tpParameters.query.disableDeleteTracking = true;\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\tvar tmpUpdateUndeleteSetters = generateUpdateUndeleteSetters(pParameters);\n\t\tpParameters.query.disableDeleteTracking = tmpDeleteTrackingState;\n\n\t\tif (tmpUpdateUndeleteSetters)\n\t\t{\n\t\t\t//If the table has a deleted bit, go forward with the update to change things.\n\t\t\treturn 'UPDATE'+tmpTableName+' SET'+tmpUpdateUndeleteSetters+tmpWhere+';';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// This is a no-op because the record can't be undeleted.\n\t\t\t// TODO: Should it throw instead?\n\t\t\treturn 'SELECT NULL;';\n\t\t}\n\t};\n\n\tvar Count = function(pParameters)\n\t{\n\t\tvar tmpFieldList = pParameters.distinct ? generateFieldList(pParameters, true) : '*';\n\t\tvar tmpTableName = generateTableName(pParameters);\n\t\tvar tmpJoin = generateJoins(pParameters);\n\t\tvar tmpWhere = generateWhere(pParameters);\n\t\t// here, we ignore the distinct keyword if no fields have been specified and\n\t\tif (pParameters.distinct && tmpFieldList.length < 1)\n\t\t{\n\t\t\tconsole.warn('Distinct requested but no field list or schema are available, so not honoring distinct for count query.');\n\t\t}\n\t\tconst tmpOptDistinct = pParameters.distinct && tmpFieldList.length > 0 ? 'DISTINCT' : '';\n\n\t\tif (pParameters.queryOverride)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tmpQueryTemplate = _Fable.Utility.template(pParameters.queryOverride);\n\t\t\t\treturn tmpQueryTemplate({FieldList:[], TableName:tmpTableName, Where:tmpWhere, OrderBy:'', Limit:'', Distinct: tmpOptDistinct, _Params: pParameters});\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t// This pokemon is here to give us a convenient way of not throwing up totally if the query fails.\n\t\t\t\tconsole.log('Error with custom Count Query ['+pParameters.queryOverride+']: '+pError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn `SELECT COUNT(${tmpOptDistinct}${tmpFieldList || '*'}) AS RowCount FROM${tmpTableName}${tmpJoin}${tmpWhere};`;\n\t};\n\n\tvar tmpDialect = ({\n\t\tCreate: Create,\n\t\tRead: Read,\n\t\tUpdate: Update,\n\t\tDelete: Delete,\n\t\tUndelete: Undelete,\n\t\tCount: Count\n\t});\n\n\t/**\n\t* Dialect Name\n\t*\n\t* @property name\n\t* @type string\n\t*/\n\tObject.defineProperty(tmpDialect, 'name',\n\t\t{\n\t\t\tget: function() { return 'MySQL'; },\n\t\t\tenumerable: true\n\t\t});\n\n\treturn tmpDialect;\n};\n\nmodule.exports = FoxHoundDialectMySQL;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","var util = require('util')\nvar isProperty = require('is-property')\n\nvar INDENT_START = /[\\{\\[]/\nvar INDENT_END = /[\\}\\]]/\n\n// from https://mathiasbynens.be/notes/reserved-keywords\nvar RESERVED = [\n  'do',\n  'if',\n  'in',\n  'for',\n  'let',\n  'new',\n  'try',\n  'var',\n  'case',\n  'else',\n  'enum',\n  'eval',\n  'null',\n  'this',\n  'true',\n  'void',\n  'with',\n  'await',\n  'break',\n  'catch',\n  'class',\n  'const',\n  'false',\n  'super',\n  'throw',\n  'while',\n  'yield',\n  'delete',\n  'export',\n  'import',\n  'public',\n  'return',\n  'static',\n  'switch',\n  'typeof',\n  'default',\n  'extends',\n  'finally',\n  'package',\n  'private',\n  'continue',\n  'debugger',\n  'function',\n  'arguments',\n  'interface',\n  'protected',\n  'implements',\n  'instanceof',\n  'NaN',\n  'undefined'\n]\n\nvar RESERVED_MAP = {}\n\nfor (var i = 0; i < RESERVED.length; i++) {\n  RESERVED_MAP[RESERVED[i]] = true\n}\n\nvar isVariable = function (name) {\n  return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name)\n}\n\nvar formats = {\n  s: function(s) {\n    return '' + s\n  },\n  d: function(d) {\n    return '' + Number(d)\n  },\n  o: function(o) {\n    return JSON.stringify(o)\n  }\n}\n\nvar genfun = function() {\n  var lines = []\n  var indent = 0\n  var vars = {}\n\n  var push = function(str) {\n    var spaces = ''\n    while (spaces.length < indent*2) spaces += '  '\n    lines.push(spaces+str)\n  }\n\n  var pushLine = function(line) {\n    if (INDENT_END.test(line.trim()[0]) && INDENT_START.test(line[line.length-1])) {\n      indent--\n      push(line)\n      indent++\n      return\n    }\n    if (INDENT_START.test(line[line.length-1])) {\n      push(line)\n      indent++\n      return\n    }\n    if (INDENT_END.test(line.trim()[0])) {\n      indent--\n      push(line)\n      return\n    }\n\n    push(line)\n  }\n\n  var line = function(fmt) {\n    if (!fmt) return line\n\n    if (arguments.length === 1 && fmt.indexOf('\\n') > -1) {\n      var lines = fmt.trim().split('\\n')\n      for (var i = 0; i < lines.length; i++) {\n        pushLine(lines[i].trim())\n      }\n    } else {\n      pushLine(util.format.apply(util, arguments))\n    }\n\n    return line\n  }\n\n  line.scope = {}\n  line.formats = formats\n\n  line.sym = function(name) {\n    if (!name || !isVariable(name)) name = 'tmp'\n    if (!vars[name]) vars[name] = 0\n    return name + (vars[name]++ || '')\n  }\n\n  line.property = function(obj, name) {\n    if (arguments.length === 1) {\n      name = obj\n      obj = ''\n    }\n\n    name = name + ''\n\n    if (isProperty(name)) return (obj ? obj + '.' + name : name)\n    return obj ? obj + '[' + JSON.stringify(name) + ']' : JSON.stringify(name)\n  }\n\n  line.toString = function() {\n    return lines.join('\\n')\n  }\n\n  line.toFunction = function(scope) {\n    if (!scope) scope = {}\n\n    var src = 'return ('+line.toString()+')'\n\n    Object.keys(line.scope).forEach(function (key) {\n      if (!scope[key]) scope[key] = line.scope[key]\n    })\n\n    var keys = Object.keys(scope).map(function(key) {\n      return key\n    })\n\n    var vals = keys.map(function(key) {\n      return scope[key]\n    })\n\n    return Function.apply(null, keys.concat(src)).apply(null, vals)\n  }\n\n  if (arguments.length) line.apply(null, arguments)\n\n  return line\n}\n\ngenfun.formats = formats\nmodule.exports = genfun\n","var isProperty = require('is-property')\n\nvar gen = function(obj, prop) {\n  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'\n}\n\ngen.valid = isProperty\ngen.property = function (prop) {\n return isProperty(prop) ? prop : JSON.stringify(prop)\n}\n\nmodule.exports = gen\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\ntry {\n\tnull.error; // eslint-disable-line no-unused-expressions\n} catch (e) {\n\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\tvar errorProto = getProto(getProto(e));\n\tINTRINSICS['%Error.prototype%'] = errorProto;\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('has');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","var http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar objectClass = '[object Object]';\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar ddaClass = '[object HTMLAllCollection]'; // IE 11\nvar ddaClass2 = '[object HTML document.all class]';\nvar ddaClass3 = '[object HTMLCollection]'; // IE 9-10\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\n\nvar isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing\n\nvar isDDA = function isDocumentDotAll() { return false; };\nif (typeof document === 'object') {\n\t// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly\n\tvar all = document.all;\n\tif (toStr.call(all) === toStr.call(document.all)) {\n\t\tisDDA = function isDocumentDotAll(value) {\n\t\t\t/* globals document: false */\n\t\t\t// in IE 6-8, typeof document.all is \"object\" and it's truthy\n\t\t\tif ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {\n\t\t\t\ttry {\n\t\t\t\t\tvar str = toStr.call(value);\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstr === ddaClass\n\t\t\t\t\t\t|| str === ddaClass2\n\t\t\t\t\t\t|| str === ddaClass3 // opera 12.16\n\t\t\t\t\t\t|| str === objectClass // IE 6-8\n\t\t\t\t\t) && value('') == null; // eslint-disable-line eqeqeq\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n}\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value) && tryFunctionObject(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\tif (strClass !== fnClass && strClass !== genClass && !(/^\\[object HTML/).test(strClass)) { return false; }\n\t\treturn tryFunctionObject(value);\n\t};\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","var reIpv4FirstPass = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/\n\nvar reSubnetString = /\\/\\d{1,3}(?=%|$)/\nvar reForwardSlash = /\\//\nvar reZone = /%.*$/\nvar reBadCharacters = /([^0-9a-f:/%])/i\nvar reBadAddress = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\\/$)/i\n\nfunction validate4 (input) {\n  if (!(reIpv4FirstPass.test(input))) return false\n\n  var parts = input.split('.')\n\n  if (parts.length !== 4) return false\n\n  if (parts[0][0] === '0' && parts[0].length > 1) return false\n  if (parts[1][0] === '0' && parts[1].length > 1) return false\n  if (parts[2][0] === '0' && parts[2].length > 1) return false\n  if (parts[3][0] === '0' && parts[3].length > 1) return false\n\n  var n0 = Number(parts[0])\n  var n1 = Number(parts[1])\n  var n2 = Number(parts[2])\n  var n3 = Number(parts[3])\n\n  return (n0 >= 0 && n0 < 256 && n1 >= 0 && n1 < 256 && n2 >= 0 && n2 < 256 && n3 >= 0 && n3 < 256)\n}\n\nfunction validate6 (input) {\n  var withoutSubnet = input.replace(reSubnetString, '')\n  var hasSubnet = (input.length !== withoutSubnet.length)\n\n  // FIXME: this should probably be an option in the future\n  if (hasSubnet) return false\n\n  if (!hasSubnet) {\n    if (reForwardSlash.test(input)) return false\n  }\n\n  var withoutZone = withoutSubnet.replace(reZone, '')\n  var lastPartSeparator = withoutZone.lastIndexOf(':')\n\n  if (lastPartSeparator === -1) return false\n\n  var lastPart = withoutZone.substring(lastPartSeparator + 1)\n  var hasV4Part = validate4(lastPart)\n  var address = (hasV4Part ? withoutZone.substring(0, lastPartSeparator + 1) + '1234:5678' : withoutZone)\n\n  if (reBadCharacters.test(address)) return false\n  if (reBadAddress.test(address)) return false\n\n  var halves = address.split('::')\n\n  if (halves.length > 2) return false\n\n  if (halves.length === 2) {\n    var first = (halves[0] === '' ? [] : halves[0].split(':'))\n    var last = (halves[1] === '' ? [] : halves[1].split(':'))\n    var remainingLength = 8 - (first.length + last.length)\n\n    if (remainingLength <= 0) return false\n  } else {\n    if (address.split(':').length !== 8) return false\n  }\n\n  return true\n}\n\nfunction validate (input) {\n  return validate4(input) || validate6(input)\n}\n\nmodule.exports = function validator (options) {\n  if (!options) options = {}\n\n  if (options.version === 4) return validate4\n  if (options.version === 6) return validate6\n  if (options.version == null) return validate\n\n  throw new Error('Unknown version: ' + options.version)\n}\n\nmodule.exports['__all_regexes__'] = [\n  reIpv4FirstPass,\n  reSubnetString,\n  reForwardSlash,\n  reZone,\n  reBadCharacters,\n  reBadAddress\n]\n","var createIpValidator = require('is-my-ip-valid')\n\nvar reEmailWhitespace = /\\s/\nvar reHostnameFirstPass = /^[a-zA-Z0-9.-]+$/\nvar reHostnamePart = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/\nvar rePhoneFirstPass = /^\\+[0-9][0-9 ]{5,27}[0-9]$/\nvar rePhoneDoubleSpace = / {2}/\nvar rePhoneGlobalSpace = / /g\n\nexports['date-time'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+|)([zZ]|[+-]\\d{2}:\\d{2})$/\nexports['date'] = /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/\nexports['time'] = /^\\d{2}:\\d{2}:\\d{2}$/\nexports['email'] = function (input) { return (input.indexOf('@') !== -1) && (!reEmailWhitespace.test(input)) }\nexports['ip-address'] = exports['ipv4'] = createIpValidator({ version: 4 })\nexports['ipv6'] = createIpValidator({ version: 6 })\nexports['uri'] = /^[a-zA-Z][a-zA-Z0-9+\\-.]*:[^\\s]*$/\nexports['color'] = /(#?([0-9A-Fa-f]{3,6})\\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\))/\nexports['hostname'] = function (input) {\n  if (!(reHostnameFirstPass.test(input))) return false\n\n  var parts = input.split('.')\n\n  for (var i = 0; i < parts.length; i++) {\n    if (!(reHostnamePart.test(parts[i]))) return false\n  }\n\n  return true\n}\nexports['alpha'] = /^[a-zA-Z]+$/\nexports['alphanumeric'] = /^[a-zA-Z0-9]+$/\nexports['style'] = /.:\\s*[^;]/g\nexports['phone'] = function (input) {\n  if (!(rePhoneFirstPass.test(input))) return false\n  if (rePhoneDoubleSpace.test(input)) return false\n\n  var digits = input.substring(1).replace(rePhoneGlobalSpace, '').length\n\n  return (digits >= 7 && digits <= 15)\n}\nexports['utc-millisec'] = /^[0-9]{1,15}\\.?[0-9]{0,15}$/\n","var genobj = require('generate-object-property')\nvar genfun = require('generate-function')\nvar jsonpointer = require('jsonpointer')\nvar xtend = require('xtend')\nvar formats = require('./formats')\n\nvar get = function(obj, additionalSchemas, ptr) {\n\n  var visit = function(sub) {\n    if (sub && sub.id === ptr) return sub\n    if (typeof sub !== 'object' || !sub) return null\n    return Object.keys(sub).reduce(function(res, k) {\n      return res || visit(sub[k])\n    }, null)\n  }\n\n  var res = visit(obj)\n  if (res) return res\n\n  ptr = ptr.replace(/^#/, '')\n  ptr = ptr.replace(/\\/$/, '')\n\n  try {\n    return jsonpointer.get(obj, decodeURI(ptr))\n  } catch (err) {\n    var end = ptr.indexOf('#')\n    var other\n    // external reference\n    if (end !== 0) {\n      // fragment doesn't exist.\n      if (end === -1) {\n        other = additionalSchemas[ptr]\n      } else {\n        var ext = ptr.slice(0, end)\n        other = additionalSchemas[ext]\n        var fragment = ptr.slice(end).replace(/^#/, '')\n        try {\n          return jsonpointer.get(other, fragment)\n        } catch (err) {}\n      }\n    } else {\n      other = additionalSchemas[ptr]\n    }\n    return other || null\n  }\n}\n\nvar types = {}\n\ntypes.any = function() {\n  return 'true'\n}\n\ntypes.null = function(name) {\n  return name+' === null'\n}\n\ntypes.boolean = function(name) {\n  return 'typeof '+name+' === \"boolean\"'\n}\n\ntypes.array = function(name) {\n  return 'Array.isArray('+name+')'\n}\n\ntypes.object = function(name) {\n  return 'typeof '+name+' === \"object\" && '+name+' && !Array.isArray('+name+')'\n}\n\ntypes.number = function(name) {\n  return 'typeof '+name+' === \"number\" && isFinite('+name+')'\n}\n\ntypes.integer = function(name) {\n  return 'typeof '+name+' === \"number\" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'\n}\n\ntypes.string = function(name) {\n  return 'typeof '+name+' === \"string\"'\n}\n\nvar unique = function(array, len) {\n  len = Math.min(len === -1 ? array.length : len, array.length)\n  var list = []\n  for (var i = 0; i < len; i++) {\n    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])\n  }\n  for (var i = 1; i < list.length; i++) {\n    if (list.indexOf(list[i]) !== i) return false\n  }\n  return true\n}\n\nvar isMultipleOf = function(name, multipleOf) {\n  var res;\n  var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1\n  if (factor > 1) {\n    var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1\n    if (factorName > factor) res = true\n    else res = Math.round(factor * name) % (factor * multipleOf)\n  }\n  else res = name % multipleOf;\n  return !res;\n}\n\nvar testLimitedRegex = function (r, s, maxLength) {\n  if (maxLength > -1 && s.length > maxLength) return true\n  return r.test(s)\n}\n\nvar compile = function(schema, cache, root, reporter, opts) {\n  var fmts = opts ? xtend(formats, opts.formats) : formats\n  var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf, testLimitedRegex:testLimitedRegex}\n  var verbose = opts ? !!opts.verbose : false;\n  var greedy = opts && opts.greedy !== undefined ?\n    opts.greedy : false;\n\n  var syms = {}\n  var allocated = []\n  var gensym = function(name) {\n    var res = name+(syms[name] = (syms[name] || 0)+1)\n    allocated.push(res)\n    return res\n  }\n\n  var formatName = function(field) {\n    var s = JSON.stringify(field)\n    try {\n      var pattern = /\\[([^\\[\\]\"]+)\\]/\n      while (pattern.test(s)) s = s.replace(pattern, replacer)\n      return s\n    } catch (_) {\n      return JSON.stringify(field)\n    }\n\n    function replacer (match, v) {\n      if (allocated.indexOf(v) === -1) throw new Error('Unreplaceable')\n      return '.\" + ' + v + ' + \"'\n    }\n  }\n\n  var reversePatterns = {}\n  var patterns = function(p) {\n    if (reversePatterns[p]) return reversePatterns[p]\n    var n = gensym('pattern')\n    scope[n] = new RegExp(p)\n    reversePatterns[p] = n\n    return n\n  }\n\n  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']\n  var genloop = function() {\n    var v = vars.shift()\n    vars.push(v+v[0])\n    allocated.push(v)\n    return v\n  }\n\n  var visit = function(name, node, reporter, filter, schemaPath) {\n    var properties = node.properties\n    var type = node.type\n    var tuple = false\n\n    if (Array.isArray(node.items)) { // tuple type\n      properties = {}\n      node.items.forEach(function(item, i) {\n        properties[i] = item\n      })\n      type = 'array'\n      tuple = true\n    }\n\n    var indent = 0\n    var error = function(msg, prop, value) {\n      validate('errors++')\n      if (reporter === true) {\n        validate('if (validate.errors === null) validate.errors = []')\n        if (verbose) {\n          validate(\n            'validate.errors.push({field:%s,message:%s,value:%s,type:%s,schemaPath:%s})',\n            formatName(prop || name),\n            JSON.stringify(msg),\n            value || name,\n            JSON.stringify(type),\n            JSON.stringify(schemaPath)\n          )\n        } else {\n          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))\n        }\n      }\n    }\n\n    if (node.required === true) {\n      indent++\n      validate('if (%s === undefined) {', name)\n      error('is required')\n      validate('} else {')\n    } else {\n      indent++\n      validate('if (%s !== undefined) {', name)\n    }\n\n    var valid = [].concat(type)\n      .map(function(t) {\n        if (t && !types.hasOwnProperty(t)) {\n          throw new Error('Unknown type: ' + t)\n        }\n\n        return types[t || 'any'](name)\n      })\n      .join(' || ') || 'true'\n\n    if (valid !== 'true') {\n      indent++\n      validate('if (!(%s)) {', valid)\n      error('is the wrong type')\n      validate('} else {')\n    }\n\n    if (tuple) {\n      if (node.additionalItems === false) {\n        validate('if (%s.length > %d) {', name, node.items.length)\n        error('has additional items')\n        validate('}')\n      } else if (node.additionalItems) {\n        var i = genloop()\n        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)\n        visit(name+'['+i+']', node.additionalItems, reporter, filter, schemaPath.concat('additionalItems'))\n        validate('}')\n      }\n    }\n\n    if (node.format && fmts[node.format]) {\n      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))\n      var n = gensym('format')\n      scope[n] = fmts[node.format]\n\n      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)\n      else validate('if (!testLimitedRegex(%s, %s, %d)) {', n, name, typeof node.maxLength === 'undefined' ? -1 : node.maxLength)\n      error('must be '+node.format+' format')\n      validate('}')\n      if (type !== 'string' && formats[node.format]) validate('}')\n    }\n\n    if (Array.isArray(node.required)) {\n      var n = gensym('missing')\n      validate('var %s = 0', n)\n      var checkRequired = function (req) {\n        var prop = genobj(name, req);\n        validate('if (%s === undefined) {', prop)\n        error('is required', prop)\n        validate('%s++', n)\n        validate('}')\n      }\n      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')\n      node.required.map(checkRequired)\n      validate('}');\n      if (!greedy) {\n        validate('if (%s === 0) {', n)\n        indent++\n      }\n    }\n\n    if (node.uniqueItems) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n      validate('if (!(unique(%s, %d))) {', name, node.maxItems || -1)\n      error('must be unique')\n      validate('}')\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.enum) {\n      var complex = node.enum.some(function(e) {\n        return typeof e === 'object'\n      })\n\n      var compare = complex ?\n        function(e) {\n          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'\n        } :\n        function(e) {\n          return name+' !== '+JSON.stringify(e)\n        }\n\n      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')\n      error('must be an enum value')\n      validate('}')\n    }\n\n    if (node.dependencies) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      Object.keys(node.dependencies).forEach(function(key) {\n        var deps = node.dependencies[key]\n        if (typeof deps === 'string') deps = [deps]\n\n        var exists = function(k) {\n          return genobj(name, k) + ' !== undefined'\n        }\n\n        if (Array.isArray(deps)) {\n          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')\n          error('dependencies not set')\n          validate('}')\n        }\n        if (typeof deps === 'object') {\n          validate('if (%s !== undefined) {', genobj(name, key))\n          visit(name, deps, reporter, filter, schemaPath.concat(['dependencies', key]))\n          validate('}')\n        }\n      })\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.additionalProperties || node.additionalProperties === false) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      var i = genloop()\n      var keys = gensym('keys')\n\n      var toCompare = function(p) {\n        return keys+'['+i+'] !== '+JSON.stringify(p)\n      }\n\n      var toTest = function(p) {\n        return '!'+patterns(p)+'.test('+keys+'['+i+'])'\n      }\n\n      var additionalProp = Object.keys(properties || {}).map(toCompare)\n        .concat(Object.keys(node.patternProperties || {}).map(toTest))\n        .join(' && ') || 'true'\n\n      validate('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n          ('if (%s) {', additionalProp)\n\n      if (node.additionalProperties === false) {\n        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')\n        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')\n      } else {\n        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter, schemaPath.concat(['additionalProperties']))\n      }\n\n      validate\n          ('}')\n        ('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.$ref) {\n      var sub = get(root, opts && opts.schemas || {}, node.$ref)\n      if (sub) {\n        var fn = cache[node.$ref]\n        if (!fn) {\n          cache[node.$ref] = function proxy(data) {\n            return fn(data)\n          }\n          fn = compile(sub, cache, root, false, opts)\n        }\n        var n = gensym('ref')\n        scope[n] = fn\n        validate('if (!(%s(%s))) {', n, name)\n        error('referenced schema does not match')\n        validate('}')\n      }\n    }\n\n    if (node.not) {\n      var prev = gensym('prev')\n      validate('var %s = errors', prev)\n      visit(name, node.not, false, filter, schemaPath.concat('not'))\n      validate('if (%s === errors) {', prev)\n      error('negative schema matches')\n      validate('} else {')\n        ('errors = %s', prev)\n      ('}')\n    }\n\n    if (node.items && !tuple) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      var i = genloop()\n      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)\n      visit(name+'['+i+']', node.items, reporter, filter, schemaPath.concat('items'))\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.patternProperties) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n      var keys = gensym('keys')\n      var i = genloop()\n      validate\n        ('var %s = Object.keys(%s)', keys, name)\n        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)\n\n      Object.keys(node.patternProperties).forEach(function(key) {\n        var p = patterns(key)\n        validate('if (%s.test(%s)) {', p, keys+'['+i+']')\n        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter, schemaPath.concat(['patternProperties', key]))\n        validate('}')\n      })\n\n      validate('}')\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.pattern) {\n      var p = patterns(node.pattern)\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n      validate('if (!(testLimitedRegex(%s, %s, %d))) {', p, name, typeof node.maxLength === 'undefined' ? -1 : node.maxLength)\n      error('pattern mismatch')\n      validate('}')\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.allOf) {\n      node.allOf.forEach(function(sch, key) {\n        visit(name, sch, reporter, filter, schemaPath.concat(['allOf', key]))\n      })\n    }\n\n    if (node.anyOf && node.anyOf.length) {\n      var prev = gensym('prev')\n\n      node.anyOf.forEach(function(sch, i) {\n        if (i === 0) {\n          validate('var %s = errors', prev)\n        } else {\n          validate('if (errors !== %s) {', prev)\n            ('errors = %s', prev)\n        }\n        visit(name, sch, false, false, schemaPath)\n      })\n      node.anyOf.forEach(function(sch, i) {\n        if (i) validate('}')\n      })\n      validate('if (%s !== errors) {', prev)\n      error('no schemas match')\n      validate('}')\n    }\n\n    if (node.oneOf && node.oneOf.length) {\n      var prev = gensym('prev')\n      var passes = gensym('passes')\n\n      validate\n        ('var %s = errors', prev)\n        ('var %s = 0', passes)\n\n      node.oneOf.forEach(function(sch, i) {\n        visit(name, sch, false, false, schemaPath)\n        validate('if (%s === errors) {', prev)\n          ('%s++', passes)\n        ('} else {')\n          ('errors = %s', prev)\n        ('}')\n      })\n\n      validate('if (%s !== 1) {', passes)\n      error('no (or more than one) schemas match')\n      validate('}')\n    }\n\n    if (node.multipleOf !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)\n\n      error('has a remainder')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maxProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)\n      error('has more properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.minProperties !== undefined) {\n      if (type !== 'object') validate('if (%s) {', types.object(name))\n\n      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)\n      error('has less properties than allowed')\n      validate('}')\n\n      if (type !== 'object') validate('}')\n    }\n\n    if (node.maxItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length > %d) {', name, node.maxItems)\n      error('has more items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.minItems !== undefined) {\n      if (type !== 'array') validate('if (%s) {', types.array(name))\n\n      validate('if (%s.length < %d) {', name, node.minItems)\n      error('has less items than allowed')\n      validate('}')\n\n      if (type !== 'array') validate('}')\n    }\n\n    if (node.maxLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length > %d) {', name, node.maxLength)\n      error('has longer length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minLength !== undefined) {\n      if (type !== 'string') validate('if (%s) {', types.string(name))\n\n      validate('if (%s.length < %d) {', name, node.minLength)\n      error('has less length than allowed')\n      validate('}')\n\n      if (type !== 'string') validate('}')\n    }\n\n    if (node.minimum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)\n      error('is less than minimum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (node.maximum !== undefined) {\n      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))\n\n      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)\n      error('is more than maximum')\n      validate('}')\n\n      if (type !== 'number' && type !== 'integer') validate('}')\n    }\n\n    if (properties) {\n      Object.keys(properties).forEach(function(p) {\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)\n\n        visit(\n          genobj(name, p),\n          properties[p],\n          reporter,\n          filter,\n          schemaPath.concat(tuple ? p : ['properties', p])\n        )\n\n        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')\n      })\n    }\n\n    while (indent--) validate('}')\n  }\n\n  var validate = genfun\n    ('function validate(data) {')\n      // Since undefined is not a valid JSON value, we coerce to null and other checks will catch this\n      ('if (data === undefined) data = null')\n      ('validate.errors = null')\n      ('var errors = 0')\n\n  visit('data', schema, reporter, opts && opts.filter, [])\n\n  validate\n      ('return errors === 0')\n    ('}')\n\n  validate = validate.toFunction(scope)\n  validate.errors = null\n\n  if (Object.defineProperty) {\n    Object.defineProperty(validate, 'error', {\n      get: function() {\n        if (!validate.errors) return ''\n        return validate.errors.map(function(err) {\n          return err.field + ' ' + err.message;\n        }).join('\\n')\n      }\n    })\n  }\n\n  validate.toJSON = function() {\n    return schema\n  }\n\n  return validate\n}\n\nmodule.exports = function(schema, opts) {\n  if (typeof schema === 'string') schema = JSON.parse(schema)\n  return compile(schema, {}, schema, true, opts)\n}\n\nmodule.exports.filter = function(schema, opts) {\n  var validate = module.exports(schema, xtend(opts, {filter: true}))\n  return function(sch) {\n    validate(sch)\n    return sch\n  }\n}\n","\"use strict\"\nfunction isProperty(str) {\n  return /^[$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc][$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc0-9\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19b0-\\u19c0\\u19c8\\u19c9\\u19d0-\\u19d9\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1dc0-\\u1de6\\u1dfc-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f]*$/.test(str)\n}\nmodule.exports = isProperty","'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar gOPD = require('gopd');\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n","/*global Buffer*/\n// Named constants with unique integer values\nvar C = {};\n// Tokens\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;\nvar COLON         = C.COLON         = 0x5;\nvar COMMA         = C.COMMA         = 0x6;\nvar TRUE          = C.TRUE          = 0x7;\nvar FALSE         = C.FALSE         = 0x8;\nvar NULL          = C.NULL          = 0x9;\nvar STRING        = C.STRING        = 0xa;\nvar NUMBER        = C.NUMBER        = 0xb;\n// Tokenizer States\nvar START   = C.START   = 0x11;\nvar STOP    = C.STOP    = 0x12;\nvar TRUE1   = C.TRUE1   = 0x21;\nvar TRUE2   = C.TRUE2   = 0x22;\nvar TRUE3   = C.TRUE3   = 0x23;\nvar FALSE1  = C.FALSE1  = 0x31;\nvar FALSE2  = C.FALSE2  = 0x32;\nvar FALSE3  = C.FALSE3  = 0x33;\nvar FALSE4  = C.FALSE4  = 0x34;\nvar NULL1   = C.NULL1   = 0x41;\nvar NULL2   = C.NULL2   = 0x42;\nvar NULL3   = C.NULL3   = 0x43;\nvar NUMBER1 = C.NUMBER1 = 0x51;\nvar NUMBER3 = C.NUMBER3 = 0x53;\nvar STRING1 = C.STRING1 = 0x61;\nvar STRING2 = C.STRING2 = 0x62;\nvar STRING3 = C.STRING3 = 0x63;\nvar STRING4 = C.STRING4 = 0x64;\nvar STRING5 = C.STRING5 = 0x65;\nvar STRING6 = C.STRING6 = 0x66;\n// Parser States\nvar VALUE   = C.VALUE   = 0x71;\nvar KEY     = C.KEY     = 0x72;\n// Parser Modes\nvar OBJECT  = C.OBJECT  = 0x81;\nvar ARRAY   = C.ARRAY   = 0x82;\n// Character constants\nvar BACK_SLASH =      \"\\\\\".charCodeAt(0);\nvar FORWARD_SLASH =   \"\\/\".charCodeAt(0);\nvar BACKSPACE =       \"\\b\".charCodeAt(0);\nvar FORM_FEED =       \"\\f\".charCodeAt(0);\nvar NEWLINE =         \"\\n\".charCodeAt(0);\nvar CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nvar TAB =             \"\\t\".charCodeAt(0);\n\nvar STRING_BUFFER_SIZE = 64 * 1024;\n\nfunction Parser() {\n  this.tState = START;\n  this.value = undefined;\n\n  this.string = undefined; // string data\n  this.stringBuffer = Buffer.alloc ? Buffer.alloc(STRING_BUFFER_SIZE) : new Buffer(STRING_BUFFER_SIZE);\n  this.stringBufferOffset = 0;\n  this.unicode = undefined; // unicode escapes\n  this.highSurrogate = undefined;\n\n  this.key = undefined;\n  this.mode = undefined;\n  this.stack = [];\n  this.state = VALUE;\n  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n  this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n\n  // Stream offset\n  this.offset = -1;\n}\n\n// Slow code to string converter (only used when throwing syntax errors)\nParser.toknam = function (code) {\n  var keys = Object.keys(C);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (C[key] === code) { return key; }\n  }\n  return code && (\"0x\" + code.toString(16));\n};\n\nvar proto = Parser.prototype;\nproto.onError = function (err) { throw err; };\nproto.charError = function (buffer, i) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n};\nproto.appendStringChar = function (char) {\n  if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8');\n    this.stringBufferOffset = 0;\n  }\n\n  this.stringBuffer[this.stringBufferOffset++] = char;\n};\nproto.appendStringBuf = function (buf, start, end) {\n  var size = buf.length;\n  if (typeof start === 'number') {\n    if (typeof end === 'number') {\n      if (end < 0) {\n        // adding a negative end decreeses the size\n        size = buf.length - start + end;\n      } else {\n        size = end - start;\n      }\n    } else {\n      size = buf.length - start;\n    }\n  }\n\n  if (size < 0) {\n    size = 0;\n  }\n\n  if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {\n    this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n    this.stringBufferOffset = 0;\n  }\n\n  buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);\n  this.stringBufferOffset += size;\n};\nproto.write = function (buffer) {\n  if (typeof buffer === \"string\") buffer = new Buffer(buffer);\n  var n;\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    if (this.tState === START){\n      n = buffer[i];\n      this.offset++;\n      if(n === 0x7b){ this.onToken(LEFT_BRACE, \"{\"); // {\n      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, \"}\"); // }\n      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, \"[\"); // [\n      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, \"]\"); // ]\n      }else if(n === 0x3a){ this.onToken(COLON, \":\");  // :\n      }else if(n === 0x2c){ this.onToken(COMMA, \",\"); // ,\n      }else if(n === 0x74){ this.tState = TRUE1;  // t\n      }else if(n === 0x66){ this.tState = FALSE1;  // f\n      }else if(n === 0x6e){ this.tState = NULL1; // n\n      }else if(n === 0x22){ // \"\n        this.string = \"\";\n        this.stringBufferOffset = 0;\n        this.tState = STRING1;\n      }else if(n === 0x2d){ this.string = \"-\"; this.tState = NUMBER1; // -\n      }else{\n        if (n >= 0x30 && n < 0x40) { // 1-9\n          this.string = String.fromCharCode(n); this.tState = NUMBER3;\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {\n          // whitespace\n        } else {\n          return this.charError(buffer, i);\n        }\n      }\n    }else if (this.tState === STRING1){ // After open quote\n      n = buffer[i]; // get current byte from buffer\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];\n        }\n\n        this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n        i = i + j - 1;\n      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n        if (n <= 193 || n > 244) {\n          return this.onError(new Error(\"Invalid UTF-8 character at position \" + i + \" in state \" + Parser.toknam(this.tState)));\n        }\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split\n          for (var k = 0; k <= (buffer.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;\n          i = buffer.length - 1;\n        } else {\n          this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);\n          i = i + this.bytes_in_sequence - 1;\n        }\n      } else if (n === 0x22) {\n        this.tState = START;\n        this.string += this.stringBuffer.toString('utf8', 0, this.stringBufferOffset);\n        this.stringBufferOffset = 0;\n        this.onToken(STRING, this.string);\n        this.offset += Buffer.byteLength(this.string, 'utf8') + 1;\n        this.string = undefined;\n      }\n      else if (n === 0x5c) {\n        this.tState = STRING2;\n      }\n      else if (n >= 0x20) { this.appendStringChar(n); }\n      else {\n          return this.charError(buffer, i);\n      }\n    }else if (this.tState === STRING2){ // After backslash\n      n = buffer[i];\n      if(n === 0x22){ this.appendStringChar(n); this.tState = STRING1;\n      }else if(n === 0x5c){ this.appendStringChar(BACK_SLASH); this.tState = STRING1;\n      }else if(n === 0x2f){ this.appendStringChar(FORWARD_SLASH); this.tState = STRING1;\n      }else if(n === 0x62){ this.appendStringChar(BACKSPACE); this.tState = STRING1;\n      }else if(n === 0x66){ this.appendStringChar(FORM_FEED); this.tState = STRING1;\n      }else if(n === 0x6e){ this.appendStringChar(NEWLINE); this.tState = STRING1;\n      }else if(n === 0x72){ this.appendStringChar(CARRIAGE_RETURN); this.tState = STRING1;\n      }else if(n === 0x74){ this.appendStringChar(TAB); this.tState = STRING1;\n      }else if(n === 0x75){ this.unicode = \"\"; this.tState = STRING3;\n      }else{\n        return this.charError(buffer, i);\n      }\n    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes\n      n = buffer[i];\n      // 0-9 A-F a-f\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {\n        this.unicode += String.fromCharCode(n);\n        if (this.tState++ === STRING6) {\n          var intVal = parseInt(this.unicode, 16);\n          this.unicode = undefined;\n          if (this.highSurrogate !== undefined && intVal >= 0xDC00 && intVal < (0xDFFF + 1)) { //<56320,57343> - lowSurrogate\n            this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal)));\n            this.highSurrogate = undefined;\n          } else if (this.highSurrogate === undefined && intVal >= 0xD800 && intVal < (0xDBFF + 1)) { //<55296,56319> - highSurrogate\n            this.highSurrogate = intVal;\n          } else {\n            if (this.highSurrogate !== undefined) {\n              this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate)));\n              this.highSurrogate = undefined;\n            }\n            this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));\n          }\n          this.tState = STRING1;\n        }\n      } else {\n        return this.charError(buffer, i);\n      }\n    } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {\n        n = buffer[i];\n\n        switch (n) {\n          case 0x30: // 0\n          case 0x31: // 1\n          case 0x32: // 2\n          case 0x33: // 3\n          case 0x34: // 4\n          case 0x35: // 5\n          case 0x36: // 6\n          case 0x37: // 7\n          case 0x38: // 8\n          case 0x39: // 9\n          case 0x2e: // .\n          case 0x65: // e\n          case 0x45: // E\n          case 0x2b: // +\n          case 0x2d: // -\n            this.string += String.fromCharCode(n);\n            this.tState = NUMBER3;\n            break;\n          default:\n            this.tState = START;\n            var result = Number(this.string);\n\n            if (isNaN(result)){\n              return this.charError(buffer, i);\n            }\n\n            if ((this.string.match(/[0-9]+/) == this.string) && (result.toString() != this.string)) {\n              // Long string of digits which is an ID string and not valid and/or safe JavaScript integer Number\n              this.onToken(STRING, this.string);\n            } else {\n              this.onToken(NUMBER, result);\n            }\n\n            this.offset += this.string.length - 1;\n            this.string = undefined;\n            i--;\n            break;\n        }\n    }else if (this.tState === TRUE1){ // r\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === TRUE2){ // u\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === TRUE3){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); this.offset+= 3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE1){ // a\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE2){ // l\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE3){ // s\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === FALSE4){ // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); this.offset+= 4; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL1){ // u\n      if (buffer[i] === 0x75) { this.tState = NULL2; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL2){ // l\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }\n      else { return this.charError(buffer, i); }\n    }else if (this.tState === NULL3){ // l\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); this.offset += 3; }\n      else { return this.charError(buffer, i); }\n    }\n  }\n};\nproto.onToken = function (token, value) {\n  // Override this to get events\n};\n\nproto.parseError = function (token, value) {\n  this.tState = STOP;\n  this.onError(new Error(\"Unexpected \" + Parser.toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + Parser.toknam(this.state)));\n};\nproto.push = function () {\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});\n};\nproto.pop = function () {\n  var value = this.value;\n  var parent = this.stack.pop();\n  this.value = parent.value;\n  this.key = parent.key;\n  this.mode = parent.mode;\n  this.emit(value);\n  if (!this.mode) { this.state = VALUE; }\n};\nproto.emit = function (value) {\n  if (this.mode) { this.state = COMMA; }\n  this.onValue(value);\n};\nproto.onValue = function (value) {\n  // Override me\n};\nproto.onToken = function (token, value) {\n  if(this.state === VALUE){\n    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){\n      if (this.value) {\n        this.value[this.key] = value;\n      }\n      this.emit(value);\n    }else if(token === LEFT_BRACE){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = {};\n      } else {\n        this.value = {};\n      }\n      this.key = undefined;\n      this.state = KEY;\n      this.mode = OBJECT;\n    }else if(token === LEFT_BRACKET){\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = [];\n      } else {\n        this.value = [];\n      }\n      this.key = 0;\n      this.mode = ARRAY;\n      this.state = VALUE;\n    }else if(token === RIGHT_BRACE){\n      if (this.mode === OBJECT) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    }else if(token === RIGHT_BRACKET){\n      if (this.mode === ARRAY) {\n        this.pop();\n      } else {\n        return this.parseError(token, value);\n      }\n    }else{\n      return this.parseError(token, value);\n    }\n  }else if(this.state === KEY){\n    if (token === STRING) {\n      this.key = value;\n      this.state = COLON;\n    } else if (token === RIGHT_BRACE) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  }else if(this.state === COLON){\n    if (token === COLON) { this.state = VALUE; }\n    else { return this.parseError(token, value); }\n  }else if(this.state === COMMA){\n    if (token === COMMA) {\n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }\n      else if (this.mode === OBJECT) { this.state = KEY; }\n\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {\n      this.pop();\n    } else {\n      return this.parseError(token, value);\n    }\n  }else{\n    return this.parseError(token, value);\n  }\n};\n\nParser.C = C;\n\nmodule.exports = Parser;\n","var hasExcape = /~/\nvar escapeMatcher = /~[01]/g\nfunction escapeReplacer (m) {\n  switch (m) {\n    case '~1': return '/'\n    case '~0': return '~'\n  }\n  throw new Error('Invalid tilde escape: ' + m)\n}\n\nfunction untilde (str) {\n  if (!hasExcape.test(str)) return str\n  return str.replace(escapeMatcher, escapeReplacer)\n}\n\nfunction setter (obj, pointer, value) {\n  var part\n  var hasNextPart\n\n  for (var p = 1, len = pointer.length; p < len;) {\n    if (pointer[p] === 'constructor' || pointer[p] === 'prototype' || pointer[p] === '__proto__') return obj\n\n    part = untilde(pointer[p++])\n    hasNextPart = len > p\n\n    if (typeof obj[part] === 'undefined') {\n      // support setting of /-\n      if (Array.isArray(obj) && part === '-') {\n        part = obj.length\n      }\n\n      // support nested objects/array when setting values\n      if (hasNextPart) {\n        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []\n        else obj[part] = {}\n      }\n    }\n\n    if (!hasNextPart) break\n    obj = obj[part]\n  }\n\n  var oldValue = obj[part]\n  if (value === undefined) delete obj[part]\n  else obj[part] = value\n  return oldValue\n}\n\nfunction compilePointer (pointer) {\n  if (typeof pointer === 'string') {\n    pointer = pointer.split('/')\n    if (pointer[0] === '') return pointer\n    throw new Error('Invalid JSON pointer.')\n  } else if (Array.isArray(pointer)) {\n    for (const part of pointer) {\n      if (typeof part !== 'string' && typeof part !== 'number') {\n        throw new Error('Invalid JSON pointer. Must be of type string or number.')\n      }\n    }\n    return pointer\n  }\n\n  throw new Error('Invalid JSON pointer.')\n}\n\nfunction get (obj, pointer) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  var len = pointer.length\n  if (len === 1) return obj\n\n  for (var p = 1; p < len;) {\n    obj = obj[untilde(pointer[p++])]\n    if (len === p) return obj\n    if (typeof obj !== 'object' || obj === null) return undefined\n  }\n}\n\nfunction set (obj, pointer, value) {\n  if (typeof obj !== 'object') throw new Error('Invalid input object.')\n  pointer = compilePointer(pointer)\n  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')\n  return setter(obj, pointer, value)\n}\n\nfunction compile (pointer) {\n  var compiled = compilePointer(pointer)\n  return {\n    get: function (object) {\n      return get(object, compiled)\n    },\n    set: function (object, value) {\n      return set(object, compiled, value)\n    }\n  }\n}\n\nexports.get = get\nexports.set = set\nexports.compile = compile\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncify;\n\nvar _initialParams = require('./internal/initialParams.js');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if ((0, _wrapAsync.isAsync)(func)) {\n        return function (...args /*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback);\n        };\n    }\n\n    return (0, _initialParams2.default)(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback);\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        (0, _setImmediate2.default)(e => {\n            throw e;\n        }, err);\n    }\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachOfLimit = require('./internal/eachOfLimit.js');\n\nvar _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);\n\nvar _withoutIndex = require('./internal/withoutIndex.js');\n\nvar _withoutIndex2 = _interopRequireDefault(_withoutIndex);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachLimit(coll, limit, iteratee, callback) {\n  return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);\n}\nexports.default = (0, _awaitify2.default)(eachLimit, 4);\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eachLimit = require('./eachLimit.js');\n\nvar _eachLimit2 = _interopRequireDefault(_eachLimit);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n * in series and therefore the iteratee functions will complete in order.\n\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachSeries(coll, iteratee, callback) {\n  return (0, _eachLimit2.default)(coll, 1, iteratee, callback);\n}\nexports.default = (0, _awaitify2.default)(eachSeries, 3);\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = asyncEachOfLimit;\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return;\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({ value, done: iterDone }) => {\n            //console.log('got value', value)\n            if (canceled || done) return;\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return;\n        if (err) return handleError(err);\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return;\n        }\n\n        if (result === _breakLoop2.default || done && running <= 0) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return;\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = awaitify;\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify(asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined');\n    function awaitable(...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args);\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err);\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        });\n    }\n\n    return awaitable;\n}\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\nexports.default = breakLoop;\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _iterator = require('./iterator.js');\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _onlyOnce = require('./onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./wrapAsync.js');\n\nvar _asyncEachOfLimit = require('./asyncEachOfLimit.js');\n\nvar _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);\n\nvar _breakLoop = require('./breakLoop.js');\n\nvar _breakLoop2 = _interopRequireDefault(_breakLoop);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = limit => {\n    return (obj, iteratee, callback) => {\n        callback = (0, _once2.default)(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1');\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);\n        }\n        if ((0, _wrapAsync.isAsyncIterable)(obj)) {\n            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);\n        }\n        var nextElem = (0, _iterator2.default)(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return;\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (err === false) {\n                done = true;\n                canceled = true;\n            } else if (value === _breakLoop2.default || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n};\n\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (fn) {\n    return function (...args /*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n};\n\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isArrayLike;\nfunction isArrayLike(value) {\n    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;\n}\nmodule.exports = exports['default'];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = createIterator;\n\nvar _isArrayLike = require('./isArrayLike.js');\n\nvar _isArrayLike2 = _interopRequireDefault(_isArrayLike);\n\nvar _getIterator = require('./getIterator.js');\n\nvar _getIterator2 = _interopRequireDefault(_getIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? { value: obj[key], key } : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if ((0, _isArrayLike2.default)(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = (0, _getIterator2.default)(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\nmodule.exports = exports['default'];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = once;\nfunction once(fn) {\n    function wrapper(...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper;\n}\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = onlyOnce;\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fallback = fallback;\nexports.wrap = wrap;\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nexports.default = wrap(_defer);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _withoutIndex;\nfunction _withoutIndex(iteratee) {\n    return (value, index, callback) => iteratee(value, callback);\n}\nmodule.exports = exports[\"default\"];","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;\n\nvar _asyncify = require('../asyncify.js');\n\nvar _asyncify2 = _interopRequireDefault(_asyncify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function');\n    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;\n}\n\nexports.default = wrapAsync;\nexports.isAsync = isAsync;\nexports.isAsyncGenerator = isAsyncGenerator;\nexports.isAsyncIterable = isAsyncIterable;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _awaitify = require('./internal/awaitify.js');\n\nvar _awaitify2 = _interopRequireDefault(_awaitify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall(tasks, callback) {\n    callback = (0, _once2.default)(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        task(...args, (0, _onlyOnce2.default)(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return;\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nexports.default = (0, _awaitify2.default)(waterfall);\nmodule.exports = exports['default'];","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Load the schema and metadata from a package file\n*\n* @method loadFromPackageFile\n* @return {Object} Returns a new Meadow, or false if it failed\n*/\nvar loadFromPackageFile = function(pMeadow, pPackage)\n{\n\t// Use the package loader to grab the configuration objects and clone a new Meadow.\n\tvar tmpPackage = false;\n\ttry\n\t{\n\t\ttmpPackage = require(pPackage);\n\t}\n\tcatch(pError)\n\t{\n\t\tpMeadow.fable.log.error('Error loading Fable package', {Package:pPackage});\n\t\treturn false;\n\t}\n\n\t// Spool up a new Meadow object\n\tvar tmpNewMeadow = pMeadow.new(pMeadow.fable);\n\n\t// Safely set the parameters\n\tif (typeof(tmpPackage.Scope) === 'string')\n\t{\n\t\ttmpNewMeadow.setScope(tmpPackage.Scope);\n\t}\n\t\n\tif (typeof(tmpPackage.Domain) === 'string')\n\t{\n\t\ttmpNewMeadow.setDomain(tmpPackage.Domain);\n\t}\n\n\tif (typeof(tmpPackage.DefaultIdentifier) === 'string')\n\t{\n\t\ttmpNewMeadow.setDefaultIdentifier(tmpPackage.DefaultIdentifier);\n\t}\n\tif (Array.isArray(tmpPackage.Schema))\n\t{\n\t\ttmpNewMeadow.setSchema(tmpPackage.Schema);\n\t}\n\tif (typeof(tmpPackage.JsonSchema) === 'object')\n\t{\n\t\ttmpNewMeadow.setJsonSchema(tmpPackage.JsonSchema);\n\t}\n\tif (typeof(tmpPackage.DefaultObject) === 'object')\n\t{\n\t\ttmpNewMeadow.setDefault(tmpPackage.DefaultObject);\n\t}\n\n\tif (typeof(tmpPackage.Authorization) === 'object')\n\t{\n\t\ttmpNewMeadow.setAuthorizer(tmpPackage.Authorization);\n\t}\n\n\treturn tmpNewMeadow;\n};\n\nmodule.exports = loadFromPackageFile;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Load the schema and metadata from a package object\n*\n* @method loadFromPackageObject\n* @return {Object} Returns a new Meadow, or false if it failed\n*/\nvar loadFromPackageObject = function(pMeadow, pPackage)\n{\n\t// Use the package loader to grab the configuration objects and clone a new Meadow.\n\tvar tmpPackage = (typeof(pPackage) == 'object') ? pPackage : {};\n\n\tif (!pPackage.hasOwnProperty('Scope'))\n\t{\n\t\tpMeadow.fable.log.error('Error loading Fable package -- scope not defined.', {Package:pPackage});\n\t}\n\n\t// Spool up a new Meadow object\n\tvar tmpNewMeadow = pMeadow.new(pMeadow.fable);\n\n\t// Safely set the parameters\n\tif (typeof(tmpPackage.Scope) === 'string')\n\t{\n\t\ttmpNewMeadow.setScope(tmpPackage.Scope);\n\t}\n\t\n\tif (typeof(tmpPackage.Domain) === 'string')\n\t{\n\t\ttmpNewMeadow.setDomain(tmpPackage.Domain);\n\t}\n\n\tif (typeof(tmpPackage.DefaultIdentifier) === 'string')\n\t{\n\t\ttmpNewMeadow.setDefaultIdentifier(tmpPackage.DefaultIdentifier);\n\t}\n\tif (Array.isArray(tmpPackage.Schema))\n\t{\n\t\ttmpNewMeadow.setSchema(tmpPackage.Schema);\n\t}\n\tif (typeof(tmpPackage.JsonSchema) === 'object')\n\t{\n\t\ttmpNewMeadow.setJsonSchema(tmpPackage.JsonSchema);\n\t}\n\tif (typeof(tmpPackage.DefaultObject) === 'object')\n\t{\n\t\ttmpNewMeadow.setDefault(tmpPackage.DefaultObject);\n\t}\n\n\tif (typeof(tmpPackage.Authorization) === 'object')\n\t{\n\t\ttmpNewMeadow.setAuthorizer(tmpPackage.Authorization);\n\t}\n\n\treturn tmpNewMeadow;\n};\n\nmodule.exports = loadFromPackageObject;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libFS = require('fs');\n\n/**\n* ### Meadow Raw Query Library\n*\n* This library loads and stores raw queries for FoxHound to use.\n* You can overload the default query that is built for each of\n* the following query archetypes:\n*\n* `Create`, `Read`, `Reads`, `Update`, `Delete`, `Count`\n*\n* You can also load other custom queries and give them an\n* arbitrary name.\n*\n* @class MeadowRawQuery\n*/\nvar MeadowRawQuery = function()\n{\n\tfunction createNew(pMeadow)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pMeadow) !== 'object') || !('fable' in pMeadow))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Meadow = pMeadow;\n\n\t\tvar _Queries = {};\n\n\n\t\t/**\n\t\t* Load a Custom Query from a File\n\t\t*\n\t\t* @method doLoadQuery\n\t\t*/\n\t\tfunction doLoadQuery(pQueryTag, pFileName, fCallBack)\n\t\t{\n\t\t\tvar tmpCallBack = (typeof(fCallBack) === 'function') ? fCallBack : function() {};\n\n\t\t\tlibFS.readFile(pFileName, 'utf8',\n\t\t\t\tfunction (pError, pData)\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\t_Meadow.fable.log.error('Problem loading custom query file.', {QueryTag:pQueryTag, FileName:pFileName, Error:pError});\n\t\t\t\t\t\t// There is some debate whether we should leave the queries entry unset or set it to empty so nothing happens.\n\t\t\t\t\t\t// If this were to set the query to `false` instead of `''`, FoxHound would be used to generate a query.\n\t\t\t\t\t\tdoSetQuery(pQueryTag, '');\n\t\t\t\t\t\ttmpCallBack(false);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_Meadow.fable.log.trace('Loaded custom query file.', {QueryTag:pQueryTag, FileName:pFileName});\n\t\t\t\t\t\tdoSetQuery(pQueryTag, pData);\n\t\t\t\t\t\ttmpCallBack(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\treturn _Meadow;\n\t\t}\n\n\n\t\t/**\n\t\t* Sets a Custom Query from a String\n\t\t*\n\t\t* @method doSetQuery\n\t\t*/\n\t\tfunction doSetQuery(pQueryTag, pQueryString)\n\t\t{\n\t\t\t_Queries[pQueryTag] = pQueryString;\n\t\t\treturn _Meadow;\n\t\t}\n\n\n\t\t/**\n\t\t* Returns a Custom Query if one has been set for this tag\n\t\t*\n\t\t* @method doGetQuery\n\t\t*/\n\t\tfunction doGetQuery(pQueryTag)\n\t\t{\n\t\t\tif (_Queries.hasOwnProperty(pQueryTag))\n\t\t\t{\n\t\t\t\treturn _Queries[pQueryTag];\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\n\t\t/**\n\t\t* Check if a Custom Query exists\n\t\t*\n\t\t* @method doCheckQuery\n\t\t*/\n\t\tfunction doCheckQuery(pQueryTag)\n\t\t{\n\t\t\treturn _Queries.hasOwnProperty(pQueryTag);\n\t\t}\n\n\t\tvar tmpNewMeadowRawQuery = (\n\t\t{\n\t\t\tloadQuery: doLoadQuery,\n\t\t\tsetQuery: doSetQuery,\n\n\t\t\tcheckQuery: doCheckQuery,\n\t\t\tgetQuery: doGetQuery,\n\n\t\t\tnew: createNew\n\t\t});\n\n\t\treturn tmpNewMeadowRawQuery;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowRawQuery();\n","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libValidator = require('is-my-json-valid');\n\n/**\n* @class MeadowSchema\n*/\nvar MeadowSchema = function()\n{\n\tfunction createNew(pOriginalJsonSchema, pOriginalSchema)\n\t{\n\t\t/* ^ An Example Meadow Schema Object\n\t\t    [\n\t\t    \t{ \"Column\": \"IDAnimal\", \"Type\":\"AutoIdentity\" },\n\t\t    \t{ \"Column\": \"GUIDAnimal\", \"Type\":\"AutoGUID\" },\n\t\t    \t{ \"Column\": \"Created\", \"Type\":\"CreateDate\" },\n\t\t    \t{ \"Column\": \"CreatingIDUser\", \"Type\":\"CreateIDUser\" },\n\t\t    \t{ \"Column\": \"Modified\", \"Type\":\"UpdateDate\" },\n\t\t    \t{ \"Column\": \"ModifyingIDUser\", \"Type\":\"UpdateIDUser\" },\n\t\t    \t{ \"Column\": \"Deleted\", \"Type\":\"Deleted\" },\n\t\t    \t{ \"Column\": \"DeletingIDUser\", \"Type\":\"DeleteIDUser\" },\n\t\t    \t{ \"Column\": \"DeleteDate\", \"Type\":\"DeleteDate\" }\n\t\t    ]\n\t\t*/\n\t\t/* #### The Meadow Schema\n\t\t *\n\t\t * Meadow uses this description object to create queries, broker data and generate interfaces.\n\t\t */\n\t\tvar _Schema = false;\n\n\t\t/* ^ An Example JSONSchema Object:\n\t\t    \t{\n\t\t    \t\t\"$schema\": \"http://json-schema.org/draft-04/schema#\",\n\t\t    \t\t\"title\": \"Product\",\n\t\t    \t\t\"description\": \"A product from Acme's catalog\",\n\t\t    \t\t\"type\": \"object\",\n\t\t    \t\t\"properties\": {\n\t\t    \t\t\t\"id\": {\n\t\t    \t\t\t\t\"description\": \"The unique identifier for a product\",\n\t\t    \t\t\t\t\"type\": \"integer\"\n\t\t    \t\t\t},\n\t\t    \t\t\t\"name\": {\n\t\t    \t\t\t\t\"description\": \"Name of the product\",\n\t\t    \t\t\t\t\"type\": \"string\"\n\t\t    \t\t\t},\n\t\t    \t\t\t\"price\": {\n\t\t    \t\t\t\t\"type\": \"number\",\n\t\t    \t\t\t\t\"minimum\": 0,\n\t\t    \t\t\t\t\"exclusiveMinimum\": true\n\t\t    \t\t\t},\n\t\t    \t\t\t\"tags\": {\n\t\t    \t\t\t\t\"type\": \"array\",\n\t\t    \t\t\t\t\"items\": {\n\t\t    \t\t\t\t\t\"type\": \"string\"\n\t\t    \t\t\t\t},\n\t\t    \t\t\t\t\"minItems\": 1,\n\t\t    \t\t\t\t\"uniqueItems\": true\n\t\t    \t\t\t}\n\t\t    \t\t},\n\t\t    \t\t\"required\": [\"id\", \"name\", \"price\"]\n\t\t    \t}\n\t\t*/\n\t\t/* #### A JSONSchema Description\n\t\t *\n\t\t * http://json-schema.org/examples.html\n\t\t *\n\t\t * http://json-schema.org/latest/json-schema-core.html\n\t\t */\n\t\tvar _JsonSchema = false;\n\n\t\t/* #### An \"empty\" ORM object\n\t\t * This is the basis for being filled out by the marshalling code.\n\t\t */\n\t\tvar _Default = false;\n\n\t\t// The cached validator, which uses the JSONSchema\n\t\tvar _Validate = false;\n\n\t\t// The authorizers available to this meadow object\n\t\tvar _Authorizers = {};\n\n\n\t\t/**\n\t\t* Set the Meadow schema\n\t\t*\n\t\t* Our schemas are really instructions for *what* to do *when*.  We track:\n\t\t*   - Column\n\t\t*   - Type _(e.g. AutoIdentity, AutoGUID, CreateDate, CreateIDUser, UpdateDate, UpdateIDUser, DeleteDate, Deleted, DeleteIDUser)_\n\t\t*   - Optionally Special Instractions\n\t\t*\n\t\t* @method setSchema\n\t\t*/\n\t\tvar setSchema = function(pSchema)\n\t\t{\n\t\t\t_Schema = (typeof(pSchema) === 'object') ? pSchema : (\n\t\t\t{\n\t\t\t\ttitle: 'Unknown',\n\t\t\t\ttype: 'object',\n\t\t\t\trequired: []\n\t\t\t});\n\t\t};\n\t\tsetSchema(pOriginalSchema);\n\n\t\t/**\n\t\t* Set the JSONSchema\n\t\t*\n\t\t* @method setJsonSchema\n\t\t*/\n\t\tvar setJsonSchema = function(pJsonSchema)\n\t\t{\n\t\t\t_JsonSchema = (typeof(pJsonSchema) === 'object') ? pJsonSchema : (\n\t\t\t{\n\t\t\t\ttitle: 'Unknown',\n\t\t\t\ttype: 'object',\n\t\t\t\trequired: []\n\t\t\t});\n\t\t\t_Validate = libValidator(_JsonSchema, { greedy:true, verbose:true });\n\t\t};\n\t\tsetJsonSchema(pOriginalJsonSchema);\n\n\t\t/**\n\t\t* Set the Default ORM object\n\t\t*\n\t\t* @method setDefault\n\t\t*/\n\t\tvar setDefault = function(pDefault)\n\t\t{\n\t\t\t_Default = (typeof(pDefault) === 'object') ? pDefault : {};\n\t\t};\n\t\tsetDefault();\n\n\t\t/**\n\t\t* Set the authorizer set\n\t\t*\n\t\t* @method setAuthorizer\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setAuthorizer = function(pAuthorizer)\n\t\t{\n\t\t\t_Authorizers = (typeof(pAuthorizer) === 'object') ? pAuthorizer : {};\n\t\t};\n\n\t\t/**\n\t\t* Validate an object against the current schema\n\t\t*\n\t\t* @method validateObject\n\t\t*/\n\t\tvar validateObject = function(pObject)\n\t\t{\n\t\t\tvar tmpValidation = { Valid:_Validate(pObject) };\n\n\t\t\t// Stuff the errors in if it is invalid\n\t\t\tif (!tmpValidation.Valid)\n\t\t\t{\n\t\t\t\ttmpValidation.Errors = _Validate.errors;\n\t\t\t}\n\n\t\t\treturn tmpValidation;\n\t\t};\n\n\n\t\tvar tmpNewMeadowSchemaObject = (\n\t\t{\n\t\t\tsetSchema: setSchema,\n\t\t\tsetJsonSchema: setJsonSchema,\n\t\t\tsetDefault: setDefault,\n\t\t\tsetAuthorizer: setAuthorizer,\n\t\t\tvalidateObject: validateObject,\n\n\t\t\tnew: createNew\n\t\t});\n\n\t\t/**\n\t\t * The Meadow Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'schema',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\t/**\n\t\t * The JsonSchema\n\t\t *\n\t\t * @property jsonSchema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'jsonSchema',\n\t\t\t{\n\t\t\t\tget: function() { return _JsonSchema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\t/**\n\t\t * Default Object\n\t\t *\n\t\t * @property defaultObject\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'defaultObject',\n\t\t\t{\n\t\t\t\tget: function() { return _Default; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\t/**\n\t\t * Authorizer\n\t\t *\n\t\t * @property defaultObject\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowSchemaObject, 'authorizer',\n\t\t\t{\n\t\t\t\tget: function() { return _Authorizers; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\n\t\treturn tmpNewMeadowSchemaObject;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowSchema();\n","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libFoxHound = require('foxhound');\n\n/**\n* Meadow Data Broker Library\n*\n* @class Meadow\n*/\nvar Meadow = function()\n{\n\tfunction createNew(pFable, pScope, pJsonSchema, pSchema)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pFable) !== 'object') || !('fable' in pFable))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\t// Make sure there is a valid data broker set\n\t\t_Fable.settingsManager.fill({MeadowProvider:'None'});\n\n\t\tvar _IDUser = 0;\n\n\t\t// The scope of this broker.\n\t\tvar _Scope = (typeof(pScope) === 'string') ? pScope : 'Unknown';\n\t\tvar _Domain = 'Default';\n\n\t\t// The schema for this broker\n\t\tvar _Schema = require('./Meadow-Schema.js').new(pJsonSchema, pSchema);\n\t\t// The query for this broker\n\t\tvar _Query = libFoxHound.new(_Fable).setScope(_Scope);\n\t\t// The custom query loader\n\t\tvar _RawQueries = require('./Meadow-RawQuery.js').new(_Fable);\n\n\t\t// The core behaviors.. abstracted into their own modules to encapsulate complexity\n\t\tvar _CreateBehavior = require('./behaviors/Meadow-Create.js');\n\t\tvar _ReadBehavior = require('./behaviors/Meadow-Read.js');\n\t\tvar _ReadsBehavior = require('./behaviors/Meadow-Reads.js');\n\t\tvar _UpdateBehavior = require('./behaviors/Meadow-Update.js');\n\t\tvar _DeleteBehavior = require('./behaviors/Meadow-Delete.js');\n\t\tvar _UndeleteBehavior = require('./behaviors/Meadow-Undelete.js');\n\t\tvar _CountBehavior = require('./behaviors/Meadow-Count.js');\n\n\t\t// The data provider\n\t\tvar _Provider = false;\n\t\tvar _ProviderName = false;\n\n\t\t// The default identifier for this broker.\n\t\t// This is what is used for the automated endpoint queries\n\t\t// For example the 198 in GET http://myapi.com/Widget/198\n\t\t//\n\t\t// Our development model prefers IDWidget as the column name for the default identifier.\n\t\tvar _DefaultIdentifier = 'ID'+_Scope;\n\t\tvar _DefaultGUIdentifier = 'GUID'+_Scope;\n\n\n\t\t/**\n\t\t * Load a Meadow Package JSON, create a Meadow object from it.\n\t\t */\n\t\tvar _MeadowPackageLoader = require('./Meadow-PackageFileLoader.js');\n\t\tvar loadFromPackage = function(pPackage)\n\t\t{\n\t\t\treturn _MeadowPackageLoader(this, pPackage);\n\t\t};\n\n\t\t/**\n\t\t * Load a Meadow Package JSON from file, create a Meadow object from it.\n\t\t */\n\t\tvar _MeadowPackageObjectLoader = require('./Meadow-PackageObjectLoader.js');\n\t\tvar loadFromPackageObject = function(pPackage)\n\t\t{\n\t\t\treturn _MeadowPackageObjectLoader(this, pPackage);\n\t\t};\n\n\t\t/**\n\t\t* Pass relevant state into the provider\n\t\t*\n\t\t* @method updateProviderState\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar updateProviderState = ()=>\n\t\t{\n\t\t\tif (typeof(_Provider.setSchema) === 'function')\n\t\t\t{\n\t\t\t\t_Provider.setSchema(_Scope, _Schema.schema, _DefaultIdentifier, _DefaultGUIdentifier);\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the scope\n\t\t*\n\t\t* @method setScope\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar setScope = function(pScope)\n\t\t{\n\t\t\t_Scope = pScope;\n\t\t\t_Query.setScope(pScope);\n\t\t\tupdateProviderState();\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the user ID for inserts and updates\n\t\t*\n\t\t* @method setIDUser\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar setIDUser = function(pIDUser)\n\t\t{\n\t\t\t_IDUser = pIDUser;\n\t\t\treturn this;\n\t\t};\n\n\n\t\t/**\n\t\t* Set the Provider for Query execution.\n\t\t*\n\t\t* This function expects a string, case sensitive, which matches the\n\t\t* provider filename\n\t\t*\n\t\t* @method setProvider\n\t\t* @param {String} pProviderName The provider for query generation.\n\t\t* @return {Object} Returns the current Meadow for chaining.\n\t\t*/\n\t\tvar _PROVIDERS = (\n\t\t{\n\t\t\t'ALASQL': require(`./providers/Meadow-Provider-ALASQL.js`),\n\t\t\t'MeadowEndpoints': require(`./providers/Meadow-Provider-MeadowEndpoints.js`),\n\t\t\t'MySQL': require(`./providers/Meadow-Provider-MySQL.js`),\n\t\t\t'None': require(`./providers/Meadow-Provider-None.js`),\n\t\t});\n\t\tvar setProvider = function(pProviderName)\n\t\t{\n\t\t\tif (typeof(pProviderName) !== 'string')\n\t\t\t{\n\t\t\t\tpProviderName = 'None';\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_Provider = _PROVIDERS[pProviderName].new(_Fable);\n\t\t\t\t// Give the provider access to the schema object\n\t\t\t\tupdateProviderState();\n\n\t\t\t\t_ProviderName = pProviderName;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\t_Fable.log.error('Provider not set - require load problem', {InvalidProvider:pProviderName, error:pError});\n\t\t\t\tsetProvider('None');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\t\tsetProvider(_Fable.settings.MeadowProvider);\n\n\t\t/**\n\t\t* Set the schema to be something else\n\t\t*\n\t\t* @method setSchema\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setSchema = function(pSchema)\n\t\t{\n\t\t\t_Schema.setSchema(pSchema);\n\t\t\tupdateProviderState();\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the Jsonschema to be something else\n\t\t*\n\t\t* @method setJsonSchema\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setJsonSchema = function(pJsonSchema)\n\t\t{\n\t\t\t_Schema.setJsonSchema(pJsonSchema);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the default object to be something else\n\t\t*\n\t\t* @method setDefault\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setDefault = function(pDefault)\n\t\t{\n\t\t\t_Schema.setDefault(pDefault);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the authorizer set\n\t\t*\n\t\t* @method setAuthorizer\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setAuthorizer = function(pAuthorizer)\n\t\t{\n\t\t\t_Schema.setAuthorizer(pAuthorizer);\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the domain\n\t\t*\n\t\t* @method setDomain\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setDomain = function(pDomain)\n\t\t{\n\t\t\t_Domain = pDomain;\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t* Set the default identifier\n\t\t*\n\t\t* @method setDefaultIdentifier\n\t\t* @return {Object} This is chainable.\n\t\t*/\n\t\tvar setDefaultIdentifier = function(pDefaultIdentifier)\n\t\t{\n\t\t\t_DefaultIdentifier = pDefaultIdentifier;\n\t\t\t_DefaultGUIdentifier = 'GU' + pDefaultIdentifier;\n\t\t\tupdateProviderState();\n\t\t\treturn this;\n\t\t};\n\n\t\t/**\n\t\t * Create a record\n\t\t */\n\t\tvar doCreate = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _CreateBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Read a record\n\t\t */\n\t\tvar doRead = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _ReadBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Read multiple records\n\t\t */\n\t\tvar doReads = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _ReadsBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\n\t\t/**\n\t\t * Update a record\n\t\t */\n\t\tvar doUpdate = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _UpdateBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\n\t\t/**\n\t\t * Delete a record\n\t\t */\n\t\tvar doDelete = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _DeleteBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Undelete a record\n\t\t */\n\t\tvar doUndelete = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _UndeleteBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Count multiple records\n\t\t */\n\t\tvar doCount = function(pQuery, fCallBack)\n\t\t{\n\t\t\treturn _CountBehavior(this, pQuery, fCallBack);\n\t\t};\n\n\t\t/**\n\t\t * Get the role name for an index\n\t\t */\n\t\tlet _RoleNames;\n\t\tif (Array.isArray(_Fable.settings.MeadowRoleNames))\n\t\t{\n\t\t\t_RoleNames = _Fable.settings.MeadowRoleNames;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_RoleNames =\n\t\t\t[\n\t\t\t\t'Unauthenticated',\n\t\t\t\t'User',\n\t\t\t\t'Manager',\n\t\t\t\t'Director',\n\t\t\t\t'Executive',\n\t\t\t\t'Administrator',\n\t\t\t];\n\t\t}\n\t\tvar getRoleName = function(pRoleIndex)\n\t\t{\n\t\t\tif (pRoleIndex < 0 || pRoleIndex >= _RoleNames.length)\n\t\t\t{\n\t\t\t\treturn 'Unauthenticated';\n\t\t\t}\n\n\t\t\treturn _RoleNames[pRoleIndex];\n\t\t};\n\n\t\t/**\n\t\t * Take the stored representation of our object and stuff the proper values\n\t\t * into our record, translating where necessary.\n\t\t */\n\t\tvar marshalRecordFromSourceToObject = function(pRecord)\n\t\t{\n\t\t\t// Create an object from the default schema object\n\t\t\tvar tmpNewObject = _Fable.Utility.extend({}, _Schema.defaultObject);\n\t\t\t// Now marshal the values from pRecord into tmpNewObject, based on schema\n\t\t\t_Provider.marshalRecordFromSourceToObject(tmpNewObject, pRecord, _Schema.schema);\n\t\t\t// This turns on magical validation\n\t\t\t//_Fable.log.trace('Validation', {Value:tmpNewObject, Validation:_Schema.validateObject(tmpNewObject)})\n\t\t\treturn tmpNewObject;\n\t\t};\n\n\t\t/**\n\t\t * Method to log slow queries in a consistent pattern\n\t\t */\n\t\tvar logSlowQuery = function(pProfileTime, pQuery)\n\t\t{\n\t\t\tvar tmpQuery = pQuery.query || {body: '', parameters: {}};\n\t\t\tvar tmpFullQuery = tmpQuery.body;\n\t\t\tif (tmpQuery.parameters.length)\n\t\t\t{\n\t\t\t\tfor (var tmpKey in tmpQuery.parameters)\n\t\t\t\t{\n\t\t\t\t\ttmpFullQuery = tmpFullQuery.replace(':' + tmpKey, tmpQuery.parameters[tmpKey]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_Fable.log.warn('Slow Read query took ' + pProfileTime + 'ms',\n\t\t\t\t{\n\t\t\t\t\tProvider: _ProviderName,\n\t\t\t\t\tQuery:\n\t\t\t\t\t{\n\t\t\t\t\t\tBody: tmpQuery.body,\n\t\t\t\t\t\tParameters: tmpQuery.parameters,\n\t\t\t\t\t\tFullQuery: tmpFullQuery\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t* Container Object for our Factory Pattern\n\t\t*/\n\t\tvar tmpNewMeadowObject = (\n\t\t{\n\t\t\tdoCreate: doCreate,\n\t\t\tdoRead: doRead,\n\t\t\tdoReads: doReads,\n\t\t\tdoUpdate: doUpdate,\n\t\t\tdoDelete: doDelete,\n\t\t\tdoUndelete: doUndelete,\n\t\t\tdoCount: doCount,\n\n\t\t\tvalidateObject: _Schema.validateObject,\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tsetProvider: setProvider,\n\t\t\tsetIDUser: setIDUser,\n\n\t\t\tloadFromPackage: loadFromPackage,\n\t\t\tloadFromPackageObject: loadFromPackageObject,\n\t\t\tsetScope: setScope,\n\t\t\tsetDomain: setDomain,\n\t\t\tsetSchema: setSchema,\n\t\t\tsetJsonSchema: setJsonSchema,\n\t\t\tsetDefault: setDefault,\n\t\t\tsetDefaultIdentifier: setDefaultIdentifier,\n\t\t\tsetAuthorizer: setAuthorizer,\n\n\t\t\tgetRoleName: getRoleName,\n\n\t\t\tlogSlowQuery: logSlowQuery,\n\n\t\t\t// Factory\n\t\t\tnew: createNew\n\t\t});\n\n\t\t/**\n\t\t * Entity Scope -- usually the name of the entity it represents\n\t\t *\n\t\t * @property scope\n\t\t * @type string\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'scope',\n\t\t\t{\n\t\t\t\tget: function() { return _Scope; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Entity Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'schema',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema.schema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Entity Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'schemaFull',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Default Identifier\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'defaultIdentifier',\n\t\t\t{\n\t\t\t\tget: function() { return _DefaultIdentifier; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Default GUIdentifier\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'defaultGUIdentifier',\n\t\t\t{\n\t\t\t\tget: function() { return _DefaultGUIdentifier; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Json Schema\n\t\t *\n\t\t * @property schema\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'jsonSchema',\n\t\t\t{\n\t\t\t\tget: function() { return _Schema.jsonSchema; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * User Identifier\n\t\t *\n\t\t * Used to stamp user identity into Create/Update operations.\n\t\t *\n\t\t * @property userIdentifier\n\t\t * @type string\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'userIdentifier',\n\t\t\t{\n\t\t\t\tget: function() { return _IDUser; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Query (FoxHound) object\n\t\t *\n\t\t * This always returns a cloned query, so it's safe to get queries with a simple:\n\t\t *   var tmpQuery = libSomeFableObject.query;\n\t\t *\n\t\t * and not expect leakage of basic (cap, begin, filter, dataelements) cloned values.\n\t\t *\n\t\t * @property query\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'query',\n\t\t\t{\n\t\t\t\tget: function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmpQuery = _Query.clone();\n\t\t\t\t\t\t\t// Set the default schema\n\t\t\t\t\t\t\ttmpQuery.query.schema = _Schema.schema;\n\t\t\t\t\t\t\treturn tmpQuery;\n\t\t\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Raw Queries\n\t\t *\n\t\t * @property rawQueries\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'rawQueries',\n\t\t\t{\n\t\t\t\tget: function() { return _RawQueries; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Provider\n\t\t *\n\t\t * @property provider\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'provider',\n\t\t\t{\n\t\t\t\tget: function() { return _Provider; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t/**\n\t\t * Provider Name\n\t\t *\n\t\t * @property providerName\n\t\t * @type object\n\t\t */\n\t\tObject.defineProperty(tmpNewMeadowObject, 'providerName',\n\t\t\t{\n\t\t\t\tget: function() { return _ProviderName; },\n\t\t\t\tenumerable: true\n\t\t\t});\n\n\t\t// addServices removed in fable 2.x\n\t\tif (typeof(_Fable.addServices) === 'function')\n\t\t{\n\t\t\t_Fable.addServices(tmpNewMeadowObject);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// bring over addServices implementation from Fable 1.x for backward compatibility\n\t\t\tObject.defineProperty(tmpNewMeadowObject, 'fable',\n\t\t\t{\n\t\t\t\tget: function() { return _Fable; },\n\t\t\t\tenumerable: false,\n\t\t\t});\n\n\t\t\tObject.defineProperty(tmpNewMeadowObject, 'settings',\n\t\t\t{\n\t\t\t\tget: function() { return _Fable.settings; },\n\t\t\t\tenumerable: false,\n\t\t\t});\n\n\t\t\tObject.defineProperty(tmpNewMeadowObject, 'log',\n\t\t\t{\n\t\t\t\tget: function() { return _Fable.log; },\n\t\t\t\tenumerable: false,\n\t\t\t});\n\t\t}\n\n\t\treturn tmpNewMeadowObject;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new Meadow();\n","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Count multiple records\n*\n* @function meadowBehaviorCount\n*/\nvar meadowBehaviorCount = function(pMeadow, pQuery, fCallBack)\n{\n\tvar tmpProfileStart = new Date(); //for profiling query time\n\n\t// Count the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Get the record countfrom the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Count'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Count');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Count(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Validate the resulting value\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// Check if query time exceeded threshold in settings. Log if slow.\n\t\t\t\tvar tmpProfileTime = new Date().getTime() - tmpProfileStart.getTime();\n\t\t\t\tif (tmpProfileTime > (pMeadow.fable.settings['QueryThresholdWarnTime'] || 200))\n\t\t\t\t{\n\t\t\t\t\tpMeadow.logSlowQuery(tmpProfileTime, pQuery);\n\t\t\t\t}\n\n\t\t\t\tif (typeof(pQuery.parameters.result.value) !== 'number')\n\t\t\t\t{\n\t\t\t\t\t// The return value is a number.. something is wrong.\n\t\t\t\t\treturn fStageComplete('Count did not return valid results.', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, pQuery.result.value);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pCount)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the count waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pCount);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorCount;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Create\n*\n* @function meadowBehaviorCreate\n*/\nvar meadowBehaviorCreate = function(pMeadow, pQuery, fCallBack)\n{\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 0: If GUID is specified, make sure the record does not already exist\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\t// Make sure the user submitted a record\n\t\t\t\tif (!pQuery.query.records)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('No record submitted', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tif (pQuery.query.records[0][pMeadow.defaultGUIdentifier] &&\n\t\t\t\t\tpQuery.query.records[0][pMeadow.defaultGUIdentifier].length >= 5) //see Foxhound mysql build create query: GUID min len must be 5\n\t\t\t\t{\n\t\t\t\t\tvar tmpGUIDRecord = pQuery.query.records[0][pMeadow.defaultGUIdentifier];\n\n\t\t\t\t\tvar tmpQueryRead = pQuery.clone().addFilter(pMeadow.defaultGUIdentifier, tmpGUIDRecord)\n\t\t\t\t\t\t\t\t\t\t\t\t .setDisableDeleteTracking(true); //this check is to guarantee uniqueness across the entire table, so always do this\n\n\t\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpQueryRead.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t\t}\n\t\t\t\t\tpMeadow.provider.Read(tmpQueryRead, function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmpError = tmpQueryRead.error;\n\n\t\t\t\t\t\t\tif (!tmpError &&\n\t\t\t\t\t\t\t\ttmpQueryRead.result.value.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpError = 'Record with GUID ' + tmpGUIDRecord + ' already exists!';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (tmpError)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn fStageComplete(tmpError, tmpQueryRead, tmpQueryRead, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete();\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Step 1: Create the record in the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (!pQuery.query.IDUser)\n\t\t\t\t{\n\t\t\t\t\t// The user ID is not already set, set it magically.\n\t\t\t\t\tif (typeof(pQuery.userID) === 'number' && (pQuery.userID % 1) === 0 && pQuery.userID >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pQuery.userID;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pMeadow.userIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Merge in the default record with the passed-in record for completeness\n\t\t\t\tpQuery.query.records[0] = pMeadow.fable.Utility.extend({}, pMeadow.schemaFull.defaultObject, pQuery.query.records[0]);\n\t\t\t\t// Create override is too complex ... punting for now\n\t\t\t\t// if (pMeadow.rawQueries.checkQuery('Create'))\n\t\t\t\t//\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Create');\n\t\t\t\tpMeadow.provider.Create(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Setup a read operation\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// The value is not set (it should be set to the value for our DefaultIdentifier)\n\t\t\t\tif (pQuery.parameters.result.value === false)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('Creation failed', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tvar tmpIDRecord = pQuery.result.value;\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, tmpIDRecord);\n\t\t\t},\n\t\t\t// Step 3: Read the record\n\t\t\tfunction (pQuery, pIDRecord, fStageComplete)\n\t\t\t{\n\t\t\t\tvar tmpQueryRead = pQuery.clone().addFilter(pMeadow.defaultIdentifier, pIDRecord)\n\t\t\t\t\t\t\t\t\t\t\t\t .setDisableDeleteTracking(pQuery.parameters.query.disableDeleteTracking); //if delete tracking is disabled, we need to disable it on this Read operation\n\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t{\n\t\t\t\t\ttmpQueryRead.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(tmpQueryRead, function(){ fStageComplete(tmpQueryRead.result.error, pQuery, tmpQueryRead); });\n\t\t\t},\n\t\t\t// Step 4: Marshal the record into a POJO\n\t\t\tfunction (pQuery, pQueryRead, fStageComplete)\n\t\t\t{\n\t\t\t\t// Ensure there is not at least one record returned\n\t\t\t\tif (pQueryRead.parameters.result.value.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('No record found after create.', pQuery, pQueryRead, false);\n\t\t\t\t}\n\n\t\t\t\tvar tmpRecord = pMeadow.marshalRecordFromSourceToObject(pQueryRead.result.value[0]);\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, pQueryRead, tmpRecord);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pQueryRead, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the create waterfall', {Error:pError, Message: pError.message, Query: pQuery.query, Stack: pError.stack});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pQueryRead, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorCreate;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Delete a single record\n*\n* @function meadowBehaviorDelete\n*/\nvar meadowBehaviorDelete = function(pMeadow, pQuery, fCallBack)\n{\n\t// TODO: Check if this recordset has implicit delete tracking, branch in this module.\n\t// Delete the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Delete the record\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Delete'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Delete');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Delete(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery, pQuery.result.value); });\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the delete waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorDelete;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Read a single record\n*\n* @function meadowBehaviorRead\n*/\nvar meadowBehaviorRead = function(pMeadow, pQuery, fCallBack)\n{\n\t// Read the record from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Get the record from the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\t// If there is a Read override query, use it!\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Marshal the record into a POJO\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// Check that a record was returned\n\t\t\t\tif (pQuery.parameters.result.value.length < 1)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(undefined, pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tvar tmpRecord = pMeadow.marshalRecordFromSourceToObject(pQuery.result.value[0]);\n\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, tmpRecord);\n\t\t\t}\n\t\t],\n\t\t(pError, pQuery, pRecord)=>\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the read waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorRead;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\nvar libAsyncEach = require('async/eachSeries');\n\n/**\n* Meadow Behavior - Read multiple records\n*\n* @function meadowBehaviorReads\n*/\nvar meadowBehaviorReads = function(pMeadow, pQuery, fCallBack)\n{\n\tvar tmpProfileStart = new Date(); //for profiling query time\n\n\t// Read the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Get the record(s) from the data source\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Reads'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Reads');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Marshal all the records into an array of POJOs\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// Check if query time exceeded threshold in settings. Log if slow.\n\t\t\t\tvar tmpProfileTime = new Date().getTime() - tmpProfileStart.getTime();\n\t\t\t\tif (tmpProfileTime > (pMeadow.fable.settings['QueryThresholdWarnTime'] || 200))\n\t\t\t\t{\n\t\t\t\t\tpMeadow.logSlowQuery(tmpProfileTime, pQuery);\n\t\t\t\t}\n\n\t\t\t\tvar tmpRecords = [];\n\n\t\t\t\tlibAsyncEach\n\t\t\t\t(\n\t\t\t\t\tpQuery.parameters.result.value,\n\t\t\t\t\tfunction(pRow, pQueueCallback)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRecords.push(pMeadow.marshalRecordFromSourceToObject(pRow));\n\t\t\t\t\t\tpQueueCallback();\n\t\t\t\t\t},\n\t\t\t\t\tfunction()\n\t\t\t\t\t{\n\t\t\t\t\t\t// After we've pushed every record into the array in order, complete the waterfall\n\t\t\t\t\t\tfStageComplete(pQuery.result.error, pQuery, tmpRecords);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pRecords)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the read multiple waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecords);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorReads;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Undelete a single record\n*\n* @function meadowBehaviorUndelete\n*/\nvar meadowBehaviorUndelete = function(pMeadow, pQuery, fCallBack)\n{\n\t// TODO: Check if this recordset has implicit delete tracking, branch in this module?\n\t// Undelete the record(s) if they were deleted with a bit\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Undelete the record\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Undelete'))\n\t\t\t\t{\n\t\t\t\t\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Undelete');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Undelete(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery, pQuery.result.value); });\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during the undelete waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorUndelete;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libAsyncWaterfall = require('async/waterfall');\n\n/**\n* Meadow Behavior - Update a single record\n*\n* @function meadowBehaviorUpdate\n*/\nvar meadowBehaviorUpdate = function(pMeadow, pQuery, fCallBack)\n{\n\t// Update the record(s) from the source\n\tlibAsyncWaterfall(\n\t\t[\n\t\t\t// Step 1: Update the record\n\t\t\tfunction (fStageComplete)\n\t\t\t{\n\t\t\t\tif (!pQuery.query.IDUser)\n\t\t\t\t{\n\t\t\t\t\t// The user ID is not already set, set it magically.\n\t\t\t\t\tif (typeof(pQuery.userID) === 'number' && (pQuery.userID % 1) === 0 && pQuery.userID >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pQuery.userID;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpQuery.query.IDUser = pMeadow.userIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Make sure the developer submitted a record\n\t\t\t\tif (!pQuery.query.records)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('No record submitted', pQuery, false);\n\t\t\t\t}\n\t\t\t\t// Make sure there is a default identifier\n\t\t\t\tif (!pQuery.query.records[0].hasOwnProperty(pMeadow.defaultIdentifier))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('Automated update missing default identifier', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\t// Now see if there is anything in the schema that is an Update action that isn't in this query\n\t\t\t\tfor (var i = 0; i < pMeadow.schema.length; i++)\n\t\t\t\t{\n\t\t\t\t\tswitch (pMeadow.schema[i].Type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t\t\tpQuery.query.records[0][pMeadow.schema[i].Column] = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Set the update filter\n\t\t\t\tpQuery.addFilter(pMeadow.defaultIdentifier, pQuery.query.records[0][pMeadow.defaultIdentifier]);\n\n\t\t\t\t// Sanity check on update to make sure we don't update EVERY record.\n\t\t\t\tif ((pQuery.parameters.filter === false) || (pQuery.parameters.filter.length < 1))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete('Automated update missing filters... aborting!', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\t// Updates are too complex to override for now, punting on this feature.\n\t\t\t\t//if (pMeadow.rawQueries.checkQuery('Update'))\n\t\t\t\t//\tpQuery.parameters.queryOverride = pMeadow.rawQueries.getQuery('Update');\n\t\t\t\tpMeadow.provider.Update(pQuery, function(){ fStageComplete(pQuery.result.error, pQuery); });\n\t\t\t},\n\t\t\t// Step 2: Check that the record was updated\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\tif (typeof(pQuery.parameters.result.value) !== 'object')\n\t\t\t\t{\n\t\t\t\t\t// The value is not an object\n\t\t\t\t\treturn fStageComplete('No record updated.', pQuery, false);\n\t\t\t\t}\n\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery);\n\t\t\t},\n\t\t\t// Step 3: Read the record\n\t\t\tfunction (pQuery, fStageComplete)\n\t\t\t{\n\t\t\t\t// We can clone the query, since it has the criteria for the update in it already (filters survive a clone)\n\t\t\t\tvar tmpQueryRead = pQuery.clone();\n\t\t\t\t// Make sure to load the record with the custom query if necessary.\n\t\t\t\tif (pMeadow.rawQueries.checkQuery('Read'))\n\t\t\t\t{\n\t\t\t\t\ttmpQueryRead.parameters.queryOverride = pMeadow.rawQueries.getQuery('Read');\n\t\t\t\t}\n\t\t\t\tpMeadow.provider.Read(tmpQueryRead, function(){ fStageComplete(tmpQueryRead.result.error, pQuery, tmpQueryRead); });\n\t\t\t},\n\t\t\t// Step 4: Marshal the record into a POJO\n\t\t\tfunction (pQuery, pQueryRead, fStageComplete)\n\t\t\t{\n\t\t\t\tif (pQueryRead.result.value.length === 0)\n\t\t\t\t{\n\t\t\t\t\t//No record found to update\n\t\t\t\t\treturn fStageComplete('No record found to update!', pQueryRead.result, false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar tmpRecord = pMeadow.marshalRecordFromSourceToObject(pQueryRead.result.value[0]);\n\t\t\t\tfStageComplete(pQuery.result.error, pQuery, pQueryRead, tmpRecord);\n\t\t\t}\n\t\t],\n\t\tfunction(pError, pQuery, pQueryRead, pRecord)\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpMeadow.fable.log.warn('Error during Update waterfall', {Error:pError, Message: pError.message, Query: pQuery.query});\n\t\t\t}\n\t\t\tfCallBack(pError, pQuery, pQueryRead, pRecord);\n\t\t}\n\t);\n\n\treturn pMeadow;\n};\n\nmodule.exports = meadowBehaviorUpdate;","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif (typeof(pFable) !== 'object')\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\tvar _GlobalLogLevel = 0;\n\t\tif (_Fable.settings.ArrayStorage)\n\t\t{\n\t\t\t _GlobalLogLevel = _Fable.settings.ArrayStorage.GlobalLogLevel || 0;\n\t\t}\n\t\t\n\t\tif (!_Fable.hasOwnProperty('ALASQL'))\n\t\t{\n\t\t\t// This is going to be problematic.\n\t\t\t_Fable.log.fatal('Meadow is trying to perform queries without a valid [Fable.ALASQL] object.  See the documentation for how to initialize one.');\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar libALASQL = _Fable.ALASQL;\n\n\t\tvar _Scope = 'Unknown_Meadow_ALASQL_Scope';\n\t\tvar _Schema = {};\n\t\tvar _DefaultIdentifier = 'ID';\n\t\tvar _DefaultGUIDentifier = 'GUID';\n\t\tvar setSchema = (pScope, pSchema, pDefaultIdentifier, pDefaultGUIdentifier) => \n\t\t{\n\t\t\t_Scope = pScope;\n\t\t\t_Schema = pSchema;\n\t\t\t_DefaultIdentifier = pDefaultIdentifier;\n\t\t\t_DefaultGUIDentifier = pDefaultGUIdentifier;\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t// Create a table for this schema on the fly\n\t\t// This is ripped off from https://github.com/stevenvelozo/stricture/blob/master/source/Stricture-Generate-MySQL.js\n\t\tvar createTableDynamically = () =>\n\t\t{\n\t\t\tvar tmpCreateStatement = '';\n\t\t\tvar tmpTable = _Scope;\n\t\t\tvar tmpSchema = _Schema;\n\t\t\t\n\t\t\t// Check if the scope in the query matches the passed-in scope\n\t\t\t// Check if the schema does not contain all columns in the query, and add them if it doesn't.\n\t\t\n\t\t\ttmpCreateStatement += \"CREATE TABLE IF NOT EXISTS\\n    \"+tmpTable+\"\\n\";\n\t\t\tif (tmpSchema.length > 0)\n\t\t\t{\n\t\t\t\ttmpCreateStatement += \"    (\\n\";\n\t\t\t\tfor (var j = 0; j < tmpSchema.length; j++)\n\t\t\t\t{\n\t\t\t\t\t// If we aren't the first element, append a comma.\n\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\ttmpCreateStatement += \",\";\n\t\t\n\t\t\t\t\ttmpCreateStatement += \"\\n\";\n\t\t\t\t\t// Dump out each column......\n\t\t\t\t\tswitch (tmpSchema[j].Type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'AutoIdentity':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` INT UNSIGNED NOT NULL AUTO_INCREMENT\";\n\t\t\t\t\t\t\t_DefaultIdentifier = tmpSchema[j].Column;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'AutoGUID':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` CHAR(36) NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000'\";\n\t\t\t\t\t\t\t_DefaultGUIDentifier = tmpSchema[j].Column;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Boolean':\n\t\t\t\t\t\tcase 'Deleted':\n\t\t\t\t\t\tcase 'CreateIDUser':\n\t\t\t\t\t\tcase 'UpdateIDUser':\n\t\t\t\t\t\tcase 'DeleteIDUser':\n\t\t\t\t\t\tcase 'Numeric':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` INT NOT NULL DEFAULT 0\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Decimal':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` DECIMAL(\"+tmpSchema[j].Size+\")\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'String':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` VARCHAR NOT NULL DEFAULT ''\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Text':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` TEXT\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'CreateDate':\n\t\t\t\t\t\tcase 'UpdateDate':\n\t\t\t\t\t\tcase 'DeleteDate':\n\t\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\t\ttmpCreateStatement += \"        `\"+tmpSchema[j].Column+\"` DATETIME\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmpCreateStatement += \"\\n    )\";\n\t\t\t}\n\t\t\ttmpCreateStatement += \";\";\n\t\t\t\n\t\t\t_Fable.log.info('Auto Creating ALASQL database `'+tmpTable+'`', {CreateStatement:tmpCreateStatement});\n\n\t\t\tlibALASQL(tmpCreateStatement);\n\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t// Determine if the table has been created in ALASQL.  If not, create it.\n\t\tvar checkDataExists = (pParameters) =>\n\t\t{\n\t\t\t// Check if the scope was passed in via the query and it hasn't been set yet.\n\t\t\tif ((_Scope == 'Unknown_Meadow_ALASQL_Scope') && (typeof(pParameters.scope) !== 'undefined'))\n\t\t\t{\n\t\t\t\t_Scope = pParameters.scope;\n\t\t\t}\n\t\t\t// Per https://github.com/agershun/alasql/wiki/How-to-insert-data-into-the-table\n\t\t\tif (!_Fable.ALASQL.tables.hasOwnProperty(_Scope))\n\t\t\t{\n\t\t\t\t// Create the table with the schema\n\t\t\t\tcreateTableDynamically();\n\t\t\t}\n\t\t};\n\n\t\tvar bindObject = (pObject) =>\n\t\t{\n\t\t\tif (!Array.isArray(pObject))\n\t\t\t\treturn false;\n\n\t\t\t// Check that the database is created in ALASQL first\n\t\t\tcheckDataExists({});\n\t\t\t\n\t\t\tif (!_Fable.ALASQL.tables.hasOwnProperty(_Scope))\n\t\t\t\treturn false;\n\n\t\t\t// Per https://github.com/agershun/alasql/wiki/How-to-insert-data-into-the-table\n\t\t\t_Fable.ALASQL.tables[_Scope].data = pObject;\n\t\t\treturn true;\n\t\t};\n\n\t\t// The Meadow marshaller also passes in the Schema as the third parameter, but this is a blunt function ATM.\n\t\tvar marshalRecordFromSourceToObject = function(pObject, pRecord)\n\t\t{\n\t\t\t// For now, crudely assign everything in pRecord to pObject\n\t\t\t// This is safe in this context, and we don't want to slow down marshalling with millions of hasOwnProperty checks\n\t\t\tfor(var tmpColumn in pRecord)\n\t\t\t{\n\t\t\t\tpObject[tmpColumn] = pRecord[tmpColumn];\n\t\t\t}\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildCreateQuery();\n\n\t\t\t// Compile the ALASQL query\n\t\t\t// Per https://github.com/agershun/alasql/wiki/Compile\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\t// TODO: Test the query before executing\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\t// No iops so this is not async\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\t\t\t\ttmpResult.value = 0;\n\n\t\t\t\tvar tmpQueryResponse = fQuery(pQuery.query.parameters);\n\n\t\t\t\tif (tmpQueryResponse > 0)\n\t\t\t\t{\n\t\t\t\t\t// Check if there is an ALASQL autoval for this insert\n\t\t\t\t\tif (libALASQL.tables[pQuery.parameters.scope].identities[_DefaultIdentifier])\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResult.value = libALASQL.autoval(pQuery.parameters.scope, _DefaultIdentifier);\n\t\t\t\t\t}\n\t\t\t\t\telse if ((pQuery.query.records.length > 0) && (pQuery.query.records[0].hasOwnProperty(_DefaultIdentifier)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpResult.value = pQuery.query.records[0][_DefaultIdentifier];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildReadQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value = fQuery(pQuery.query.parameters);\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildUpdateQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value = {affectedRows: fQuery(pQuery.query.parameters)};\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildDeleteQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value =  fQuery(pQuery.query.parameters);\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Undelete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildUndeleteQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value =  fQuery(pQuery.query.parameters);\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tcheckDataExists(pQuery.parameters);\n\n\t\t\tpQuery.setDialect('ALASQL').buildCountQuery();\n\t\t\tvar fQuery = libALASQL.compile(pQuery.query.body);\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttmpResult.error = undefined;\n\t\t\t\ttmpResult.executed = false;\n\n\t\t\t\ttmpResult.value =  fQuery(pQuery.query.parameters)[0].RowCount;\n\n\t\t\t\ttmpResult.executed = true;\n\t\t\t}\n\t\t\tcatch (pError)\n\t\t\t{\n\t\t\t\ttmpResult.error = pError;\n\t\t\t}\n\n\t\t\tfCallback();\n\t\t};\n\t\t\n\t\t/**\n\t\t * Construct a new Meadow from a record prototype, optionally passing in records.\n\t\t * \n\t\t * Takes an object\n\t\t * {\n\t\t *\t\tMeadow:          Meadow object to use (required)\n\t\t *      Scope:           \"DATA\" (string)\n\t\t *      ObjectPrototype: {}     (the object to base the schema off of -- REQUIRED)\n\t\t *      AuditData:       true   (boolean -- whether or not to add audit columns)\n\t\t *      Import:          true   (boolean -- whether or not to import them using the DAL)\n\t\t *      Data:            []     (optional array of records, one object each)\n\t\t * }\n\t\t */\n\t\tvar constructFromObject = (pParameters) =>\n\t\t{\n\t\t\tif ((typeof(pParameters) !== 'object') || (typeof(pParameters.Meadow) !== 'object'))\n\t\t\t\treturn false;\n\n\t\t\t// I know there are better ways to do this, but for now I want to keep it very manual\n\t\t\tif (!(typeof(pParameters.Scope) === 'string'))\n\t\t\t\tpParameters.Scope = 'DATA';\n\t\t\tif (!(typeof(pParameters.ObjectPrototype) === 'object'))\n\t\t\t\tpParameters.ObjectPrototype = {};\n\t\t\tif (!(typeof(pParameters.AuditData) === 'boolean'))\n\t\t\t\tpParameters.AuditData = true;\n\t\t\tif (!(typeof(pParameters.Import) === 'boolean'))\n\t\t\t\tpParameters.Import = true;\n\t\t\tif (!Array.isArray(pParameters.Data))\n\t\t\t\tpParameters.Data = [];\n\t\t\t\t\n\t\t\t// Construct a meadow\n\t\t\tvar tmpMeadow = pParameters.Meadow\n\t\t\t\t.new(_Fable, pParameters.Scope)\n\t\t\t\t.setProvider('ALASQL');\n\t\t\t\n\t\t\tvar tmpSchema = [];\n\t\t\tvar tmpDefaultIdentifier;\n\n\t\t\tif (pParameters.AuditData)\n\t\t\t{\n\t\t\t\t// Add the audit fields to the schema\n\t\t\t\ttmpDefaultIdentifier = 'ID'+pParameters.Scope;\n\t\t\t\ttmpSchema.push({ Column: tmpDefaultIdentifier, Type:\"AutoIdentity\" });\n\t\t\t\ttmpSchema.push({ Column: \"GU\"+tmpDefaultIdentifier, Type:\"AutoGUID\" });\n\t\t\t\ttmpSchema.push({ Column: \"CreateDate\", Type:\"CreateDate\" });\n\t\t\t\ttmpSchema.push({ Column: \"CreatingIDUser\", Type:\"CreateIDUser\" });\n\t\t\t\ttmpSchema.push({ Column: \"UpdateDate\", Type:\"UpdateDate\" });\n\t\t\t\ttmpSchema.push({ Column: \"UpdatingIDUser\", Type:\"UpdateIDUser\" });\n\t\t\t\ttmpSchema.push({ Column: \"DeleteDate\", Type:\"DeleteDate\" });\n\t\t\t\ttmpSchema.push({ Column: \"DeletingIDUser\", Type:\"DeleteIDUser\" });\n\t\t\t\ttmpSchema.push({ Column: \"Deleted\", Type:\"Deleted\" });\n\t\t\t}\n\n\t\t\t// Now add the fields from the object in\n\t\t\tfor (var tmpProperty in pParameters.ObjectPrototype)\n\t\t\t{\n\t\t\t\tvar tmpAdded = false;\n\n\t\t\t\t// Add it to the schema\n\t\t\t\tswitch(typeof(pParameters.ObjectPrototype[tmpProperty]))\n\t\t\t\t{\n\t\t\t\t\tcase \"undefined\":\n\t\t\t\t\tcase \"object\":\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\t// Do nothing with these types of properties\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\ttmpSchema.push({ Column: tmpProperty, Type:\"Boolean\" });\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Because we can't tell the difference between floating point and not\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttmpSchema.push({ Column: tmpProperty, Type:\"Text\" });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (tmpAdded && (typeof(tmpDefaultIdentifier) === 'undefined'))\n\t\t\t\t\t// Just use the first property of the prototype object as the default identifier\n\t\t\t\t\ttmpDefaultIdentifier = tmpProperty;\n\t\t\t}\n\t\t\ttmpMeadow.setSchema(tmpSchema);\n\n\t\t\tif (typeof(tmpDefaultIdentifier) === 'undefined')\n\t\t\t\ttmpMeadow.setDefaultIdentifier(tmpDefaultIdentifier);\n\n\t\t\t// Now import the data\n\t\t\tif(pParameters.Import)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < pParameters.Data.length; j++)\n\t\t\t\t{\n\t\t\t\t\ttmpMeadow.doCreate(tmpMeadow.query.clone().addRecord(pParameters.Data[j]),\n\t\t\t\t\t\t\tfunction(pError, pQuery, pQueryRead, pRecord)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Maybe log the error?\n\t\t\t\t\t\t\t\t_Fable.log.trace('Auto imported record', pRecord);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just assign the object\n\t\t\t\ttmpMeadow.provider.bindObject(pParameters.Data);\n\t\t\t}\n\t\t\t\n\t\t\treturn tmpMeadow;\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tsetSchema: setSchema,\n\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\t\t\t\n\t\t\tconstructFromObject: constructFromObject,\n\n\t\t\tbindObject:bindObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tUndelete: Undelete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libSimpleGet = require('simple-get');\n\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif (typeof(pFable) !== 'object')\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\tvar _GlobalLogLevel = 0;\n\n\t\tvar _Dialect = 'MeadowEndpoints';\n\n\t\tvar _Headers = {};\n\t\tvar _Cookies = [];\n\n\t\tvar _EndpointSettings = (_Fable.settings.hasOwnProperty('MeadowEndpoints')) ? JSON.parse(JSON.stringify(_Fable.settings.MedaowEndpoints)) : (\n\t\t\t{\n\t\t\t\tServerProtocol: 'http',\n\t\t\t\tServerAddress: '127.0.0.1',\n\t\t\t\tServerPort: '8086',\n\t\t\t\tServerEndpointPrefix: '1.0/'\n\t\t\t}\n\t\t)\n\n\t\tvar buildURL = function(pAddress)\n\t\t{\n\t\t\treturn `${_EndpointSettings.ServerProtocol}://${_EndpointSettings.ServerAddress}:${_EndpointSettings.ServerPort}/${_EndpointSettings.ServerEndpointPrefix}${pAddress}`;\n\t\t};\n\n\t\tvar buildRequestOptions = function(pQuery)\n\t\t{\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.records);\n\t\t\t}\n\n\t\t\tlet tmpURL = buildURL(pQuery.query.body);\n\n\t\t\tlet tmpRequestOptions = (\n\t\t\t{\n\t\t\t\turl: tmpURL,\n\t\t\t\theaders: _Fable.Utility.extend({cookie: ''}, _Headers)\n\t\t\t});\n\n\t\t\ttmpRequestOptions.headers.cookie = _Cookies.join(';');\n\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t_Fable.log.debug(`Request options built...`,tmpRequestOptions);\n\n\t\t\t\treturn tmpRequestOptions;\n\t\t};\n\n\t\t// The Meadow marshaller also passes in the Schema as the third parameter, but this is a blunt function ATM.\n\t\tvar marshalRecordFromSourceToObject = function(pObject, pRecord)\n\t\t{\n\t\t\tfor(var tmpColumn in pRecord)\n\t\t\t{\n\t\t\t\tpObject[tmpColumn] = pRecord[tmpColumn];\n\t\t\t}\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildCreateQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\n\t\t\t// TODO: Should this test for exactly one?\n\t\t\tif (!pQuery.query.records.length > 0)\n\t\t\t{\n\t\t\t\ttmpResult.error = 'No records passed for proxying to Meadow-Endpoints.';\n\n\t\t\t\treturn fCallback();\n\t\t\t}\n\n\t\t\ttmpRequestOptions.body = pQuery.query.records[0];\n\t\t\ttmpRequestOptions.json = true;\n\t\n\t\t\tlibSimpleGet.post(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> POST request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> POST data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\t// TODO Because this was proxied, read happens at this layer too.  Inefficient -- fixable\n\t\t\t\t\t\t\tlet tmpIdentityColumn = `ID${pQuery.parameters.scope}`;\n\t\t\t\t\t\t\tif (tmpResult.value.hasOwnProperty(tmpIdentityColumn))\n\t\t\t\t\t\t\ttmpResult.value = tmpResult.value[tmpIdentityColumn];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> POST completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildReadQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\t\n\t\t\tlibSimpleGet.get(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> GET request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> GET data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\tif (pQuery.query.body.startsWith(`${pQuery.parameters.scope}/`))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// If this is not a plural read, make the result into an array.\n\t\t\t\t\t\t\t\ttmpResult.value = [tmpResult.value];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> GET completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildUpdateQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\n\t\t\t// TODO: Should this test for exactly one?\n\t\t\tif (!pQuery.query.records.length > 0)\n\t\t\t{\n\t\t\t\ttmpResult.error = 'No records passed for proxying to Meadow-Endpoints.';\n\n\t\t\t\treturn fCallback();\n\t\t\t}\n\n\t\t\ttmpRequestOptions.body = pQuery.query.records[0];\n\t\t\ttmpRequestOptions.json = true;\n\t\n\t\t\tlibSimpleGet.put(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> PUT request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> PUT data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\t// TODO Because this was proxied, read happens at this layer too.  Inefficient -- fixable\n\t\t\t\t\t\t\tlet tmpIdentityColumn = `ID${pQuery.parameters.scope}`;\n\t\t\t\t\t\t\tif (tmpResult.value.hasOwnProperty(tmpIdentityColumn))\n\t\t\t\t\t\t\ttmpResult.value = tmpResult.value[tmpIdentityColumn];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> PUT completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t}\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildDeleteQuery();\n\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\t\n\t\t\tlibSimpleGet.delete(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> DEL request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> DEL data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (tmpResult.value.hasOwnProperty('Count'))\n\t\t\t\t\t\t\t\ttmpResult.value = tmpResult.value.Count;\n\t\n\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> DEL completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\t\t\tpQuery.setDialect(_Dialect).buildCountQuery();\n\n\t\t\tlet tmpRequestOptions = buildRequestOptions(pQuery);\n\t\n\t\t\tlibSimpleGet.get(tmpRequestOptions, (pError, pResponse)=>\n\t\t\t\t{\n\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\ttmpResult.executed = true;\n\n\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t_Fable.log.debug(`--> GET request connected`);\n\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fCallback(tmpResult);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpData = '';\n\t\n\t\t\t\t\tpResponse.on('data', (pChunk)=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t\t\t_Fable.log.debug(`--> GET data chunk size ${pChunk.length}b received`);\n\t\t\t\t\t\t\ttmpData += pChunk;\n\t\t\t\t\t\t});\n\t\n\t\t\t\t\tpResponse.on('end', ()=>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tmpData)\n\t\t\t\t\t\t\t\ttmpResult.value = JSON.parse(tmpData);\n\n\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmpResult.value = tmpResult.value.Count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// This is an error state...\n\t\t\t\t\t\t\t\t\ttmpResult.value = -1;\n\t\t\t\t\t\t\t\t\t_Fable.log.warn('Error getting rowcount during count query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_Fable.log.debug(`==> GET completed data size ${tmpData.length}b received`,tmpResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfCallback();\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif (typeof(pFable) !== 'object')\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\tvar _Fable = pFable;\n\t\tvar _GlobalLogLevel = 0;\n\t\tif (_Fable.settings.MySQL)\n\t\t{\n\t\t\t _GlobalLogLevel = _Fable.settings.MySQL.GlobalLogLevel || 0;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Build a connection pool, shared within this provider.\n\t\t * This may be more performant as a shared object.\n\t\t */\n\t\tvar getSQLPool = function()\n\t\t{\n\t\t\tif (typeof(_Fable.MeadowMySQLConnectionPool) !== 'object')\n\t\t\t{\n\t\t\t\t// This is going to be problematic.\n\t\t\t\t_Fable.log.fatal('Meadow is trying to perform queries without a valid [Fable.MeadowMySQLConnectionPool] object.  See the documentation for how to initialize one.');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn _Fable.MeadowMySQLConnectionPool;\n\t\t};\n\n\t\t// The Meadow marshaller also passes in the Schema as the third parameter, but this is a blunt function ATM.\n\t\tvar marshalRecordFromSourceToObject = function(pObject, pRecord)\n\t\t{\n\t\t\t// For now, crudely assign everything in pRecord to pObject\n\t\t\t// This is safe in this context, and we don't want to slow down marshalling with millions of hasOwnProperty checks\n\t\t\tfor(var tmpColumn in pRecord)\n\t\t\t{\n\t\t\t\tpObject[tmpColumn] = pRecord[tmpColumn];\n\t\t\t}\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildCreateQuery();\n\n\t\t\t// TODO: Test the query before executing\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows.insertId;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting insert ID during create query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildReadQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = pRows;\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildUpdateQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = pRows;\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildDeleteQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query\n\t\t\t\t(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows.affectedRows;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting affected rowcount during delete query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar Undelete = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildUndeleteQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query\n\t\t\t\t(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows.affectedRows;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting affected rowcount during delete query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\tvar tmpResult = pQuery.parameters.result;\n\n\t\t\tpQuery.setDialect('MySQL').buildCountQuery();\n\n\t\t\tif (pQuery.logLevel > 0 ||\n\t\t\t\t_GlobalLogLevel > 0)\n\t\t\t{\n\t\t\t\t_Fable.log.trace(pQuery.query.body, pQuery.query.parameters);\n\t\t\t}\n\n\t\t\tgetSQLPool().getConnection(function(pError, pDBConnection)\n\t\t\t{\n\t\t\t\tpDBConnection.query(\n\t\t\t\t\tpQuery.query.body,\n\t\t\t\t\tpQuery.query.parameters,\n\t\t\t\t\t// The MySQL library also returns the Fields as the third parameter\n\t\t\t\t\tfunction(pError, pRows)\n\t\t\t\t\t{\n\t\t\t\t\t\tpDBConnection.release();\n\t\t\t\t\t\ttmpResult.executed = true;\n\t\t\t\t\t\ttmpResult.error = pError;\n\t\t\t\t\t\ttmpResult.value = false;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmpResult.value = pRows[0].RowCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(pErrorGettingRowcount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_Fable.log.warn('Error getting rowcount during count query',{Body:pQuery.query.body, Parameters:pQuery.query.parameters});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fCallback();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tUndelete: Undelete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n","// ##### Part of the **[retold](https://stevenvelozo.github.io/retold/)** system\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\nvar MeadowProvider = function()\n{\n\tfunction createNew(pFable)\n\t{\n\t\t// If a valid Fable object isn't passed in, return a constructor\n\t\tif ((typeof(pFable) !== 'object') || !('fable' in pFable))\n\t\t{\n\t\t\treturn {new: createNew};\n\t\t}\n\t\t//var _Fable = pFable;\n\n\t\t//var marshalRecordFromSourceToObject = function(pObject, pRecord, pSchema)\n\t\tvar marshalRecordFromSourceToObject = function()\n\t\t{\n\t\t\t// Do nothing ... this is the NONE provider after all\n\t\t};\n\n\t\tvar Create = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\t// This is a synchronous read, good for a few records.\n\t\t// TODO: Add a pipe-able read for huge sets\n\t\tvar Read = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tpQuery.parameters.result.value = [true];\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Update = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Delete = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Undelete = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar Count = function(pQuery, fCallback)\n\t\t{\n\t\t\t// This does nothing because it's the none data provider!\n\t\t\tpQuery.parameters.result.executed = true;\n\t\t\tfCallback();\n\t\t};\n\n\t\tvar tmpNewProvider = (\n\t\t{\n\t\t\tmarshalRecordFromSourceToObject: marshalRecordFromSourceToObject,\n\n\t\t\tCreate: Create,\n\t\t\tRead: Read,\n\t\t\tUpdate: Update,\n\t\t\tDelete: Delete,\n\t\t\tUndelete: Undelete,\n\t\t\tCount: Count,\n\n\t\t\tnew: createNew\n\t\t});\n\n\n\t\treturn tmpNewProvider;\n\t}\n\n\treturn createNew();\n};\n\nmodule.exports = new MeadowProvider();\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = function (stream, cb) {\n  var chunks = []\n  stream.on('data', function (chunk) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n","/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const originalHost = opts.hostname // hostname before potential redirect\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      const redirectHost = url.parse(opts.url).hostname // eslint-disable-line node/no-deprecated-api\n      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)\n      if (redirectHost !== null && redirectHost !== originalHost) {\n        delete opts.headers.cookie\n        delete opts.headers.authorization\n      }\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = { url: opts }\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/lib/_stream_readable.js');\nStream.Writable = require('readable-stream/lib/_stream_writable.js');\nStream.Duplex = require('readable-stream/lib/_stream_duplex.js');\nStream.Transform = require('readable-stream/lib/_stream_transform.js');\nStream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');\nStream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')\nStream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nconst Readable = require('./_stream_readable');\nconst Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  const keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    const method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nconst Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nconst EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nconst debugUtil = require('util');\nlet debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nconst BufferList = require('./internal/streams/buffer_list');\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nlet StringDecoder;\nlet createReadableStreamAsyncIterator;\nlet from;\nrequire('inherits')(Readable, Stream);\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nconst kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  let p = this._readableState.buffer.head;\n  let content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', () => {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) this.push(chunk);\n    }\n    this.push(null);\n  });\n  stream.on('data', chunk => {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = n => {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      const wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nconst _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nconst Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush((er, data) => {\n      done(this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, err2 => {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  this.next = null;\n  this.entry = null;\n  this.finish = () => {\n    onCorkedFinish(this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nconst internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk,\n      encoding,\n      isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(err => {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        const rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nconst finished = require('./end-of-stream');\nconst kLastResolve = Symbol('lastResolve');\nconst kLastReject = Symbol('lastReject');\nconst kError = Symbol('error');\nconst kEnded = Symbol('ended');\nconst kLastPromise = Symbol('lastPromise');\nconst kHandlePromise = Symbol('handlePromise');\nconst kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value,\n    done\n  };\n}\nfunction readAndResolve(iter) {\n  const resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    const data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return (resolve, reject) => {\n    lastPromise.then(() => {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nconst AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nconst ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({\n  get stream() {\n    return this[kStream];\n  },\n  next() {\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    const error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise((resolve, reject) => {\n        process.nextTick(() => {\n          if (this[kError]) {\n            reject(this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    const lastPromise = this[kLastPromise];\n    let promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      const data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  },\n  [Symbol.asyncIterator]() {\n    return this;\n  },\n  return() {\n    // destroy(err, cb) is a private API\n    // we can guarantee we have that here, because we control the\n    // Readable class this is attached to\n    return new Promise((resolve, reject) => {\n      this[kStream].destroy(null, err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(createIterResult(undefined, true));\n      });\n    });\n  }\n}, AsyncIteratorPrototype);\nconst createReadableStreamAsyncIterator = stream => {\n  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {\n    [kStream]: {\n      value: stream,\n      writable: true\n    },\n    [kLastResolve]: {\n      value: null,\n      writable: true\n    },\n    [kLastReject]: {\n      value: null,\n      writable: true\n    },\n    [kError]: {\n      value: null,\n      writable: true\n    },\n    [kEnded]: {\n      value: stream._readableState.endEmitted,\n      writable: true\n    },\n    // the function passed to new Promise\n    // is cached so we avoid allocating a new\n    // closure at every run\n    [kHandlePromise]: {\n      value: (resolve, reject) => {\n        const data = iterator[kStream].read();\n        if (data) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          resolve(createIterResult(data, false));\n        } else {\n          iterator[kLastResolve] = resolve;\n          iterator[kLastReject] = reject;\n        }\n      },\n      writable: true\n    }\n  });\n  iterator[kLastPromise] = null;\n  finished(stream, err => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      const reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    const resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst _require = require('buffer'),\n  Buffer = _require.Buffer;\nconst _require2 = require('util'),\n  inspect = _require2.inspect;\nconst custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n  shift() {\n    if (this.length === 0) return;\n    const ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n  join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) ret += s + p.data;\n    return ret;\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    var ret;\n    if (n < this.head.data.length) {\n      // `slice` is the same for buffers and strings.\n      ret = this.head.data.slice(0, n);\n      this.head.data = this.head.data.slice(n);\n    } else if (n === this.head.data.length) {\n      // First chunk is a perfect match.\n      ret = this.shift();\n    } else {\n      // Result spans more than one buffer.\n      ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n    }\n    return ret;\n  }\n  first() {\n    return this.head.data;\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    var p = this.head;\n    var c = 1;\n    var ret = p.data;\n    n -= ret.length;\n    while (p = p.next) {\n      const str = p.data;\n      const nb = n > str.length ? str.length : n;\n      if (nb === str.length) ret += str;else ret += str.slice(0, n);\n      n -= nb;\n      if (n === 0) {\n        if (nb === str.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = str.slice(nb);\n        }\n        break;\n      }\n      ++c;\n    }\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    var p = this.head;\n    var c = 1;\n    p.data.copy(ret);\n    n -= p.data.length;\n    while (p = p.next) {\n      const buf = p.data;\n      const nb = n > buf.length ? buf.length : n;\n      buf.copy(ret, ret.length - n, 0, nb);\n      n -= nb;\n      if (n === 0) {\n        if (nb === buf.length) {\n          ++c;\n          if (p.next) this.head = p.next;else this.head = this.tail = null;\n        } else {\n          this.head = p;\n          p.data = buf.slice(nb);\n        }\n        break;\n      }\n      ++c;\n    }\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [custom](_, options) {\n    return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    }));\n  }\n};","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState && this._readableState.destroyed;\n  const writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, err => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const rState = stream._readableState;\n  const wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy,\n  undestroy,\n  errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nconst ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  let called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  let readable = opts.readable || opts.readable !== false && stream.readable;\n  let writable = opts.writable || opts.writable !== false && stream.writable;\n  const onlegacyfinish = () => {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  const onfinish = () => {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  const onend = () => {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  const onerror = err => {\n    callback.call(stream, err);\n  };\n  const onclose = () => {\n    let err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  const onrequest = () => {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nlet eos;\nfunction once(callback) {\n  let called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback(...arguments);\n  };\n}\nconst _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  let closed = false;\n  stream.on('close', () => {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, err => {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  let destroyed = false;\n  return err => {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  const callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  let error;\n  const destroys = streams.map(function (stream, i) {\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;","'use strict';\n\nconst ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      const name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark\n};","module.exports = require('events').EventEmitter;\n","var ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\tself._socketTimeout = null\n\tself._socketTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tif ('timeout' in opts && opts.timeout !== 0) {\n\t\tself.setTimeout(opts.timeout)\n\t}\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n        body = new Blob(self._body, {\n            type: (headersObj['content-type'] || {}).value || ''\n        });\n    }\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._resetTimers(false)\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself._resetTimers(true)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself._resetTimers(true)\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tself._resetTimers(false)\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress(self._resetTimers.bind(self))\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype._resetTimers = function (done) {\n\tvar self = this\n\n\tglobal.clearTimeout(self._socketTimer)\n\tself._socketTimer = null\n\n\tif (done) {\n\t\tglobal.clearTimeout(self._fetchTimer)\n\t\tself._fetchTimer = null\n\t} else if (self._socketTimeout) {\n\t\tself._socketTimer = global.setTimeout(function () {\n\t\t\tself.emit('timeout')\n\t\t}, self._socketTimeout)\n\t}\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {\n\tvar self = this\n\tself._destroyed = true\n\tself._resetTimers(true)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n\n\tif (err)\n\t\tself.emit('error', err)\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.setTimeout = function (timeout, cb) {\n\tvar self = this\n\n\tif (cb)\n\t\tself.once('timeout', cb)\n\n\tself._socketTimeout = timeout\n\tself._resetTimers(false)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\tresetTimers(false)\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tresetTimers(result.done)\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(Buffer.from(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tresetTimers(true)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function (resetTimers) {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text':\n\t\t\tresponse = xhr.responseText\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tresetTimers(true)\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tresetTimers(true)\n\t\tself.push(null)\n\t}\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nconst Readable = require('./_stream_readable');\nconst Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  const keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    const method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nconst EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nconst debugUtil = require('util');\nlet debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nconst BufferList = require('./internal/streams/buffer_list');\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nlet StringDecoder;\nlet createReadableStreamAsyncIterator;\nlet from;\nrequire('inherits')(Readable, Stream);\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nconst kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  let p = this._readableState.buffer.head;\n  let content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', () => {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) this.push(chunk);\n    }\n    this.push(null);\n  });\n  stream.on('data', chunk => {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = n => {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      const wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  this.next = null;\n  this.entry = null;\n  this.finish = () => {\n    onCorkedFinish(this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nconst internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nconst Buffer = require('buffer').Buffer;\nconst OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nconst destroyImpl = require('./internal/streams/destroy');\nconst _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nconst _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nconst errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  const isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk,\n      encoding,\n      isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(err => {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        const rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nconst finished = require('./end-of-stream');\nconst kLastResolve = Symbol('lastResolve');\nconst kLastReject = Symbol('lastReject');\nconst kError = Symbol('error');\nconst kEnded = Symbol('ended');\nconst kLastPromise = Symbol('lastPromise');\nconst kHandlePromise = Symbol('handlePromise');\nconst kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value,\n    done\n  };\n}\nfunction readAndResolve(iter) {\n  const resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    const data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return (resolve, reject) => {\n    lastPromise.then(() => {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nconst AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nconst ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({\n  get stream() {\n    return this[kStream];\n  },\n  next() {\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    const error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise((resolve, reject) => {\n        process.nextTick(() => {\n          if (this[kError]) {\n            reject(this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    const lastPromise = this[kLastPromise];\n    let promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      const data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  },\n  [Symbol.asyncIterator]() {\n    return this;\n  },\n  return() {\n    // destroy(err, cb) is a private API\n    // we can guarantee we have that here, because we control the\n    // Readable class this is attached to\n    return new Promise((resolve, reject) => {\n      this[kStream].destroy(null, err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(createIterResult(undefined, true));\n      });\n    });\n  }\n}, AsyncIteratorPrototype);\nconst createReadableStreamAsyncIterator = stream => {\n  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {\n    [kStream]: {\n      value: stream,\n      writable: true\n    },\n    [kLastResolve]: {\n      value: null,\n      writable: true\n    },\n    [kLastReject]: {\n      value: null,\n      writable: true\n    },\n    [kError]: {\n      value: null,\n      writable: true\n    },\n    [kEnded]: {\n      value: stream._readableState.endEmitted,\n      writable: true\n    },\n    // the function passed to new Promise\n    // is cached so we avoid allocating a new\n    // closure at every run\n    [kHandlePromise]: {\n      value: (resolve, reject) => {\n        const data = iterator[kStream].read();\n        if (data) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          resolve(createIterResult(data, false));\n        } else {\n          iterator[kLastResolve] = resolve;\n          iterator[kLastReject] = reject;\n        }\n      },\n      writable: true\n    }\n  });\n  iterator[kLastPromise] = null;\n  finished(stream, err => {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      const reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    const resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState && this._readableState.destroyed;\n  const writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, err => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const rState = stream._readableState;\n  const wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy,\n  undestroy,\n  errorOrDestroy\n};","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').slice(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.slice(1, -1);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\nvar gOPD = require('gopd');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = require('is-typed-array');\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","/**\n* Simple browser shim loader - assign the npm module to a window global automatically\n*\n* @license MIT\n* @author <steven@velozo.com>\n*/\nvar libNPMModuleWrapper = require('./Meadow-Endpoints.js');\n\nif ((typeof(window) === 'object') && !window.hasOwnProperty('MeadowEndpoints'))\n{\n\twindow.MeadowEndpoints = libNPMModuleWrapper;\n}\n\nmodule.exports = libNPMModuleWrapper;","/**\n* Meadow Endpoints Service Data Broker Library\n*\n* @license MIT\n* @author Steven Velozo <steven@velozo.com>\n*/\n\nconst libMeadowEndpointsControllerBase = require('./controller/Meadow-Endpoints-Controller-Base.js');\nconst libMeadow = require('meadow');\n\nclass MeadowEndpoints\n{\n\tconstructor(pMeadow, pControllerOptions)\n\t{\n\t\tthis._Meadow = pMeadow;\n\t\t// This is for backwards compatibility\n\t\tthis.DAL = this._Meadow;\n\n\t\tthis._Controller = false;\n\t\tthis._ControllerOptions = (typeof(pControllerOptions) == 'object') ? pControllerOptions : {};\n\n\t\tif (typeof(pMeadow) != 'object')\n\t\t{\n\t\t\tthrow new Error('Meadow endpoints requires a valid Meadow DAL object as the first parameter of the constructor.');\n\t\t}\n\n\t\tif (this._ControllerOptions.hasOwnProperty('ControllerInstance'))\n\t\t{\n\t\t\t// Passed in already instantiated controller instance\n\t\t\tthis._Controller = this._ControllerOptions.ControllerInstance;\n\t\t}\n\t\telse if (this._ControllerOptions.hasOwnProperty('ControllerClass'))\n\t\t{\n\t\t\t// Passed in controller class, ready to initialize\n\t\t\tthis._Controller = new this._ControllerOptions.ControllerClass(this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._Controller = new libMeadowEndpointsControllerBase(this);\n\t\t}\n\n\t\t// Pull version from the settings; default to 1.0\n\t\tthis.EndpointVersion = this._Controller.settings.MeadowEndpointVersion || '1.0';\n\t\t// Pull endpoint name from settings if the user to override the endpoint \"name\" eventually.\n\t\tthis.EndpointName = this.DAL.scope;\n\t\t// This allows a wily developer to change what this prefix is....\n\t\tthis.EndpointPrefix = `/${this.EndpointVersion}/${this.EndpointName}`;\n\n\t\t// The default behavior sets available.\n\t\t// Turning these off before wiring the endpoints up will result in their counterpart endpoints not being available.\n\t\tthis._EnabledBehaviorSets = (\n\t\t{\n\t\t\tCreate: true,\n\t\t\tRead: true,\n\t\t\tReads: true,\n\t\t\tUpdate: true,\n\t\t\tDelete: true,\n\t\t\tCount: true,\n\t\t\tSchema: true,\n\t\t\tValidate: true,\n\t\t\tNew: true\n\t\t});\n\n\t\t// The default endpoints\n\t\tthis._Endpoints = (\n\t\t{\n\t\t\tCreate: require('./endpoints/create/Meadow-Endpoint-Create.js'),\n\t\t\tCreates: require('./endpoints/create/Meadow-Endpoint-BulkCreate.js'),\n\n\t\t\tRead: require('./endpoints/read/Meadow-Endpoint-Read.js'),\n\t\t\tReadMax: require('./endpoints/read/Meadow-Endpoint-ReadMax.js'),\n\n\t\t\tReads: require('./endpoints/read/Meadow-Endpoint-Reads.js'),\n\t\t\tReadsBy: require('./endpoints/read/Meadow-Endpoint-ReadsBy.js'),\n\n\t\t\tReadSelectList: require('./endpoints/read/Meadow-Endpoint-ReadSelectList.js'),\n\t\t\tReadLiteList: require('./endpoints/read/Meadow-Endpoint-ReadLiteList.js'),\n\t\t\tReadDistinctList: require('./endpoints/read/Meadow-Endpoint-ReadDistinctList.js'),\n\n\t\t\tUpdate: require('./endpoints/update/Meadow-Endpoint-Update.js'),\n\t\t\tUpdates: require('./endpoints/update/Meadow-Endpoint-BulkUpdate.js'),\n\n\t\t\tUpsert: require('./endpoints/upsert/Meadow-Endpoint-Upsert.js'),\n\t\t\tUpserts: require('./endpoints/upsert/Meadow-Endpoint-BulkUpsert.js'),\n\n\t\t\tDelete: require('./endpoints/delete/Meadow-Endpoint-Delete.js'),\n\t\t\tUndelete: require('./endpoints/delete/Meadow-Endpoint-Undelete.js'),\n\n\t\t\tCount: require('./endpoints/count/Meadow-Endpoint-Count.js'),\n\t\t\tCountBy: require('./endpoints/count/Meadow-Endpoint-CountBy.js'),\n\n\t\t\t// Get the JSONSchema spec schema\n\t\t\t/* http://json-schema.org/examples.html\n\t\t\t * http://json-schema.org/latest/json-schema-core.html\n\t\t\t */\n\t\t\tSchema: require('./endpoints/schema/Meadow-Endpoint-Schema.js'),\n\t\t\t// Validate a passed-in JSON object for if it matches the schema\n\t\t\tValidate: require('./endpoints/schema/Meadow-Endpoint-Validate.js'),\n\t\t\t// Get an empty initialized JSON object for this.\n\t\t\tNew: require('./endpoints/schema/Meadow-Endpoint-New.js')\n\t\t});\n\t}\n\n\tget controller()\n\t{\n\t\treturn this._Controller;\n\t}\n\tset controller(pController)\n\t{\n\t\tthis._Controller = pController;\n\t}\n\n\t/**\n\t* Customize a default endpoint (or create more)\n\t*\n\t* @method setEndpoint\n\t*/\n\tsetBehaviorEndpoint(pEndpointHash, fEndpoint)\n\t{\n\t\tif (typeof(fEndpoint) === 'function')\n\t\t{\n\t\t\tthis._Endpoints[pEndpointHash] = fEndpoint;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tconnectRoute(pServiceServer, pRequestMethod, pRoutePartial, pEndpointProcessingFunction, pBehaviorName)\n\t{\n\t\tlet tmpRoute = `${this.EndpointPrefix}${pRoutePartial}`;\n\t\tlet tmpBehaviorName = (typeof(pBehaviorName) == 'string') ? pBehaviorName : 'an unnamed custom behavior'\n\n\t\tthis._Controller.log.trace(`...meadow-endpoints mapping a ${pRequestMethod} endpoint for scope ${this.DAL.scope} on route [${tmpRoute}] which runs ${tmpBehaviorName}.`);\n\n\t\ttry\n\t\t{\n\t\t\t(pServiceServer[pRequestMethod])(tmpRoute, pEndpointProcessingFunction.bind(this._Controller));\n\t\t}\n\t\tcatch (pServiceServerRouteConnectError)\n\t\t{\n\t\t\tthis._Controller.log.error(`...error mapping ${pBehaviorName} to method ${pRequestMethod} for scope ${this.DAL.scope} to route [${tmpRoute}]: ${pServiceServerRouteConnectError}`, pServiceServerRouteConnectError.stack);\n\t\t}\n\t\treturn true;\n\t}\n\n\tconnectRoutes(pServiceServer)\n\t{\n\t\tthis._Controller.log.trace(`Creating automatic meadow endpoints at prefix [${this.EndpointPrefix}] for scope ${this.DAL.scope}...`);\n\n\t\t// These special schema services must come in the route table before the READ because they\n\t\t// technically block out the routes for the IDRecord 'Schema' (e.g. GET[/1.0/EntityName/Schema] ==NEEDS=> GET[/1.0/EntityName/100])\n\t\tif (this._EnabledBehaviorSets.Schema)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Schema`, this._Endpoints.Schema, `the internal behavior _Endpoints.Schema`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.New)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Schema/New`, this._Endpoints.New, `the internal behavior _Endpoints.New`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Validate)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'post', `/Schema/Validate`, this._Endpoints.Validate, `the internal behavior _Endpoints.Validate`);\n\t\t}\n\n\t\t// Standard CRUD and Count endpoints\n\t\tif (this._EnabledBehaviorSets.Create)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'post', ``, this._Endpoints.Create, `the internal behavior _Endpoints.Create`);\n\t\t\tthis.connectRoute(pServiceServer, 'post', `s`, this._Endpoints.Creates, `the internal behavior _Endpoints.Creates`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Read)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Max/:ColumnName`, this._Endpoints.ReadMax, `the internal behavior _Endpoints.ReadMax`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/:IDRecord`, this._Endpoints.Read, `the internal behavior _Endpoints.Read`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Reads)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/By/:ByField/:ByValue`, this._Endpoints.ReadsBy, `the internal behavior _Endpoints.ReadsBy`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/By/:ByField/:ByValue/:Begin/:Cap`, this._Endpoints.ReadsBy, `the internal behavior _Endpoints.ReadsBy`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/FilteredTo/:Filter`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select/FilteredTo/:Filter`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `Select/:Begin/:Cap`, this._Endpoints.ReadSelectList, `the internal behavior _Endpoints.ReadSelectList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite/FilteredTo/:Filter`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Lite/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns/FilteredTo/:Filter`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/LiteExtended/:ExtraColumns/:Begin/:Cap`, this._Endpoints.ReadLiteList, `the internal behavior _Endpoints.ReadLiteList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns/FilteredTo/:Filter`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns/FilteredTo/:Filter/:Begin/:Cap`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Distinct/:Columns/:Begin/:Cap`, this._Endpoints.ReadDistinctList, `the internal behavior _Endpoints.ReadDistinctList`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/:Begin/:Cap`, this._Endpoints.Reads, `the internal behavior _Endpoints.Reads`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Update)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'put', ``, this._Endpoints.Update, `the internal behavior _Endpoints.Update`);\n\t\t\tthis.connectRoute(pServiceServer, 'put', `s`, this._Endpoints.Updates, `the internal behavior _Endpoints.Updates`);\n\t\t\tthis.connectRoute(pServiceServer, 'put', `/Upsert`, this._Endpoints.Upsert, `the internal behavior _Endpoints.Upsert`);\n\t\t\tthis.connectRoute(pServiceServer, 'put', `/Upserts`, this._Endpoints.Upserts, `the internal behavior _Endpoints.Upserts`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Delete)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'del', ``, this._Endpoints.Delete, `the internal behavior _Endpoints.Delete`);\n\t\t\tthis.connectRoute(pServiceServer, 'del', `/:IDRecord`, this._Endpoints.Delete, `the internal behavior _Endpoints.Delete`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `/Undelete/:IDRecord`, this._Endpoints.Undelete, `the internal behavior _Endpoints.Undelete`);\n\t\t}\n\t\tif (this._EnabledBehaviorSets.Count)\n\t\t{\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Count`, this._Endpoints.Count, `the internal behavior _Endpoints.Count`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Count/By/:ByField/:ByValue`, this._Endpoints.CountBy, `the internal behavior _Endpoints.CountBy`);\n\t\t\tthis.connectRoute(pServiceServer, 'get', `s/Count/FilteredTo/:Filter`, this._Endpoints.Count, `the internal behavior _Endpoints.Count`);\n\t\t}\n\t}\n}\n\n\n// This is for backwards compatibility\nfunction autoConstruct(pMeadow, pControllerOptions)\n{\n\treturn new MeadowEndpoints(pMeadow, pControllerOptions);\n}\n\nmodule.exports = MeadowEndpoints;\nmodule.exports.new = autoConstruct;\n\nmodule.exports.Meadow = libMeadow;\nmodule.exports.BaseController = libMeadowEndpointsControllerBase;","const libAsyncWaterfall = require('async/waterfall');\n\nconst libBaseLogController = require('./components/Meadow-Endpoints-Controller-Log.js')\n\nconst libBaseErrorController = require('./components/Meadow-Endpoints-Controller-Error.js');\nconst libBaseBehaviorInjectionController = require('./components/Meadow-Endpoints-Controller-BehaviorInjection.js');\n\nconst libMeadowEndpointsFilterParser = require('./utility/Meadow-Endpoints-Filter-Parser.js');\nconst libMeadowEndpointsSessionMarshaler = require('./utility/Meadow-Endpoints-Session-Marshaler.js');\nconst libMeadowEndpointsStreamRecordArray = require('./utility/Meadow-Endpoints-Stream-RecordArray.js');\n\nclass MeadowEndpointControllerBase\n{\n\tconstructor(pMeadowEndpoints)\n\t{\n\t\tthis.DAL = pMeadowEndpoints.DAL;\n\t\tthis.ControllerOptions = pMeadowEndpoints._ControllerOptions\n\n\t\t// Application Services\n\t\tthis._Settings = false;\n\t\tthis._LogController = false;\n\n\t\t// Logic and Behavior\n\t\tthis._BehaviorInjectionController = false;\n\t\tthis._ErrorController = false;\n\n\t\t// Internal async utility functions\n\t\tthis.waterfall = this.DAL.fable.Utility.waterfall;\n\t\tthis.eachLimit = this.DAL.fable.Utility.eachLimit;\n\t\tthis.extend = this.DAL.fable.Utility.extend;\n\n\t\tif ((typeof(pControllerOptions) != 'object') || pControllerOptions.hasOwnProperty('ControllerClass'))\n\t\t{\n\t\t\tthis.initializeDefaultUnsetControllers(this);\n\t\t}\n\n\t\t// Behavior functions\n\t\tthis._FilterParser = new libMeadowEndpointsFilterParser(this);\n\t\tthis._SessionMarshaler = new libMeadowEndpointsSessionMarshaler(this);\n\t\tthis._StreamRecordArray = new libMeadowEndpointsStreamRecordArray(this);\n\t}\n\n\tinitializeDefaultUnsetControllers(pController)\n\t{\n\t\t// Application Services\n\t\tif (!this._Settings)\n\t\t{\n\t\t\tthis._Settings = pController.DAL.fable.settings;\n\t\t}\n\t\tif (!this._Settings.hasOwnProperty('MeadowEndpointsDefaultSessionObject'))\n\t\t{\n\t\t\tthis._Settings.MeadowEndpointsDefaultSessionObject = (\n\t\t\t\t{\n\t\t\t\t\tCustomerID: 0,\n\t\t\t\t\tSessionID: '0x0000',\n\t\t\t\t\tDeviceID: 'Unset',\n\t\t\t\t\tUserID: 0,\n\t\t\t\t\tUserRole: 'None',\n\t\t\t\t\tUserRoleIndex: 0,\n\t\t\t\t\tLoggedIn: false\n\t\t\t\t});\n\t\t}\n\t\tif (!this._LogController)\n\t\t{\n\t\t\tthis._LogController = new libBaseLogController(pController);\n\t\t}\n\t\tif (!this._BehaviorInjectionController)\n\t\t{\n\t\t\tthis._BehaviorInjectionController = new libBaseBehaviorInjectionController(pController);\n\t\t}\n\t\tif (!this._ErrorController)\n\t\t{\n\t\t\tthis._ErrorController = new libBaseErrorController(pController);\n\t\t}\n\t}\n\n\tinitializeRequestState(pRequest, pVerb)\n\t{\n\t\tlet tmpRequestState = {};\n\n\t\ttmpRequestState.Verb = (typeof(pVerb) == 'string') ? pVerb : 'Unnamed_Custom_Behavior';\n\t\ttmpRequestState.SessionData = this.getSessionData(pRequest);\n\n\t\treturn tmpRequestState;\n\t}\n\n\t// Clone the session data and verb to a new request state object\n\tcloneAsyncSafeRequestState(pRequestState, pNewVerb)\n\t{\n\t\tlet tmpSafeRequestState = (\n\t\t\t{\n\t\t\t\tParentRequestState: pRequestState,\n\t\t\t\tSessionData: pRequestState.SessionData\n\t\t\t});\n\n\t\ttmpSafeRequestState.Verb = (typeof(pNewVerb) == 'string') ? pVerb : pRequestState.Verb;\n\n\t\treturn tmpSafeRequestState;\n\t}\n\n\t// Override this to provide an alternate ending function that is run with every endpoint.\n\t_BeginDataRequestFunction(pRequest, pResponse, fNext)\n\t{\n\t\treturn fNext();\n\t}\n\n\tbeginMeadowRequest(pRequest, pResponse, fNext)\n\t{\n\t\tthis._BeginDataRequestFunction(pRequest, pResponse, fNext);\n\t}\n\n\t// Override this to provide an alternate ending function that is run with every endpoint.\n\t_EndDataRequestFunction(pRequest, pResponse, fNext)\n\t{\n\t\treturn fNext();\n\t}\n\n\tendMeadowRequest(pRequest, pResponse, fNext)\n\t{\n\t\tthis._EndDataRequestFunction(pRequest, pResponse, fNext);\n\t}\n\n\t// Application Services\n\tget settings() {return this._Settings; }\n\tset settings(pSettings) { this._Settings = pSettings; }\n\n\tget log() {return this._LogController; }\n\tset log(pLogController) { this._LogController = pLogController; }\n\n\t// Logic and Behavior\n\tget BehaviorInjection() {return this._BehaviorInjectionController; }\n\tset BehaviorInjection(pBehaviorInjectionController) { this._BehaviorInjectionController = pBehaviorInjectionController; }\n\n\tget ErrorHandler() {return this._ErrorController; }\n\tset ErrorHandler(pErrorController) { this._ErrorController = pErrorController; }\n\n\tparseFilter(pFilterString, pQuery)\n\t{\n\t\treturn this._FilterParser.parseFilter(pFilterString, pQuery);\n\t}\n\n\tdoStreamRecordArray(pResponse, pRecords, fCallback)\n\t{\n\t\treturn this._StreamRecordArray.streamRecordArray(pResponse, pRecords, fCallback);\n\t}\n\n\tgetSessionData(pRequest)\n\t{\n\t\treturn this._SessionMarshaler.getSessionData(pRequest);\n\t}\n}\n\nmodule.exports = MeadowEndpointControllerBase;\n\n// Export the base classes for the controller components, for inheritance\nmodule.exports.BaseErrorController = libBaseErrorController;\nmodule.exports.BaseBehaviorInjectionController = libBaseBehaviorInjectionController;\n\nmodule.exports.BaseFilterParser = libMeadowEndpointsFilterParser;\nmodule.exports.BaseSessionMarshaler = libMeadowEndpointsSessionMarshaler;\nmodule.exports.BaseStreamRecordArray = libMeadowEndpointsStreamRecordArray;","class MeadowEndpointsControllerBehaviorInjectionBase\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n\n        // The template compilation function\n\t\tthis.template = this._Controller.DAL.fable.Utility.template;\n\n\t\t// An object to hold modifications to specific behaviors.\n\t\tthis._BehaviorFunctions = {};\n\n\t\t// A set of objects to hold the specific templates and their compiled functions\n\t\tthis._Templates = {};\n\t\tthis._TemplateFunctions = {};\n    }\n\n\t/**\n\t* Set a specific behavior.\n\t*\n\t* The anatomy of a behavior function is as follows:\n\t*\n\t* var someBehavior = function(pRequest, fCallback)\n\t* {\n\t*      // Do some stuff with pRequest...\n\t*      if (pRequest.UserSession.UserRoleIndex < 5)\n\t*          tmpRequestState.Query.addFilter('Customer', pRequest.UserSession.IDCustomer);\n\t*      return fCallback(false);\n\t* }\n\t*\n\t* It is important to note that the fCallback function expects false if no error, or a string message if there is one.\n\t*/\n\tsetBehavior(pBehaviorHash, fBehavior)\n\t{\n\t\tthis._BehaviorFunctions[pBehaviorHash] = fBehavior;\n\t}\n\n\t/**\n\t* This method runs a behavior at a specific hash, and returns true.\n\t* Or it returns false if there was no behavior there.\n\t* Behaviors should expect their state to be in the pRequest object, per the example in setBehavior\n\t*/\n\trunBehavior(pBehaviorHash, pController, pRequest, pRequestState, fCallback)\n\t{\n\t\t// Run an injected behavior (if it exists)\n\t\tif (this._BehaviorFunctions.hasOwnProperty(pBehaviorHash))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Call the behavior with the scoped [this] of the Meadow behavior\n\t\t\t\t// NOTE: If you define a behavior with lambda arrow syntax, it will *not* respect the call\n\t\t\t\treturn this._BehaviorFunctions[pBehaviorHash].call(pController, pRequest, pRequestState, fCallback);\n\t\t\t}\n\t\t\tcatch (pInjectedBehaviorError)\n\t\t\t{\n\t\t\t\treturn fCallback(pInjectedBehaviorError);\n\t\t\t}\n\t\t}\n\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t* Get a template.\n\t*/\n\tgetTemplate(pTemplateHash)\n\t{\n\t\tif (this._Templates.hasOwnProperty(pTemplateHash))\n\t\t{\n\t\t\treturn this._Templates[pTemplateHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t* Set a template.\n\t*/\n\tsetTemplate(pTemplateHash, pTemplate)\n\t{\n\t\t// Store both the cached text as well as the function\n\t\tthis._Templates[pTemplateHash] = pTemplate;\n\t\tthis._TemplateFunctions[pTemplateHash] = this.template(pTemplate);\n\t}\n\n\t/**\n\t* Get a template function.\n\t*/\n\tgetTemplateFunction(pTemplateHash)\n\t{\n\t\tif (this._TemplateFunctions.hasOwnProperty(pTemplateHash))\n\t\t{\n\t\t\treturn this._TemplateFunctions[pTemplateHash];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t* Process a template at a hash, and return the result.\n\t*/\n\tprocessTemplate(pTemplateHash, pTemplateData, pDefaultTemplate)\n\t{\n\t\tvar tmpTemplateFunction = this.getTemplateFunction(pTemplateHash);\n\t\tvar tmpTemplateData = (typeof(pTemplateData) === 'undefined') ? {} : pTemplateData;\n\n\t\t// This makes the function fairly laziliy loading.\n\t\tif (tmpTemplateFunction === false)\n\t\t{\n\t\t\t// If the template doesn't exist, try to use the passed-in default and set that as the template.\n\t\t\t// Otherwise make it empty.\n\t\t\tthis.setTemplate(pTemplateHash, (typeof(pDefaultTemplate) === 'undefined') ? '' : pDefaultTemplate);\n\t\t\ttmpTemplateFunction = this.getTemplateFunction(pTemplateHash);\n\t\t}\n\n\t\t// Now process and return the underscore template.\n\t\treturn tmpTemplateFunction(tmpTemplateData);\n\t}\n}\n\nmodule.exports = MeadowEndpointsControllerBehaviorInjectionBase;","class MeadowEndpointsControllerErrorBase\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    // Get the error object\n    getError(pMessage, pStatusCode, pSuppressSoftwareTrace)\n    {\n\t\tlet tmpError = new Error(pMessage);\n\n    \t// Default the error status code to 400 if none is passed\n\t\ttmpError.StatusCode = (typeof(pStatusCode) == 'number') ? pStatusCode : 400;\n\t\t// This suppresses the stack trace from being sent back or logged.\n\t\t// And by default it does not send a stack trace, as we expect errors created this way to be protocol, schema or data related.\n\t\ttmpError.SuppressSoftwareTrace = (typeof(pSuppressSoftwareTrace) != 'undefined') ? pSuppressSoftwareTrace : true;\n\n        return tmpError;\n    }\n\n    // Handle an error if set -- some errors don't send the response back because they aren't fully errory errors.\n\thandleErrorIfSet(pRequest, pRequestState, pResponse, pError, fCallback)\n\t{\n\t\tif (pError)\n\t\t{\n\t\t\treturn this.sendError(pRequest, pRequestState, pResponse, pError, fCallback);\n\t\t}\n\n\t\treturn fCallback();\n\t}\n\n    // Send an error object\n\tsendError(pRequest, pRequestState, pResponse, pError, fCallback)\n\t{\n\t\tthis._Controller.log.logRequestError(pRequest, pRequestState, pError);\n\n\t\t// TODO: Detect if we've already sent headers?\n\t\tif (!this._Controller.ControllerOptions.SendErrorStatusCodes)\n\t\t{\n\t\t\tlet tmpStatusCode = (pError.hasOwnProperty('StatusCode')) ? pError.StatusCode : 500;\n\t\t\tpResponse.status(tmpStatusCode);\n\t\t}\n\n\t\tlet tmpResponseObject = (\n\t\t\t{\n\t\t\t\tError:pError.message,\n\t\t\t\tStatusCode:pError.StatusCode\n\t\t\t});\n\n\t\ttmpResponseObject = this._Controller.ErrorHandler.prepareRequestContextOutputObject(tmpResponseObject, pRequest, pRequestState, pError);\n\n\t\tpResponse.send(tmpResponseObject);\n\n\t\tfCallback(pError);\n\t}\n\n\t// This looks for some generic markers in the request state and puts them into a log or send object\n\tprepareRequestContextOutputObject(pObjectToPopulate, pRequest, pRequestState, pError)\n\t{\n\t\t// Internally created errors supress stack traces\n\t\tif (pError)\n\t\t{\n\t\t\tpObjectToPopulate.Error = pError.message;\n\t\t\tpObjectToPopulate.Code = pError.code;\n\t\t\tpObjectToPopulate.StatusCode = pError.StatusCode;\n\n\t\t\tif (!pError.SuppressSoftwareTrace)\n\t\t\t{\n\t\t\t\tpObjectToPopulate.Stack = pError.stack;\n\t\t\t}\n\n\t\t\tif (pRequestState.hasOwnProperty('Record'))\n\t\t\t{\n\t\t\t\tpObjectToPopulate.Record = pRequestState.Record;\n\t\t\t}\n\n\t\t\tif (pRequestState.hasOwnProperty('Query') && (typeof(pRequestState.Query) == 'object'))\n\t\t\t{\n\t\t\t\tif (pRequestState.Query.query)\n\t\t\t\t{\n\t\t\t\t\tif (typeof(pRequestState.Query.query.body) == 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\tpObjectToPopulate.Query = pRequestState.Query.query.body;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((typeof(pRequestState.Query.query.parameters) == 'object'))\n\t\t\t\t\t{\n\t\t\t\t\t\tpObjectToPopulate.QueryParameters = pRequestState.Query.query.parameters;\n\n\t\t\t\t\t\tpObjectToPopulate.RebuiltQueryString = (typeof(pObjectToPopulate.Query) == 'string') ? pObjectToPopulate.Query : '';\n\n\t\t\t\t\t\t// This gnarly bit of code attempts to reconstruct a non prepared string version of the query, to help.\n\t\t\t\t\t\tlet tmpQueryParameterSet = Object.keys(pObjectToPopulate.QueryParameters);\n\t\t\t\t\t\tfor (let i = 0; i < tmpQueryParameterSet.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch(typeof(tmpQueryParameterSet[i]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\t\t\tpObjectToPopulate.RebuiltQueryString  = pObjectToPopulate.RebuiltQueryString.replace(new RegExp(`:${tmpQueryParameterSet[i]}\\\\b`, 'g'), `'${pObjectToPopulate.QueryParameters[tmpQueryParameterSet[i]]}'`);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\t\t\t// TODO: This may need more ... nuance...\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tpObjectToPopulate.RebuiltQueryString  = pObjectToPopulate.RebuiltQueryString.replace(new RegExp(`:${tmpQueryParameterSet[i]}\\\\b`,'g'), pObjectToPopulate.QueryParameters[tmpQueryParameterSet[i]]);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pObjectToPopulate;\n\t}\n}\n\nmodule.exports = MeadowEndpointsControllerErrorBase;","class MeadowEndpointsControllerLogBase\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    // This is called whenever an endpoint is completed successfully\n\trequestCompletedSuccessfully(pRequest, pRequestState, pActionSummary)\n\t{\n\t\tthis._Controller.log.info(pActionSummary,\n\t\t\t{\n\t\t\t\tSessionID: pRequestState.SessionData.SessionID,\n\t\t\t\tRequestID: pRequest.RequestUUID,\n\t\t\t\tRequestURL: pRequest.url,\n\t\t\t\tScope: this._Controller.DAL.scope,\n\t\t\t\tAction: `${this._Controller.DAL.scope}-${pRequestState.Verb}`,\n\t\t\t\tVerb: pRequestState.Verb\n\t\t\t});\n\t}\n\n    // This is called whenever an endpoint is completed successfully\n\tlogRequestError(pRequest, pRequestState, pError)\n\t{\n\t\tlet tmpErrorLogData = (\n\t\t\t{\n\t\t\t\tSessionID: pRequestState.SessionData.SessionID,\n\t\t\t\tRequestID: pRequest.RequestUUID,\n\t\t\t\tRequestURL: pRequest.url,\n\t\t\t\tScope: this._Controller.DAL.scope,\n\t\t\t\tAction: `${this._Controller.DAL.scope}-${pRequestState.Verb}`,\n\t\t\t\tVerb: pRequestState.Verb,\n\t\t\t});\n\n\t\ttmpErrorLogData = this._Controller.ErrorHandler.prepareRequestContextOutputObject(tmpErrorLogData, pRequest, pRequestState, pError);\n\n\t\tthis._Controller.log.error(pError.message, tmpErrorLogData);\n\t}\n\n    trace(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.trace(pLogText, pLogObject);\n\t}\n\n\tdebug(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.debug(pLogText, pLogObject);\n\t}\n\n\tinfo(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.info(pLogText, pLogObject);\n\t}\n\n\twarn(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.warn(pLogText, pLogObject);\n\t}\n\n\terror(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.error(pLogText, pLogObject);\n\t}\n\n\tfatal(pLogText, pLogObject)\n\t{\n\t\tthis._Controller.DAL.log.fatal(pLogText, pLogObject);\n\t}\n}\n\nmodule.exports = MeadowEndpointsControllerLogBase;","/**\n* Meadow Endpoint Utility Class - Parse a Filter String and put it into a Query.\n*\n* @license MIT\n*\n* @author Steven Velozo <steven@velozo.com>\n* @module Meadow\n*/\n/**\n* Parse GET-passed Filter Strings, turn the results into proper Meadow query stanzas\n\n Take the filter and return an array of filter instructions\n Basic instruction anatomy:\n       INSTRUCTION~FIELD~OPERATOR~VALUE\n FOP - Filter Open Paren\n       FOP~0~(~0\n FCP - Filter Close Paren\n       FCP~0~)~0\n FBV - Filter By Value (left-side AND connected)\n       FBV~Category~EQ~Books\n       Possible comparisons:\n       * EQ - Equals To (=)\n       * NE - Not Equals To (!=)\n       * GT - Greater Than (>)\n       * GE - Greater Than or Equals To (>=)\n       * LT - Less Than (<)\n       * LE - Less Than or Equals To (<=)\n       * LK - Like (Like)\n       * IN - Is NULL\n       * NN - Is NOT NULL\n       * INN - IN list\n FBVOR - Filter By Value (left-side OR connected)\n FBL - Filter By List (value list, separated by commas)\n       FBL~Category~EQ~Books,Movies\n FBD - Filter by Date (exclude time)\n       FBD~UpdateDate~EQ~2015-10-01\n FSF - Filter Sort Field\n       FSF~Category~ASC~0\n       FSF~Category~DESC~0\n FDST - Filter by Distinct (adds distinct keyword to Read and Count queries)\n       FDST~0~0~0~\n\n This means: FBV~Category~EQ~Books~FBV~PublishedYear~GT~2000~FSF~PublishedYear~DESC~0\n             Filters down to ALL BOOKS PUBLUSHED AFTER 2000 IN DESCENDING ORDER\n*/\n\nclass MeadowEndpointsFilterParser\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    // Get the comparison operator for use in a query stanza\n    getFilterComparisonOperator(pFilterOperator)\n    {\n        let tmpOperator = '=';\n        switch(pFilterOperator)\n        {\n            case 'EQ':\n                tmpOperator = '=';\n                break;\n            case 'NE':\n                tmpOperator = '!=';\n                break;\n            case 'GT':\n                tmpOperator = '>';\n                break;\n            case 'GE':\n                tmpOperator = '>=';\n                break;\n            case 'LT':\n                tmpOperator = '<';\n                break;\n            case 'LE':\n                tmpOperator = '<=';\n                break;\n            case 'LK':\n                tmpOperator = 'LIKE';\n                break;\n            case 'NLK':\n                tmpOperator = 'NOT LIKE';\n                break;\n            case 'IN':\n                tmpOperator = 'IS NULL';\n                break;\n            case 'NN':\n                tmpOperator = 'IS NOT NULL';\n                break;\n            case 'INN':\n                tmpOperator = 'IN';\n                break;\n            case 'FOP':\n                tmpOperator = '(';\n                break;\n            case 'FCP':\n                tmpOperator = ')';\n                break;\n        }\n        return tmpOperator;\n    }\n\n    addFilterStanzaToQuery(pFilterStanza, pQuery)\n    {\n        if (!pFilterStanza.Instruction)\n        {\n            return false;\n        }\n\n        switch(pFilterStanza.Instruction)\n        {\n            case 'FBV':   // Filter by Value (left-side AND)\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value, getFilterComparisonOperator(pFilterStanza.Operator), 'AND');\n                break;\n\n            case 'FBVOR': // Filter by Value (left-side OR)\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value, getFilterComparisonOperator(pFilterStanza.Operator), 'OR');\n                break;\n\n            case 'FBL':   // Filter by List (left-side AND)\n                // Just split the value by comma for now.  May want to revisit better characters or techniques later.\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'AND');\n                break;\n\n            case 'FBLOR': // Filter by List (left-side OR)\n                // Just split the value by comma for now.  May want to revisit better characters or techniques later.\n                pQuery.addFilter(pFilterStanza.Field, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'OR');\n                break;\n\n            case 'FBD': // Filter by Date (exclude time)\n                pQuery.addFilter(`DATE(${pFilterStanza.Field})`, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'AND', pFilterStanza.Field);\n                break;\n\n            case 'FBDOR': // Filter by Date (exclude time)\n                pQuery.addFilter(`DATE(${pFilterStanza.Field})`, pFilterStanza.Value.split(','), getFilterComparisonOperator(pFilterStanza.Operator), 'OR', pFilterStanza.Field);\n                break;\n\n            case 'FSF':   // Filter Sort Field\n                const tmpSortDirection = (pFilterStanza.Operator === 'DESC') ? 'Descending' : 'Ascending';\n                pQuery.addSort({ Column: pFilterStanza.Field, Direction: tmpSortDirection });\n                break;\n\n            case 'FOP':   // Filter Open Paren\n                pQuery.addFilter('', '', '(');\n                break;\n\n            case 'FCP':   // Filter Close Paren\n                pQuery.addFilter('', '', ')');\n                break;\n\n            case 'FDST':   // Filter Distinct\n                // ensure we don't break if using an older foxhound version\n                if (pQuery.setDistinct)\n                {\n                    pQuery.setDistinct(true);\n                }\n                break;\n\n            default:\n                //console.log('Unparsable filter stanza.');\n                return false;\n                break;\n        }\n\n        // Be paranoid about the instruction\n        pFilterStanza.Instruction = false;\n        return true;\n    };\n\n    parseFilter(pFilterString, pQuery)\n    {\n        if (typeof(pFilterString) !== 'string')\n        {\n            return false;\n        }\n\n        const tmpFilterTerms = pFilterString.split('~');\n\n        if (tmpFilterTerms.length < 4)\n        {\n            return true;\n        }\n\n        let tmpFilterStanza = { Instruction: false };\n\n        for (let i = 0; i < tmpFilterTerms.length; i++)\n        {\n            switch(i % 4)\n            {\n                case 0:  // INSTRUCTION\n                    addFilterStanzaToQuery(tmpFilterStanza, pQuery);\n                    //console.log(i+' Instruction: '+tmpFilterTerms[i]);\n                    tmpFilterStanza = (\n                    {\n                        Instruction: tmpFilterTerms[i],\n                        Field: '',\n                        Operator: '',\n                        Value: ''\n                    });\n                    break;\n\n                case 1:  // FIELD\n                    //console.log(i+' Field:       '+tmpFilterTerms[i]);\n                    tmpFilterStanza.Field = tmpFilterTerms[i];\n                    break;\n\n                case 2:  // OPERATOR\n                    //console.log(i+' Operator:    '+tmpFilterTerms[i]);\n                    tmpFilterStanza.Operator = tmpFilterTerms[i];\n                    break;\n\n                case 3:  // VALUE\n                    //console.log(i+' Value:       '+tmpFilterTerms[i]);\n                    tmpFilterStanza.Value = tmpFilterTerms[i];\n                    break;\n            }\n        }\n\n        this.addFilterStanzaToQuery(tmpFilterStanza, pQuery);\n\n        return true;\n    };\n}\n\nmodule.exports = MeadowEndpointsFilterParser;","class MeadowEndpointsSessionMarshaler\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n    getSessionData(pRequest)\n    {\n        let tmpSession = Object.assign({}, this._Controller.settings.MeadowEndpointsDefaultSessionObject);\n\n        switch (this._Controller.settings.MeadowEndpointsSessionDataSource || 'Request')\n        {\n            default:\n                this._LogController.warn(`Unknown session source configured: ${_SessionDataSource} - defaulting to Request for backward compatibility`);\n            case 'Request':\n                // noop - already set by orator-session\n                tmpSession = this._Controller.extend(tmpSession, pRequest.UserSession);\n                break;\n            case 'None':\n                break;\n            case 'Header':\n                try\n                {\n                    const tmpHeaderSessionString = pRequest.headers['x-trusted-session'];\n                    if (!tmpHeaderSessionString)\n                    {\n                        break;\n                    }\n                    tmpHeaderSession = JSON.parse(tmpHeaderSessionString);\n                    tmpSession = this._Controller.extend(tmpSession, pRequest.tmpHeaderSession);\n                }\n                catch (pError)\n                {\n                    this._LogController.error(`Meadow Endpoints attempted to process a Header Session String with value [${tmpHeaderSessionString}] and failed -- likely culprit is bad JSON.`)\n                }\n                break;\n        }\n\n        // Do we keep this here for backwards compatibility?\n        // Yes this makes sense here.\n        pRequest.UserSession = tmpSession;\n\n        return tmpSession;\n    }\n}\n\nmodule.exports = MeadowEndpointsSessionMarshaler;","/**\n* Meadow Endpoint Streamer - Stream an array of recods as JSON to an output stream.\n*/\nconst libAsyncEachSeries = require('async/eachSeries');\nconst JSONStream = require('JSONStream');\n\nclass MeadowEndpointsStreamRecordArray\n{\n    constructor(pController)\n\t{\n        this._Controller = pController;\n    }\n\n\tchunk(pInput, pChunkSize, pChunkCache)\n\t{\n\t\tlet tmpInputArray = [...pInput];\n\t\t// Note lodash defaults to 1, underscore defaults to 0\n\t\tlet tmpChunkSize = (typeof(pChunkSize) == 'number') ? pChunkSize : 0;\n\t\tlet tmpChunkCache = (typeof(pChunkCache) != 'undefined') ? pChunkCache : [];\n\n\t\tif (tmpChunkSize <= 0)\n\t\t{\n\t\t\treturn tmpChunkCache;\n\t\t}\n\n\t\twhile (tmpInputArray.length)\n\t\t{\n\t\t\ttmpChunkCache.push(tmpInputArray.splice(0, tmpChunkSize));\n\t\t}\n\n\t\treturn tmpChunkCache;\n\t}\n\n\tstreamRecordArray(pResponse, pRecords, fCallback)\n\t{\n\t\t// for meadow invoke, writeHead isn't provided, so just call send(), which is the shim it uses...\n\t\t// also, for small arrays, don't bother with the async serialization; this threshold could use tuning\n\t\tif (!pResponse.writeHead || !Array.isArray(pRecords) || pRecords.length < 2500)\n\t\t{\n\t\t\tpResponse.send(pRecords);\n\t\t\treturn fCallback();\n\t\t}\n\n\t\tpResponse.writeHead(200,\n\t\t{\n\t\t\t'content-type': 'application/json',\n\t\t});\n\n\t\tconst recordJsonMarshaller = JSONStream.stringify();\n\t\trecordJsonMarshaller.pipe(pResponse);\n\n\t\t// we write the records in chunks; doing one per loop is very inefficient, doing all is the same as not doing this at all\n\t\tlibAsyncEachSeries(this.chunk(pRecords, 1000), (pRecordChunk, fNext) =>\n\t\t{\n\t\t\tpRecordChunk.forEach(recordJsonMarshaller.write);\n\t\t\tsetImmediate(fNext);\n\t\t},\n\t\t(error) =>\n\t\t{\n\t\t\trecordJsonMarshaller.end();\n\t\t\tfCallback(error);\n\t\t});\n\t}\n}\n\nmodule.exports = MeadowEndpointsStreamRecordArray;","/**\n* Meadow Endpoint - Count a Record\n*/\nconst doAPIEndpointCount = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Count');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t\t{\n\t\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t\t}\n\t\t\t\telse if (pRequest.params.Filter)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Count-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doCount(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Result = {Count:pCount};\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.Result);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Delivered recordset count of ${tmpRequestState.Result.Count} for ${this.DAL.scope}.`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointCount;\n","/**\n* Meadow Endpoint - Count a Record filtered by a single value\n*/\nconst doAPIEndpointCountBy = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'CountBy');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\ttmpRequestState.Query.addFilter(pRequest.params.ByField, pRequest.params.ByValue, '=', 'AND', 'RequestByField');\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`CountBy-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doCount(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Result = {Count:pCount};\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Delivered recordset count of '+tmpRequestState.Result.Count+'.');\n\t\t\t\tpResponse.send(tmpRequestState.Result);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\n\nmodule.exports = doAPIEndpointCountBy;","/**\n* Meadow Endpoint - Create a set of Record in Bulk\n*/\n\nconst doCreate = require('./Meadow-Operation-Create.js');\n\nconst doAPIEndpointBulkCreate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'CreateBulk');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.CreatedRecords = [];\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (!Array.isArray(pRequest.body))\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Bulk record create failure - a valid array of records to create is required.', 500));\n\t\t\t}\n\t\t\tpRequest.RecordsToBulkCreate = pRequest.body;\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`CreateBulk-PreOperation`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tlibAsync.eachSeries(pRequest.RecordsToBulkCreate,\n\t\t\t\t(pRecord, fCallback) =>\n\t\t\t\t{\n\t\t\t\t\tdoCreate.call(this, pRecord, pRequest, tmpRequestState, pResponse, fCallback);\n\t\t\t\t}, fStageComplete);\n\t\t},\n\t\tfBehaviorInjector(`CreateBulk-PostOperation`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.CreatedRecords, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Created a record with ID '+pNewRecord[this.DAL.defaultIdentifier]+'.');\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointBulkCreate;","/**\n* Meadow Endpoint - Create a Record\n*/\nconst doCreate = require('./Meadow-Operation-Create.js');\n\nconst doAPIEndpointCreate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Create');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (typeof(pRequest.body) !== 'object')\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record create failure - a valid record is required.', 500));\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tdoCreate.call(this, pRequest.body, pRequest, tmpRequestState, pResponse, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (tmpRequestState.RecordCreateError)\n\t\t\t{\n\t\t\t\treturn fStageComplete(tmpRequestState.RecordCreateErrorObject);\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Created a ${this.DAL.scope} record ID ${tmpRequestState.Record.IDRecord}`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointCreate;","/**\n* Meadow Operation - Create a record function\n*/\nconst doCreate = function(pRecord, pRequest, pRequestState, pResponse, fCallback)\n{\n\t// This is a virtual operation\n\tlet tmpRequestState = cloneAsyncSafeRequestState(pRequestState, 'doCreate');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tif (!Array.isArray(tmpRequestState.ParentRequestState.CreatedRecords))\n\t{\n\t\ttmpRequestState.ParentRequestState.CreatedRecords = [];\n\t}\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.RecordToCreate = pRecord;\n\n\t\t\t//Make sure record gets created with a customerID\n\t\t\tif (!tmpRequestState.RecordToCreate.hasOwnProperty('IDCustomer') && this.DAL.jsonSchema.properties.hasOwnProperty('IDCustomer'))\n\t\t\t{\n\t\t\t\ttmpRequestState.RecordToCreate.IDCustomer = tmpRequestState.SessionData.CustomerID || 0;\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) => { this.BehaviorInjection.runBehavior(`Create-PreOperation`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\t// Prepare create query\n\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\ttmpRequestState.Query.addRecord(tmpRequestState.RecordToCreate);\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) => { this.BehaviorInjection.runBehavior(`Create-QueryConfiguration`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\t// Do the actual create operation with the DAL\n\t\t\tthis.DAL.doCreate(tmpRequestState.Query,\n\t\t\t\t(pError, pQuery, pReadQuery, pNewRecord) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t}\n\t\t\t\t\tif (!pNewRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError(`Error in DAL Create: No record returned from persistence engine.`, 500));\n\t\t\t\t\t}\n\n\t\t\t\t\ttmpRequestState.Record = pNewRecord;\n\n\t\t\t\t\treturn fStageComplete();\n\t\t\t\t});\n\t\t},\n\t\t(fStageComplete) => { return this.BehaviorInjection.runBehavior(`Create-PostOperation`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.ParentRequestState.CreatedRecords.push(tmpRequestState.Record);\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Created a record with ${this.DAL.defaultIdentifier} = ${tmpRequestState.Record[this.DAL.defaultIdentifier]}`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\tif (pError)\n\t\t{\n\t\t\ttmpRequestState.RecordToCreate.Error = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.RecordCreateError = true;\n\t\t\ttmpRequestState.ParentRequestState.RecordCreateErrorObject = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.CreatedRecords.push(tmpRequestState.RecordToCreate);\n\t\t}\n\n\t\treturn fCallback();\n\t});\n};\n\nmodule.exports = doCreate;","/**\n* Meadow Endpoint - Delete a Record\n*/\nconst doAPIEndpointDelete = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Delete');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.IDRecord = 0;\n\ttmpRequestState.RecordCount = { Count:0 };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (typeof(pRequest.params.IDRecord) === 'string')\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.IDRecord = pRequest.params.IDRecord;\n\t\t\t\t}\n\t\t\t\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.IDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t\t\t\t}\n\t\t\t\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'string')\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.IDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t\t\t\t}\n\t\t\t\t// Although the Meadow delete behavior does allow multiple deletes, we require an identifier.\n\t\t\t\t// If a developer wants bulk delete, it will require a custom endpoint.\n\t\t\t\tif (tmpRequestState.IDRecord < 1)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record delete failure - a valid record ID is required in the passed-in record.', 500));\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpRequestState.IDRecord);\n\t\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Delete-QueryConfiguration`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Load the record so we can do security checks on it\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not found.', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Delete-PreOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Do the delete\n\t\t\t\tthis.DAL.doDelete(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// MySQL returns the number of rows deleted\n\t\t\t\t\t\ttmpRequestState.RecordCount.Count = pCount;\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Delete-PostOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.RecordCount);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Deleted ${tmpRequestState.RecordCount.Count} ${this.DAL.scope} records with ID ${tmpRequestState.IDRecord}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointDelete;","/**\n* Meadow Endpoint - Undelete a Record\n*/\nconst doAPIEndpointUndelete = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Undelete');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\t\tvar tmpIDRecord = 0;\n\tif (typeof(pRequest.params.IDRecord) === 'string')\n\t{\n\t\ttmpIDRecord = pRequest.params.IDRecord;\n\t}\n\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'number')\n\t{\n\t\ttmpIDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t}\n\telse if (typeof(pRequest.body[this.DAL.defaultIdentifier]) === 'string')\n\t{\n\t\ttmpIDRecord = pRequest.body[this.DAL.defaultIdentifier];\n\t}\n\t// Although the undelete request does allow multiple undeletes, we require an identifier.\n\t// TODO: Decide if we want to keep this pattern similar to Delete, or, if we want to change it to allow bulk undeletes.\n\tif (tmpIDRecord < 1)\n\t{\n\t\treturn fStageComplete(this.ErrorHandler.getError('Record undelete failure - a valid record ID is required.', 500));\n\t}\n\n\ttmpRequestState.RecordCount = {Count:0};\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Validate that the schema has a deleted bit\n\t\t\t\tvar tmpSchema = this.DAL.schema;\n\t\t\t\tvar tmpHasDeletedBit = false;\n\t\t\t\tfor (let i = 0; i < tmpSchema.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (tmpSchema[i].Type == 'Deleted')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpHasDeletedBit = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!tmpHasDeletedBit)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No undelete bit on record.', 500));\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Now see if the record, with this identifier, for this user, exists with the deleted bit set to 1\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpIDRecord);\n\t\t\t\ttmpRequestState.Query.addFilter('Deleted', 1);\n\t\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Load the record so we can do security checks on it\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not found.', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Undelete-PreOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Do the undelete\n\t\t\t\tthis.DAL.doUndelete(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pCount) =>\n\t\t\t\t\t{\n\t\t\t\t\t\t// MySQL returns the number of rows deleted\n\t\t\t\t\t\ttmpRequestState.RecordCount = {Count:pCount};\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.BehaviorInjection.runBehavior(`Undelete-PostOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.RecordCount);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Undeleted '+tmpRequestState.RecordCount.Count+' records with ID '+tmpIDRecord+'.');\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointUndelete;","/**\n* Meadow Endpoint - Read a Record\n*/\nconst doAPIEndpointRead = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Read');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Read-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!pRequest.params.IDRecord && pRequest.params.GUIDRecord)\n\t\t\t\t{\n\t\t\t\t\t// We use a custom name for this (RequestDefaultIdentifier) in case there is a query with a dot in the default identifier.\n\t\t\t\t\ttmpRequestState.RecordSearchCriteria = `${this.DAL.defaultGUIdentifier} = ${pRequest.params.GUIDRecord}`;\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultGUIdentifier, pRequest.params.GUIDRecord, '=', 'AND', 'RequestDefaultIdentifier');\n\t\t\t\t}\n\t\t\t\telse if (pRequest.params.IDRecord)\n\t\t\t\t{\n\t\t\t\t\t// We use a custon name for this (RequestDefaultIdentifier) in case there is a query with a dot in the default identifier.\n\t\t\t\t\ttmpRequestState.RecordSearchCriteria = `${this.DAL.defaultIdentifier} = ${pRequest.params.IDRecord}`;\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, pRequest.params.IDRecord, '=', 'AND', 'RequestDefaultIdentifier');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No ID Provided', 400));\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Read-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tthis.DAL.doRead(tmpRequestState.Query, (pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not Found', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcatch (pQueryError)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(pQueryError);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfBehaviorInjector(`Read-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read Record Where ${tmpRequestState.RecordSearchCriteria}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointRead;","/**\n* Meadow Endpoint - Read a list of Records with a specified set of columns, distinct by those columns.\n*/\nconst marshalDistinctList = require('./Meadow-Marshal-DistinctList.js');\n\nconst doAPIEndpointReadDistinct = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadDistinct');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.DistinctColumns;\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query = this.DAL.query.setDistinct(true);\n\n\t\t\tlet tmpCap = false;\n\t\t\tlet tmpBegin = false;\n\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t{\n\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin, 10);\n\t\t\t}\n\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t{\n\t\t\t\ttmpCap = parseInt(pRequest.params.Cap, 10);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//maximum number of records to return by default on Read queries. Override via \"MeadowDefaultMaxCap\" fable setting.\n\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t}\n\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t{\n\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t}\n\t\t\telse if (pRequest.params.Filter)\n\t\t\t{\n\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t}\n\t\t\tif (typeof(pRequest.params.Columns) === 'string')\n\t\t\t{\n\t\t\t\ttmpRequestState.DistinctColumns = pRequest.params.Columns.split(',');\n\t\t\t\tif (!tmpRequestState.DistinctColumns)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete({Code:400, Message:'Columns to distinct on must be provided.'});\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setDataElements(tmpRequestState.DistinctColumns);\n\t\t\t}\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t},\n\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t{\n\t\t\tif (pRecords.length < 1)\n\t\t\t{\n\t\t\t\tpRecords = [];\n\t\t\t}\n\t\t\ttmpRequestState.Records = pRecords;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.ResultRecords = marshalDistinctList.call(this, tmpRequestState.Records, pRequest, tmpRequestState.DistinctColumns);\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.ResultRecords, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a recordset distinct lite list with ${tmpRequestState.ResultRecords.length} results.`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointReadDistinct;","/**\n* Meadow Endpoint - Read a list of lite Records (for Drop-downs and such)\n*/\nconst marshalLiteList = require('./Meadow-Marshal-LiteList.js');\n\nconst doAPIEndpointReadLite = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadsLite');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t// 1a. Get the records\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\t// TODO: Limit the query to the columns we need for the templated expression\n\n\t\t\t\tvar tmpCap = false;\n\t\t\t\tvar tmpBegin = false;\n\t\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin, 10);\n\t\t\t\t}\n\t\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpCap = parseInt(pRequest.params.Cap, 10);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//maximum number of records to return by default on Read queries. Override via \"MeadowDefaultMaxCap\" fable setting.\n\t\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t\t{\n\t\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t\t}\n\t\t\t\telse if (pRequest.params.Filter)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t\t},\n\t\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (pRecords.length < 1)\n\t\t\t\t{\n\t\t\t\t\tpRecords = [];\n\t\t\t\t}\n\t\t\t\ttmpRequestState.RawRecords = pRecords;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Records = marshalLiteList.call(this, tmpRequestState.RawRecords, pRequest, (typeof(pRequest.params.ExtraColumns) === 'string') ? pRequest.params.ExtraColumns.split(',') : []);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.Records, fNext);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a recordset lite list with ${tmpRequestState.Records.length} results`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError, pResultRecords) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadLite;","/**\n* Meadow Endpoint - Read the Max Value of a Column in a Set\n*/\nconst doAPIEndpointReadMax = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadMax');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.ColumnName =  pRequest.params.ColumnName;\n\t\t\t\ttmpRequestState.Query.setSort({Column:tmpRequestState.ColumnName, Direction:'Descending'});\n\t\t\t\ttmpRequestState.Query.setCap(1);\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`ReadMax-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query, fStageComplete);\n\t\t\t},\n\t\t\t(pQuery, pRecord, fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!pRecord)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not Found', 404));\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.BehaviorInjection.runBehavior(`ReadMax-PostOperation`, this, pRequest, tmpRequestState, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read max record of ${this.DAL.scope} on ${tmpRequestState.ColumnName}`);\n\t\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadMax;","/**\n* Meadow Endpoint - Read a select list of Records (for Drop-downs and such)\n*/\nconst doAPIEndpointReadSelectList = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadsBy');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\tvar tmpCap = false;\n\t\t\t\tvar tmpBegin = false;\n\t\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin);\n\t\t\t\t}\n\t\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpCap = parseInt(pRequest.params.Cap);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t\t},\n\t\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (pRecords.length < 1)\n\t\t\t\t{\n\t\t\t\t\tpRecords = [];\n\t\t\t\t}\n\n\t\t\t\ttmpRequestState.Records = pRecords;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.SelectList = [];\n\n\t\t\t\tfor (var i = 0; i < tmpRequestState.Records.length; i++)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.SelectList.push\n\t\t\t\t\t(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tHash: tmpRequestState.Records[i][this.DAL.defaultIdentifier],\n\t\t\t\t\t\t\tValue: this.BehaviorInjection.processTemplate('SelectList', {Record:tmpRequestState.Records[i]}, this.DAL.scope+' #<%= Record.'+this.DAL.defaultIdentifier+'%>')\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.SelectList, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a recordset lite list with ${tmpRequestState.SelectList.length} results.`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError, pResultRecords) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadSelectList;","/**\n* Meadow Endpoint - Read a Set of Records\n*/\nconst doAPIEndpointReads = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Reads');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\tvar tmpCap = false;\n\t\t\tvar tmpBegin = false;\n\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t{\n\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin);\n\t\t\t}\n\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t{\n\t\t\t\ttmpCap = parseInt(pRequest.params.Cap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t}\n\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\t\t\tif (typeof(pRequest.params.Filter) === 'string')\n\t\t\t{\n\t\t\t\t// If a filter has been passed in, parse it and add the values to the query.\n\t\t\t\tthis.parseFilter(pRequest.params.Filter, tmpRequestState.Query);\n\t\t\t}\n\t\t\telse if (pRequest.params.Filter)\n\t\t\t{\n\t\t\t\ttmpRequestState.Query.setFilter(pRequest.params.Filter);\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.DAL.doReads(tmpRequestState.Query, fStageComplete);\n\t\t},\n\t\t(pQuery, pRecords, fStageComplete) =>\n\t\t{\n\t\t\tif (!pRecords)\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No records found.', 404));\n\t\t\t}\n\t\t\ttmpRequestState.Records = pRecords;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\tfBehaviorInjector(`Reads-PostOperation`),\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.doStreamRecordArray(pResponse, tmpRequestState.Records, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, 'Read a list of records.');\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointReads;","/**\n* Meadow Endpoint - Read a Record\n*/\nconst doAPIEndpointReadsBy = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'ReadsBy');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\t// 1. Construct the Query\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\tvar tmpCap = false;\n\t\t\t\tvar tmpBegin = false;\n\t\t\t\tif (typeof(pRequest.params.Begin) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Begin) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpBegin = parseInt(pRequest.params.Begin);\n\t\t\t\t}\n\t\t\t\tif (typeof(pRequest.params.Cap) === 'string' ||\n\t\t\t\t\ttypeof(pRequest.params.Cap) === 'number')\n\t\t\t\t{\n\t\t\t\t\ttmpCap = parseInt(pRequest.params.Cap);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//maximum number of records to return by default on Read queries. Override via \"MeadowDefaultMaxCap\" fable setting.\n\t\t\t\t\ttmpCap = (this.settings['MeadowDefaultMaxCap']) || 250;\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Query.setCap(tmpCap).setBegin(tmpBegin);\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tfunction addField(pByField, pByValue)\n\t\t\t\t{\n\t\t\t\t\tif (pByValue.constructor === Array)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Query.addFilter(pByField, pByValue, 'IN', 'AND', 'RequestByField');\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpRequestState.Query.addFilter(pByField, pByValue, '=', 'AND', 'RequestByField');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar tmpFilters = pRequest.params.Filters;\n\t\t\t\tif (tmpFilters &&\n\t\t\t\t\ttmpFilters.constructor === Array)\n\t\t\t\t{\n\t\t\t\t\ttmpFilters.forEach(function(filter)\n\t\t\t\t\t{\n\t\t\t\t\t\taddField(filter.ByField, filter.ByValue);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\taddField(pRequest.params.ByField, pRequest.params.ByValue);\n\t\t\t\t}\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-QueryConfiguration`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.DAL.doReads(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecords) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!pRecords)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('No records found.', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.Records = pRecords;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t},\n\t\t\tfBehaviorInjector(`Reads-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, tmpRequestState.Records, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Read a list of records by ${pRequest.params.ByField} = ${pRequest.params.ByValue}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t// 7. Return the results to the user\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointReadsBy;","/**\n* Meadow Operation - Marshal an array of records into a distinct list\n*/\nconst marshalDistinctList = function(pRecords, pRequest, pFieldList)\n{\n\tif (pRecords.length < 1)\n\t\treturn [];\n\n\tlet tmpDistinctList = [];\n\t// Allow the caller to pass in a list of fields.\n\tlet tmpFieldList = (typeof(pFieldList) !== 'undefined') ? pFieldList : [];\n\n\t// See if this record has a GUID in the schema\n\tlet tmpGUID = (this.DAL.defaultGUIdentifier && this.DAL.defaultGUIdentifier.length > 0) ? this.DAL.defaultGUIdentifier : false;\n\t// Peek at the first record to check for updatedate\n\tlet tmpHasUpdateDate = (pRecords[0].hasOwnProperty('UpdateDate')) ? true : false;\n\t//Include all GUID and ID fields on the record\n\tlet tmpRecordFields = Object.keys(pRecords[0]);\n\n\tlet h = 0;\n\twhile (h < tmpFieldList.length)\n\t{\n\t\t// Remove any fields in the list that aren't in the first record.\n\t\tif (!pRecords[0].hasOwnProperty(tmpFieldList[0]))\n\t\t\ttmpFieldList.splice(h, 1);\n\t\telse\n\t\t\th++;\n\t}\n\n\tfor (let i = 0; i < pRecords.length; i++)\n\t{\n\t\tlet tmpDistinctRecord = { };\n\n\t\ttmpFieldList.forEach(\n\t\t\t(pField) =>\n\t\t\t{\n\t\t\t\ttmpDistinctRecord[pField] = pRecords[i][pField];\n\t\t\t});\n\n\t\ttmpDistinctList.push(tmpDistinctRecord);\n\t}\n\n\treturn tmpDistinctList;\n};\n\nmodule.exports = marshalDistinctList;","/**\n* Meadow Operation - Marshal an array of records into a lite list\n*/\nconst marshalLiteList = function(pRecords, pRequest, pFieldList)\n{\n\tif (pRecords.length < 1)\n\t\treturn [];\n\n\tlet tmpLiteList = [];\n\t// Allow the caller to pass in a list of fields.\n\tlet tmpFieldList = (typeof(pFieldList) !== 'undefined') ? pFieldList : [];\n\n\t// See if this record has a GUID in the schema\n\tlet tmpGUID = (this.DAL.defaultGUIdentifier && this.DAL.defaultGUIdentifier.length > 0) ? this.DAL.defaultGUIdentifier : false;\n\t// Peek at the first record to check for updatedate\n\tlet tmpHasUpdateDate = (pRecords[0].hasOwnProperty('UpdateDate')) ? true : false;\n\t//Include all GUID and ID fields on the record\n\tlet tmpRecordFields = Object.keys(pRecords[0]);\n\ttmpRecordFields.forEach(\n\t\t(pField) =>\n\t\t{\n\t\t\tif (pField.indexOf('ID') === 0 ||\n\t\t\t\tpField.indexOf('GUID') === 0 ||\n\t\t\t\tpField == 'CreatingIDUser') //we should always include owner info\n\t\t\t{\n\t\t\t\ttmpFieldList.push(pField);\n\t\t\t}\n\t\t});\n\n\tlet h = 0;\n\twhile (h < tmpFieldList.length)\n\t{\n\t\t// Remove any fields in the list that aren't in the first record.\n\t\tif (!pRecords[0].hasOwnProperty(tmpFieldList[0]))\n\t\t\ttmpFieldList.splice(h, 1);\n\t\telse\n\t\t\th++;\n\t}\n\n\tfor (let i = 0; i < pRecords.length; i++)\n\t{\n\t\tlet tmpLiteRecord = (\n\t\t\t{\n\t\t\t\tValue: this.BehaviorInjection.processTemplate('SelectList', {Record:pRecords[i]}, this.DAL.scope+' #<%= Record.'+this.DAL.defaultIdentifier+'%>')\n\t\t\t});\n\t\ttmpLiteRecord[this.DAL.defaultIdentifier] = pRecords[i][this.DAL.defaultIdentifier];\n\n\t\tif (tmpGUID)\n\t\t\ttmpLiteRecord[tmpGUID] = pRecords[i][tmpGUID];\n\t\tif (tmpHasUpdateDate)\n\t\t\ttmpLiteRecord['UpdateDate'] = pRecords[i].UpdateDate;\n\n\t\ttmpFieldList.forEach(\n\t\t\t(pField) =>\n\t\t\t{\n\t\t\t\ttmpLiteRecord[pField] = pRecords[i][pField];\n\t\t\t});\n\n\t\ttmpLiteList.push(tmpLiteRecord);\n\t}\n\n\treturn tmpLiteList;\n};\n\nmodule.exports = marshalLiteList;","/**\n* Meadow Endpoint - Get a New, empty Record\n*/\nconst doAPIEndpointNew = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'New');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\tfBehaviorInjector(`New-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// If during the PreOperation this was set, we can\n\t\t\t\tif (!tmpRequestState.EmptyEntityRecord)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.EmptyEntityRecord = this.extend({}, this.DAL.schemaFull.defaultObject);\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`New-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.EmptyEntityRecord);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Delivered New ${this.DAL.scope} Record`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointNew;","/**\n* Meadow Endpoint - Get the Record Schema\n*/\nconst doAPIEndpointSchema = function (pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Schema');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\tfBehaviorInjector(`Schema-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// If during the PreOperation this was set, we won't overwrite\n\t\t\t\tif (!pRequest.JSONSchema)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.JSONSchema = this.extend({}, this.DAL.jsonSchema);\n\t\t\t\t}\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Schema-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.JSONSchema);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Delivered JSONSchema for ${this.DAL.scope}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointSchema;","/**\n* Meadow Endpoint - Validate a Record\n*/\nconst doAPIEndpointValidate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Validate');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t\t[\n\t\t\tfBehaviorInjector(`Validate-PreOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (typeof(pRequest.body) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record validate failure - a valid JSON object is required.', 500));\n\t\t\t\t}\n\t\t\t\ttmpRequestState.Record = pRequest.body;\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.RecordValidation = this.DAL.schemaFull.validateObject(tmpRecord);\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\tfBehaviorInjector(`Validate-PostOperation`),\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tpResponse.send(tmpRequestState.RecordValidation);\n\t\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Validated Record for ${this.DAL.scope} - ${tmpRequestState.RecordValidation}`);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t],\n\t\t(pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t}\n\t);\n};\n\nmodule.exports = doAPIEndpointValidate;","/**\n* Meadow Endpoint - Update a set of Records\n*/\nconst doUpdate = require('./Meadow-Operation-Update.js');\n\nconst doAPIEndpointUpdate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'UpdateBulk');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.UpdatedRecords = [];\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!Array.isArray(pRequest.body))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record update failure - a valid record is required.', 500));\n\t\t\t\t}\n\n\t\t\t\tpRequest.BulkRecords = pRequest.body;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tlibAsync.eachSeries(pRequest.BulkRecords,\n\t\t\t\t\t(pRecord, fCallback) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tdoUpdate(pRecord, pRequest, tmpRequestState, pResponse, fCallback);\n\t\t\t\t\t}, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, pRequest.UpdatedRecords, fStageComplete);\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\n\nmodule.exports = doAPIEndpointUpdate;","/**\n* Meadow Endpoint - Update a Record\n*/\nconst doUpdate = require('./Meadow-Operation-Update.js');\n\nconst doAPIEndpointUpdate = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Update');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (typeof(pRequest.body) !== 'object')\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record update failure - a valid record is required.', 400));\n\t\t\t}\n\t\t\tif (pRequest.body[this.DAL.defaultIdentifier] < 1)\n\t\t\t{\n\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record update failure - a valid record ID is required in the passed-in record.', 400));\n\t\t\t}\n\n\t\t\ttmpRequestState.Record = pRequest.body;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tdoUpdate.call(this, pRequest.body, pRequest, tmpRequestState, pResponse, fStageComplete);\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tif (tmpRequestState.RecordUpdateError)\n\t\t\t{\n\t\t\t\treturn fStageComplete(tmpRequestState.RecordUpdateErrorObject);\n\t\t\t}\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\treturn fStageComplete();\n\t\t}\n\t],\n\t(pError) =>\n\t{\n\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t});\n};\n\nmodule.exports = doAPIEndpointUpdate;\n","/**\n* Meadow Operation - Update a record\n*/\nconst doUpdate = function(pRecordToModify, pRequest, pRequestState, pResponse, fCallback, pOptionalCachedUpdatingRecord)\n{\n\t// This is a virtual operation\n\tlet tmpRequestState = cloneAsyncSafeRequestState(pRequestState, 'doUpdate');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\t// If there is not a default identifier or cached record, fail\n\tif ((pRecordToModify[this.DAL.defaultIdentifier] < 1) && (typeof(pOptionalCachedUpdatingRecord) === 'undefined'))\n\t{\n\t\treturn fCallback('Record update failure - a valid record ID is required in the passed-in record.');\n\t}\n\n\tif (!Array.isArray(tmpRequestState.ParentRequestState.UpdatedRecords))\n\t{\n\t\ttmpRequestState.ParentRequestState.UpdatedRecords = [];\n\t}\n\n\tthis.waterfall(\n\t[\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.RecordToModify = pRecordToModify;\n\n\t\t\tif (typeof(pOptionalCachedUpdatingRecord) !== 'undefined')\n\t\t\t{\n\t\t\t\t// Use the cached updating record instead of reading a record.\n\t\t\t\ttmpRequestState.OriginalRecord = pOptionalCachedUpdatingRecord;\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpRequestState.RecordToModify[this.DAL.defaultIdentifier]);\n\n\t\t\t\t// Load the record so we can do security checks on it\n\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record not Found', 404));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpRequestState.OriginalRecord = pRecord;\n\t\t\t\t\t\treturn fStageComplete();\n\t\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query = this.DAL.query;\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.Query.setIDUser(tmpRequestState.SessionData.UserID);\n\t\t\ttmpRequestState.Query.addRecord(tmpRequestState.RecordToModify);\n\n\t\t\treturn fStageComplete();\n\t\t},\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\tthis.DAL.doUpdate(tmpRequestState.Query,\n\t\t\t\t(pError, pQuery, pReadQuery, pRecord) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t}\n\t\t\t\t\tif (!pRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn fStageComplete('Error updating a record.');\n\t\t\t\t\t}\n\t\t\t\t\ttmpRequestState.Record = pRecord;\n\t\t\t\t\treturn fStageComplete();\n\t\t\t\t});\n\t\t},\n\t\t(fStageComplete) => { return this.BehaviorInjection.runBehavior(`Update-PostOperation`, this, pRequest, tmpRequestState, fStageComplete); },\n\t\t(fStageComplete) =>\n\t\t{\n\t\t\ttmpRequestState.ParentRequestState.UpdatedRecords.push(tmpRequestState.Record);\n\t\t\tthis.log.requestCompletedSuccessfully(pRequest, tmpRequestState, `Updated record with ID ${tmpRequestState.Record[this.DAL.defaultIdentifier]}`);\n\t\t\treturn fStageComplete();\n\t\t}\n\t], (pError) =>\n\t{\n\t\tif (pError)\n\t\t{\n\t\t\ttmpRequestState.UpdatingRecord.Error = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.RecordUpdateError = true;\n\t\t\ttmpRequestState.ParentRequestState.RecordUpdateErrorObject = pError;\n\n\t\t\ttmpRequestState.ParentRequestState.UpdatedRecords.push(tmpRequestState.RecordToCreate);\n\t\t}\n\n\t\treturn fCallback();\n\t});\n};\n\nmodule.exports = doUpdate;","/**\n* Meadow Endpoint - Upsert a set of Records\n*/\nconst doUpsert = require('./Meadow-Operation-Upsert.js');\n\nconst marshalLiteList = require('../read/Meadow-Marshal-LiteList.js');\n\nconst doAPIEndpointUpserts = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'UpsertBulk');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\ttmpRequestState.CreatedRecords = [];\n\ttmpRequestState.UpdatedRecords = [];\n\ttmpRequestState.UpsertedRecords = [];\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (!Array.isArray(pRequest.body))\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record upsert failure - a valid record is required.', 500));\n\t\t\t\t}\n\n\t\t\t\ttmpRequestState.BulkRecords = pRequest.body;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tlibAsync.eachSeries(tmpRequestState.BulkRecords,\n\t\t\t\t\t(pRecord, fCallback) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tdoUpsert.call(this, pRecord, pRequest, tmpRequestState, pResponse, fCallback);\n\t\t\t\t\t}, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\treturn this.doStreamRecordArray(pResponse, marshalLiteList.call(this, pRequest.UpsertedRecords, pRequest), fStageComplete);\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\nmodule.exports = doAPIEndpointUpserts;","/**\n* Meadow Endpoint - Upsert (Insert OR Update) a Record\n*/\nvar doUpsert = require('./Meadow-Operation-Upsert.js');\n\nvar doAPIEndpointUpsert = function(pRequest, pResponse, fNext)\n{\n\tlet tmpRequestState = this.initializeRequestState(pRequest, 'Upsert');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\t// Configure the request for the generic create & update operations\n\ttmpRequestState.CreatedRecords = [];\n\ttmpRequestState.UpdatedRecords = [];\n\ttmpRequestState.UpsertedRecords = [];\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t//1. Validate request body to ensure it is a valid record\n\t\t\t\tif (typeof(tmpRequestState.body) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record upsert failure - a valid record is required.', 500));\n\t\t\t\t}\n\n\t\t\t\ttmpRequestState.RecordToUpsert = pRequest.body;\n\n\t\t\t\treturn fStageComplete();\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tdoUpsert.call(this, tmpRequestState.RecordToUpsert, pRequest, tmpRequestState, pResponse, fStageComplete);\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\tif (tmpRequestState.RecordUpsertError)\n\t\t\t\t{\n\t\t\t\t\treturn fStageComplete(tmpRequestState.RecordUpsertErrorMessage);\n\t\t\t\t}\n\t\t\t\tpResponse.send(tmpRequestState.Record);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\treturn this.ErrorHandler.handleErrorIfSet(pRequest, tmpRequestState, pResponse, pError, fNext);\n\t\t});\n};\n\nmodule.exports = doAPIEndpointUpsert;","/**\n* Meadow Operation - Upsert a record\n*/\nconst doCreate = require('../create/Meadow-Operation-Create.js');\nconst doUpdate = require('../update/Meadow-Operation-Update.js');\n\nconst doUpsert = function(pRecordToUpsert, pRequest, pRequestState, pResponse, fCallback)\n{\n\tlet tmpRequestState = this.cloneAsyncSafeRequestState(pRequest, 'Upsert');\n\tlet fBehaviorInjector = (pBehaviorHash) => { return (fStageComplete) => { this.BehaviorInjection.runBehavior(pBehaviorHash, this, pRequest, tmpRequestState, fStageComplete); }; };\n\n\n\tthis.waterfall(\n\t\t[\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\ttmpRequestState.Query = this.DAL.query;\n\n\t\t\t\t// Prepare to gather requirements for upserting\n\t\t\t\ttmpRequestState.Record = pRecordToUpsert;\n\n\t\t\t\t// This operation will be create only if there is no GUID or ID in the record bundle\n\t\t\t\ttmpRequestState.UpsertCreateOnly = true;\n\n\t\t\t\t// See if there is a default identifier or default GUIdentifier\n\t\t\t\tif ((typeof(tmpRequestState.Record[this.DAL.defaultGUIdentifier]) !== 'undefined') && tmpRequestState.Record[this.DAL.defaultGUIdentifier].length > 0)\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultGUIdentifier, tmpRequestState.Record[this.DAL.defaultGUIdentifier]);\n\t\t\t\t\ttmpRequestState.UpsertCreateOnly = false;\n\t\t\t\t}\n\t\t\t\tif ((typeof(tmpRequestState.Record[this.DAL.defaultIdentifier]) !== 'undefined') && (tmpRequestState.Record[this.DAL.defaultIdentifier] > 0))\n\t\t\t\t{\n\t\t\t\t\ttmpRequestState.Query.addFilter(this.DAL.defaultIdentifier, tmpRequestState.Record[this.DAL.defaultIdentifier]);\n\t\t\t\t\ttmpRequestState.UpsertCreateOnly = false;\n\t\t\t\t}\n\n\t\t\t\tif (tmpRequestState.UpsertCreateOnly)\n\t\t\t\t{\n\t\t\t\t\tdoCreate.call(this, tmpRequestState.Record, pRequest, pResponse, fStageComplete);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.DAL.doRead(tmpRequestState.Query,\n\t\t\t\t\t\t(pError, pQuery, pRecord) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pError)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Return the error, because there was an error.\n\t\t\t\t\t\t\t\treturn fStageComplete(pError);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!pError && !pRecord)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Record not found -- do a create.\n\t\t\t\t\t\t\t\tdoCreate.call(this, tmpRequestState.Record, pRequest, pResponse, fStageComplete);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Set the default ID in the passed-in record if it doesn't exist..\n\t\t\t\t\t\t\t\tif (!tmpRequestState.Record.hasOwnProperty(this.DAL.defaultIdentifier))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmpRequestState.Record[this.DAL.defaultIdentifier] = pRecord[this.DAL.defaultIdentifier];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// If the found record does not match the passed ID --- what the heck?!\n\t\t\t\t\t\t\t\tif (tmpRequestState.Record[this.DAL.defaultIdentifier] != pRecord[this.DAL.defaultIdentifier])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn fStageComplete(this.ErrorHandler.getError('Record IDs do not match', 500));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Record found -- do an update.  Use the cached record, though.\n\t\t\t\t\t\t\t\tdoUpdate.call(this, tmpRequestState.Record, pRequest, pResponse, fStageComplete, pRecord);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\t(fStageComplete) =>\n\t\t\t{\n\t\t\t\t// Now stuff the record into the upserted array\n\t\t\t\tpRequest.UpsertedRecords.push(tmpRequestState.Record);\n\t\t\t\treturn fStageComplete();\n\t\t\t}\n\t\t], (pError) =>\n\t\t{\n\t\t\tif (pError)\n\t\t\t{\n\t\t\t\tpRecordToUpsert.Error = 'Error upserting record:'+pError;\n\t\t\t\ttmpRequestState.RecordUpsertError = true;\n\t\t\t\ttmpRequestState.RecordUpsertErrorMessage = pError;\n\t\t\t\tpRequest.UpsertedRecords.push(pRecordToUpsert);\n\t\t\t\tpRequest.CommonServices.log.error('Error upserting record:'+pError, {SessionID:pRequest.UserSession.SessionID, RequestID:pRequest.RequestUUID, RequestURL:pRequest.url, Action:this.DAL.scope+'-'+pRequest.MeadowOperation, Stack: pError.stack }, pRequest);\n\t\t\t}\n\n\t\t\treturn fCallback();\n\t\t});\n};\n\nmodule.exports = doUpsert;"]}